/**
 * Hydrogen Atom API
 * The Hydrogen Atom API
 *
 * OpenAPI spec version: 1.0.1
 * Contact: info@hydrogenplatform.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 *
 * Swagger Codegen version: 2.4.8-SNAPSHOT
 *
 * Do not edit the class manually.
 *
 */

(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['ApiClient'], factory);
  } else if (typeof module === 'object' && module.exports) {
    // CommonJS-like environments that support module.exports, like Node.
    module.exports = factory(require('../ApiClient'));
  } else {
    // Browser globals (root is window)
    if (!root.atom_api) {
      root.atom_api = {};
    }
    root.atom_api.MonteCarlo = factory(root.atom_api.ApiClient);
  }
}(this, function(ApiClient) {
  'use strict';




  /**
   * The MonteCarlo model module.
   * @module model/MonteCarlo
   * @version 1.0.1
   */

  /**
   * Constructs a new <code>MonteCarlo</code>.
   * @alias module:model/MonteCarlo
   * @class
   * @param cf {Array.<Array.<Number>>} The cash flows to occur during the simulation
   * @param mu {Array.<Number>} The periodic mean portfolio return
   * @param sigma {Array.<Number>} The periodic portfolio standard deviation
   */
  var exports = function(cf, mu, sigma) {
    var _this = this;

    _this['cf'] = cf;
    _this['mu'] = mu;
    _this['sigma'] = sigma;










  };

  /**
   * Constructs a <code>MonteCarlo</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/MonteCarlo} obj Optional instance to populate.
   * @return {module:model/MonteCarlo} The populated <code>MonteCarlo</code> instance.
   */
  exports.constructFromObject = function(data, obj) {
    if (data) {
      obj = obj || new exports();

      if (data.hasOwnProperty('cf')) {
        obj['cf'] = ApiClient.convertToType(data['cf'], [['Number']]);
      }
      if (data.hasOwnProperty('mu')) {
        obj['mu'] = ApiClient.convertToType(data['mu'], ['Number']);
      }
      if (data.hasOwnProperty('sigma')) {
        obj['sigma'] = ApiClient.convertToType(data['sigma'], ['Number']);
      }
      if (data.hasOwnProperty('ret_mod')) {
        obj['ret_mod'] = ApiClient.convertToType(data['ret_mod'], ['Number']);
      }
      if (data.hasOwnProperty('init_bal')) {
        obj['init_bal'] = ApiClient.convertToType(data['init_bal'], 'Number');
      }
      if (data.hasOwnProperty('n')) {
        obj['n'] = ApiClient.convertToType(data['n'], 'Number');
      }
      if (data.hasOwnProperty('remove_outliers')) {
        obj['remove_outliers'] = ApiClient.convertToType(data['remove_outliers'], 'Boolean');
      }
      if (data.hasOwnProperty('result_type')) {
        obj['result_type'] = ApiClient.convertToType(data['result_type'], 'String');
      }
      if (data.hasOwnProperty('p')) {
        obj['p'] = ApiClient.convertToType(data['p'], ['Number']);
      }
      if (data.hasOwnProperty('min_bal')) {
        obj['min_bal'] = ApiClient.convertToType(data['min_bal'], ['Number']);
      }
      if (data.hasOwnProperty('max_bal')) {
        obj['max_bal'] = ApiClient.convertToType(data['max_bal'], ['Number']);
      }
      if (data.hasOwnProperty('min_sample')) {
        obj['min_sample'] = ApiClient.convertToType(data['min_sample'], ['Number']);
      }
      if (data.hasOwnProperty('max_sample')) {
        obj['max_sample'] = ApiClient.convertToType(data['max_sample'], ['Number']);
      }
    }
    return obj;
  }

  /**
   * The cash flows to occur during the simulation
   * @member {Array.<Array.<Number>>} cf
   */
  exports.prototype['cf'] = undefined;
  /**
   * The periodic mean portfolio return
   * @member {Array.<Number>} mu
   */
  exports.prototype['mu'] = undefined;
  /**
   * The periodic portfolio standard deviation
   * @member {Array.<Number>} sigma
   */
  exports.prototype['sigma'] = undefined;
  /**
   * A periodic return modifier
   * @member {Array.<Number>} ret_mod
   */
  exports.prototype['ret_mod'] = undefined;
  /**
   * The initial investment at time zero
   * @member {Number} init_bal
   */
  exports.prototype['init_bal'] = undefined;
  /**
   * The number of simulations to run
   * @member {Number} n
   */
  exports.prototype['n'] = undefined;
  /**
   * If true, remove outlying results
   * @member {Boolean} remove_outliers
   * @default false
   */
  exports.prototype['remove_outliers'] = false;
  /**
   * The type of simulation results to display in the output
   * @member {module:model/MonteCarlo.ResultTypeEnum} result_type
   * @default 'raw'
   */
  exports.prototype['result_type'] = 'raw';
  /**
   * Custom result percentiles
   * @member {Array.<Number>} p
   */
  exports.prototype['p'] = undefined;
  /**
   * A lower bound to enforce on the periodic balance. Each item in the array corresponds to a period in the simulation. If the length of the array is less than the number of simulation periods, it is conformed to the appropriate length by persisting the final value in the array.
   * @member {Array.<Number>} min_bal
   */
  exports.prototype['min_bal'] = undefined;
  /**
   * An upper bound to enforce on the periodic balance. Each item in the array corresponds to a period in the simulation. If the length of the array is less than the number of simulation periods, it is conformed to the appropriate length by persisting the final value in the array.
   * @member {Array.<Number>} max_bal
   */
  exports.prototype['max_bal'] = undefined;
  /**
   * A lower bound to enforce on the randomly sampled periodic return. Each item in the array corresponds to a period in the simulation. If the length of the array is less than the number of simulation periods, it is conformed to the appropriate length by persisting the final value in the array.
   * @member {Array.<Number>} min_sample
   */
  exports.prototype['min_sample'] = undefined;
  /**
   * An upper bound to enforce on the randomly sampled periodic return. Each item in the array corresponds to a period in the simulation. If the length of the array is less than the number of simulation periods, it is conformed to the appropriate length by persisting the final value in the array.
   * @member {Array.<Number>} max_sample
   */
  exports.prototype['max_sample'] = undefined;


  /**
   * Allowed values for the <code>result_type</code> property.
   * @enum {String}
   * @readonly
   */
  exports.ResultTypeEnum = {
    /**
     * value: "raw"
     * @const
     */
    "raw": "raw",
    /**
     * value: "mean"
     * @const
     */
    "mean": "mean",
    /**
     * value: "median"
     * @const
     */
    "median": "median",
    /**
     * value: "percentiles"
     * @const
     */
    "percentiles": "percentiles",
    /**
     * value: "custom"
     * @const
     */
    "custom": "custom"  };


  return exports;
}));


