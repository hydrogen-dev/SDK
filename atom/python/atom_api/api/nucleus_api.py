# coding: utf-8

"""
    Hydrogen Atom API

    The Hydrogen Atom API  # noqa: E501

    OpenAPI spec version: 1.0.1
    Contact: info@hydrogenplatform.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from atom_api.api_client import ApiClient


class NucleusApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def delete_account(self, account_id, **kwargs):  # noqa: E501
        """Delete an account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_account(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_account_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_account_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def delete_account_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Delete an account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_account_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `delete_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account/{account_id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_account_allocation(self, account_allocation_id, **kwargs):  # noqa: E501
        """Delete an account allocation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_account_allocation(account_allocation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_allocation_id: UUID of an account allocation (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_account_allocation_with_http_info(account_allocation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_account_allocation_with_http_info(account_allocation_id, **kwargs)  # noqa: E501
            return data

    def delete_account_allocation_with_http_info(self, account_allocation_id, **kwargs):  # noqa: E501
        """Delete an account allocation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_account_allocation_with_http_info(account_allocation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_allocation_id: UUID of an account allocation (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_allocation_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_account_allocation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_allocation_id' is set
        if ('account_allocation_id' not in params or
                params['account_allocation_id'] is None):
            raise ValueError("Missing the required parameter `account_allocation_id` when calling `delete_account_allocation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_allocation_id' in params:
            path_params['account_allocation_id'] = params['account_allocation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account_allocation/{account_allocation_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_account_permission(self, account_id, **kwargs):  # noqa: E501
        """Delete an account's permissions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_account_permission(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_account_permission_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_account_permission_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def delete_account_permission_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Delete an account's permissions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_account_permission_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_account_permission" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `delete_account_permission`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account_permission/{account_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_account_stage(self, stage_id, **kwargs):  # noqa: E501
        """Delete an account stage  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_account_stage(stage_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str stage_id: UUID of an account stage (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_account_stage_with_http_info(stage_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_account_stage_with_http_info(stage_id, **kwargs)  # noqa: E501
            return data

    def delete_account_stage_with_http_info(self, stage_id, **kwargs):  # noqa: E501
        """Delete an account stage  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_account_stage_with_http_info(stage_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str stage_id: UUID of an account stage (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['stage_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_account_stage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'stage_id' is set
        if ('stage_id' not in params or
                params['stage_id'] is None):
            raise ValueError("Missing the required parameter `stage_id` when calling `delete_account_stage`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'stage_id' in params:
            path_params['stage_id'] = params['stage_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/stage/{stage_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_account_status(self, account_status_id, **kwargs):  # noqa: E501
        """Delete an account status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_account_status(account_status_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_status_id: UUID of an account status (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_account_status_with_http_info(account_status_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_account_status_with_http_info(account_status_id, **kwargs)  # noqa: E501
            return data

    def delete_account_status_with_http_info(self, account_status_id, **kwargs):  # noqa: E501
        """Delete an account status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_account_status_with_http_info(account_status_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_status_id: UUID of an account status (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_status_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_account_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_status_id' is set
        if ('account_status_id' not in params or
                params['account_status_id'] is None):
            raise ValueError("Missing the required parameter `account_status_id` when calling `delete_account_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_status_id' in params:
            path_params['account_status_id'] = params['account_status_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account_status/{account_status_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_account_type(self, account_type_id, **kwargs):  # noqa: E501
        """Delete an account type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_account_type(account_type_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_type_id: UUID of an account type (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_account_type_with_http_info(account_type_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_account_type_with_http_info(account_type_id, **kwargs)  # noqa: E501
            return data

    def delete_account_type_with_http_info(self, account_type_id, **kwargs):  # noqa: E501
        """Delete an account type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_account_type_with_http_info(account_type_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_type_id: UUID of an account type (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_type_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_account_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_type_id' is set
        if ('account_type_id' not in params or
                params['account_type_id'] is None):
            raise ValueError("Missing the required parameter `account_type_id` when calling `delete_account_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_type_id' in params:
            path_params['account_type_id'] = params['account_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account_type/{account_type_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_aggregation_account(self, aggregation_account_id, **kwargs):  # noqa: E501
        """Delete an aggregation account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_aggregation_account(aggregation_account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str aggregation_account_id: UUID of an aggregation account (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_aggregation_account_with_http_info(aggregation_account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_aggregation_account_with_http_info(aggregation_account_id, **kwargs)  # noqa: E501
            return data

    def delete_aggregation_account_with_http_info(self, aggregation_account_id, **kwargs):  # noqa: E501
        """Delete an aggregation account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_aggregation_account_with_http_info(aggregation_account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str aggregation_account_id: UUID of an aggregation account (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['aggregation_account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_aggregation_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'aggregation_account_id' is set
        if ('aggregation_account_id' not in params or
                params['aggregation_account_id'] is None):
            raise ValueError("Missing the required parameter `aggregation_account_id` when calling `delete_aggregation_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'aggregation_account_id' in params:
            path_params['aggregation_account_id'] = params['aggregation_account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/aggregation_account/{aggregation_account_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_aggregation_account_balance(self, aggregation_account_balance_id, **kwargs):  # noqa: E501
        """Delete an aggregation account balance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_aggregation_account_balance(aggregation_account_balance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str aggregation_account_balance_id: UUID of an aggregation account balance (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_aggregation_account_balance_with_http_info(aggregation_account_balance_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_aggregation_account_balance_with_http_info(aggregation_account_balance_id, **kwargs)  # noqa: E501
            return data

    def delete_aggregation_account_balance_with_http_info(self, aggregation_account_balance_id, **kwargs):  # noqa: E501
        """Delete an aggregation account balance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_aggregation_account_balance_with_http_info(aggregation_account_balance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str aggregation_account_balance_id: UUID of an aggregation account balance (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['aggregation_account_balance_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_aggregation_account_balance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'aggregation_account_balance_id' is set
        if ('aggregation_account_balance_id' not in params or
                params['aggregation_account_balance_id'] is None):
            raise ValueError("Missing the required parameter `aggregation_account_balance_id` when calling `delete_aggregation_account_balance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'aggregation_account_balance_id' in params:
            path_params['aggregation_account_balance_id'] = params['aggregation_account_balance_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/aggregation_account_balance/{aggregation_account_balance_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_aggregation_account_holding(self, aggregation_account_holding_id, **kwargs):  # noqa: E501
        """Delete an aggregation account holding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_aggregation_account_holding(aggregation_account_holding_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str aggregation_account_holding_id: UUID of an aggregation account holding (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_aggregation_account_holding_with_http_info(aggregation_account_holding_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_aggregation_account_holding_with_http_info(aggregation_account_holding_id, **kwargs)  # noqa: E501
            return data

    def delete_aggregation_account_holding_with_http_info(self, aggregation_account_holding_id, **kwargs):  # noqa: E501
        """Delete an aggregation account holding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_aggregation_account_holding_with_http_info(aggregation_account_holding_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str aggregation_account_holding_id: UUID of an aggregation account holding (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['aggregation_account_holding_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_aggregation_account_holding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'aggregation_account_holding_id' is set
        if ('aggregation_account_holding_id' not in params or
                params['aggregation_account_holding_id'] is None):
            raise ValueError("Missing the required parameter `aggregation_account_holding_id` when calling `delete_aggregation_account_holding`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'aggregation_account_holding_id' in params:
            path_params['aggregation_account_holding_id'] = params['aggregation_account_holding_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/aggregation_account_holding/{aggregation_account_holding_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_aggregation_account_transaction(self, aggregation_account_transaction_id, **kwargs):  # noqa: E501
        """Delete an aggregation account transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_aggregation_account_transaction(aggregation_account_transaction_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str aggregation_account_transaction_id: UUID of an aggregation account transaction (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_aggregation_account_transaction_with_http_info(aggregation_account_transaction_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_aggregation_account_transaction_with_http_info(aggregation_account_transaction_id, **kwargs)  # noqa: E501
            return data

    def delete_aggregation_account_transaction_with_http_info(self, aggregation_account_transaction_id, **kwargs):  # noqa: E501
        """Delete an aggregation account transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_aggregation_account_transaction_with_http_info(aggregation_account_transaction_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str aggregation_account_transaction_id: UUID of an aggregation account transaction (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['aggregation_account_transaction_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_aggregation_account_transaction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'aggregation_account_transaction_id' is set
        if ('aggregation_account_transaction_id' not in params or
                params['aggregation_account_transaction_id'] is None):
            raise ValueError("Missing the required parameter `aggregation_account_transaction_id` when calling `delete_aggregation_account_transaction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'aggregation_account_transaction_id' in params:
            path_params['aggregation_account_transaction_id'] = params['aggregation_account_transaction_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/aggregation_account_transaction/{aggregation_account_transaction_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_allocation(self, allocation_id, **kwargs):  # noqa: E501
        """Delete an allocation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_allocation(allocation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str allocation_id: UUID of an allocation (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_allocation_with_http_info(allocation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_allocation_with_http_info(allocation_id, **kwargs)  # noqa: E501
            return data

    def delete_allocation_with_http_info(self, allocation_id, **kwargs):  # noqa: E501
        """Delete an allocation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_allocation_with_http_info(allocation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str allocation_id: UUID of an allocation (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['allocation_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_allocation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'allocation_id' is set
        if ('allocation_id' not in params or
                params['allocation_id'] is None):
            raise ValueError("Missing the required parameter `allocation_id` when calling `delete_allocation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'allocation_id' in params:
            path_params['allocation_id'] = params['allocation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/allocation/{allocation_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_allocation_composition(self, allocation_composition_id, **kwargs):  # noqa: E501
        """Delete an allocation composition  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_allocation_composition(allocation_composition_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str allocation_composition_id: UUID of an allocation composition (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_allocation_composition_with_http_info(allocation_composition_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_allocation_composition_with_http_info(allocation_composition_id, **kwargs)  # noqa: E501
            return data

    def delete_allocation_composition_with_http_info(self, allocation_composition_id, **kwargs):  # noqa: E501
        """Delete an allocation composition  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_allocation_composition_with_http_info(allocation_composition_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str allocation_composition_id: UUID of an allocation composition (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['allocation_composition_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_allocation_composition" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'allocation_composition_id' is set
        if ('allocation_composition_id' not in params or
                params['allocation_composition_id'] is None):
            raise ValueError("Missing the required parameter `allocation_composition_id` when calling `delete_allocation_composition`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'allocation_composition_id' in params:
            path_params['allocation_composition_id'] = params['allocation_composition_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/allocation_composition/{allocation_composition_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_bank_link(self, bank_link_id, **kwargs):  # noqa: E501
        """Delete a bank link  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_bank_link(bank_link_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str bank_link_id: UUID of a bank link (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_bank_link_with_http_info(bank_link_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_bank_link_with_http_info(bank_link_id, **kwargs)  # noqa: E501
            return data

    def delete_bank_link_with_http_info(self, bank_link_id, **kwargs):  # noqa: E501
        """Delete a bank link  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_bank_link_with_http_info(bank_link_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str bank_link_id: UUID of a bank link (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bank_link_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_bank_link" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bank_link_id' is set
        if ('bank_link_id' not in params or
                params['bank_link_id'] is None):
            raise ValueError("Missing the required parameter `bank_link_id` when calling `delete_bank_link`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bank_link_id' in params:
            path_params['bank_link_id'] = params['bank_link_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/bank_link/{bank_link_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_benchmark(self, benchmark_id, **kwargs):  # noqa: E501
        """Delete a benchmark  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_benchmark(benchmark_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str benchmark_id: UUID of a benchmark (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_benchmark_with_http_info(benchmark_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_benchmark_with_http_info(benchmark_id, **kwargs)  # noqa: E501
            return data

    def delete_benchmark_with_http_info(self, benchmark_id, **kwargs):  # noqa: E501
        """Delete a benchmark  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_benchmark_with_http_info(benchmark_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str benchmark_id: UUID of a benchmark (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['benchmark_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_benchmark" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'benchmark_id' is set
        if ('benchmark_id' not in params or
                params['benchmark_id'] is None):
            raise ValueError("Missing the required parameter `benchmark_id` when calling `delete_benchmark`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'benchmark_id' in params:
            path_params['benchmark_id'] = params['benchmark_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/benchmark/{benchmark_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_budget(self, budget_id, **kwargs):  # noqa: E501
        """Delete a budget  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_budget(budget_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str budget_id: UUID of a budget (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_budget_with_http_info(budget_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_budget_with_http_info(budget_id, **kwargs)  # noqa: E501
            return data

    def delete_budget_with_http_info(self, budget_id, **kwargs):  # noqa: E501
        """Delete a budget  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_budget_with_http_info(budget_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str budget_id: UUID of a budget (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['budget_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_budget" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'budget_id' is set
        if ('budget_id' not in params or
                params['budget_id'] is None):
            raise ValueError("Missing the required parameter `budget_id` when calling `delete_budget`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'budget_id' in params:
            path_params['budget_id'] = params['budget_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/budget/{budget_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_client(self, client_id, **kwargs):  # noqa: E501
        """Delete a client  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_client(client_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: UUID of a client (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_client_with_http_info(client_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_client_with_http_info(client_id, **kwargs)  # noqa: E501
            return data

    def delete_client_with_http_info(self, client_id, **kwargs):  # noqa: E501
        """Delete a client  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_client_with_http_info(client_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: UUID of a client (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_client" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params or
                params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `delete_client`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'client_id' in params:
            path_params['client_id'] = params['client_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/client/{client_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_client_hydro(self, client_hydro_id, **kwargs):  # noqa: E501
        """Delete a client-hydro relationship  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_client_hydro(client_hydro_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_hydro_id: UUID of a client-hydro relationship (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_client_hydro_with_http_info(client_hydro_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_client_hydro_with_http_info(client_hydro_id, **kwargs)  # noqa: E501
            return data

    def delete_client_hydro_with_http_info(self, client_hydro_id, **kwargs):  # noqa: E501
        """Delete a client-hydro relationship  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_client_hydro_with_http_info(client_hydro_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_hydro_id: UUID of a client-hydro relationship (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_hydro_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_client_hydro" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_hydro_id' is set
        if ('client_hydro_id' not in params or
                params['client_hydro_id'] is None):
            raise ValueError("Missing the required parameter `client_hydro_id` when calling `delete_client_hydro`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'client_hydro_id' in params:
            path_params['client_hydro_id'] = params['client_hydro_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/client_hydro/{client_hydro_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_client_response(self, client_response_id, **kwargs):  # noqa: E501
        """Delete a client response  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_client_response(client_response_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_response_id: UUID of a client response (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_client_response_with_http_info(client_response_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_client_response_with_http_info(client_response_id, **kwargs)  # noqa: E501
            return data

    def delete_client_response_with_http_info(self, client_response_id, **kwargs):  # noqa: E501
        """Delete a client response  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_client_response_with_http_info(client_response_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_response_id: UUID of a client response (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_response_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_client_response" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_response_id' is set
        if ('client_response_id' not in params or
                params['client_response_id'] is None):
            raise ValueError("Missing the required parameter `client_response_id` when calling `delete_client_response`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'client_response_id' in params:
            path_params['client_response_id'] = params['client_response_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/client_response/{client_response_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_decision_tree(self, decision_tree_id, **kwargs):  # noqa: E501
        """Delete a decision tree  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_decision_tree(decision_tree_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str decision_tree_id: UUID of a decision tree (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_decision_tree_with_http_info(decision_tree_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_decision_tree_with_http_info(decision_tree_id, **kwargs)  # noqa: E501
            return data

    def delete_decision_tree_with_http_info(self, decision_tree_id, **kwargs):  # noqa: E501
        """Delete a decision tree  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_decision_tree_with_http_info(decision_tree_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str decision_tree_id: UUID of a decision tree (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['decision_tree_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_decision_tree" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'decision_tree_id' is set
        if ('decision_tree_id' not in params or
                params['decision_tree_id'] is None):
            raise ValueError("Missing the required parameter `decision_tree_id` when calling `delete_decision_tree`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'decision_tree_id' in params:
            path_params['decision_tree_id'] = params['decision_tree_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/decision_tree/{decision_tree_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_deposit_request(self, deposit_id, **kwargs):  # noqa: E501
        """Delete a deposit request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_deposit_request(deposit_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str deposit_id: UUID of a deposit record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_deposit_request_with_http_info(deposit_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_deposit_request_with_http_info(deposit_id, **kwargs)  # noqa: E501
            return data

    def delete_deposit_request_with_http_info(self, deposit_id, **kwargs):  # noqa: E501
        """Delete a deposit request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_deposit_request_with_http_info(deposit_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str deposit_id: UUID of a deposit record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deposit_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_deposit_request" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deposit_id' is set
        if ('deposit_id' not in params or
                params['deposit_id'] is None):
            raise ValueError("Missing the required parameter `deposit_id` when calling `delete_deposit_request`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deposit_id' in params:
            path_params['deposit_id'] = params['deposit_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/deposit/{deposit_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_financial_offer(self, financial_offer_id, **kwargs):  # noqa: E501
        """Delete a financial offer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_financial_offer(financial_offer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str financial_offer_id: UUID of a financial offer (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_financial_offer_with_http_info(financial_offer_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_financial_offer_with_http_info(financial_offer_id, **kwargs)  # noqa: E501
            return data

    def delete_financial_offer_with_http_info(self, financial_offer_id, **kwargs):  # noqa: E501
        """Delete a financial offer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_financial_offer_with_http_info(financial_offer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str financial_offer_id: UUID of a financial offer (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['financial_offer_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_financial_offer" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'financial_offer_id' is set
        if ('financial_offer_id' not in params or
                params['financial_offer_id'] is None):
            raise ValueError("Missing the required parameter `financial_offer_id` when calling `delete_financial_offer`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'financial_offer_id' in params:
            path_params['financial_offer_id'] = params['financial_offer_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/financial_offer/{financial_offer_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_funding_request(self, funding_id, **kwargs):  # noqa: E501
        """Delete a funding request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_funding_request(funding_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str funding_id: UUID of a funding record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_funding_request_with_http_info(funding_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_funding_request_with_http_info(funding_id, **kwargs)  # noqa: E501
            return data

    def delete_funding_request_with_http_info(self, funding_id, **kwargs):  # noqa: E501
        """Delete a funding request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_funding_request_with_http_info(funding_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str funding_id: UUID of a funding record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['funding_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_funding_request" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'funding_id' is set
        if ('funding_id' not in params or
                params['funding_id'] is None):
            raise ValueError("Missing the required parameter `funding_id` when calling `delete_funding_request`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'funding_id' in params:
            path_params['funding_id'] = params['funding_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/funding/{funding_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_goal(self, goal_id, **kwargs):  # noqa: E501
        """Delete a goal  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_goal(goal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str goal_id: UUID of a goal (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_goal_with_http_info(goal_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_goal_with_http_info(goal_id, **kwargs)  # noqa: E501
            return data

    def delete_goal_with_http_info(self, goal_id, **kwargs):  # noqa: E501
        """Delete a goal  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_goal_with_http_info(goal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str goal_id: UUID of a goal (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['goal_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_goal" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'goal_id' is set
        if ('goal_id' not in params or
                params['goal_id'] is None):
            raise ValueError("Missing the required parameter `goal_id` when calling `delete_goal`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'goal_id' in params:
            path_params['goal_id'] = params['goal_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/goal/{goal_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_goal_track_record(self, goal_track_id, **kwargs):  # noqa: E501
        """Delete a goal track record  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_goal_track_record(goal_track_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str goal_track_id: UUID of a goal tracking record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_goal_track_record_with_http_info(goal_track_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_goal_track_record_with_http_info(goal_track_id, **kwargs)  # noqa: E501
            return data

    def delete_goal_track_record_with_http_info(self, goal_track_id, **kwargs):  # noqa: E501
        """Delete a goal track record  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_goal_track_record_with_http_info(goal_track_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str goal_track_id: UUID of a goal tracking record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['goal_track_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_goal_track_record" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'goal_track_id' is set
        if ('goal_track_id' not in params or
                params['goal_track_id'] is None):
            raise ValueError("Missing the required parameter `goal_track_id` when calling `delete_goal_track_record`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'goal_track_id' in params:
            path_params['goal_track_id'] = params['goal_track_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/goal_track/{goal_track_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_model(self, model_id, **kwargs):  # noqa: E501
        """Delete a model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_model(model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_id: UUID of a model (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_model_with_http_info(model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_model_with_http_info(model_id, **kwargs)  # noqa: E501
            return data

    def delete_model_with_http_info(self, model_id, **kwargs):  # noqa: E501
        """Delete a model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_model_with_http_info(model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_id: UUID of a model (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_model" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_id' is set
        if ('model_id' not in params or
                params['model_id'] is None):
            raise ValueError("Missing the required parameter `model_id` when calling `delete_model`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_id' in params:
            path_params['model_id'] = params['model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/model/{model_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_model_asset_size(self, model_asset_size_id, **kwargs):  # noqa: E501
        """Delete a model asset size  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_model_asset_size(model_asset_size_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_asset_size_id: UUID of a model asset size record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_model_asset_size_with_http_info(model_asset_size_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_model_asset_size_with_http_info(model_asset_size_id, **kwargs)  # noqa: E501
            return data

    def delete_model_asset_size_with_http_info(self, model_asset_size_id, **kwargs):  # noqa: E501
        """Delete a model asset size  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_model_asset_size_with_http_info(model_asset_size_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_asset_size_id: UUID of a model asset size record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_asset_size_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_model_asset_size" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_asset_size_id' is set
        if ('model_asset_size_id' not in params or
                params['model_asset_size_id'] is None):
            raise ValueError("Missing the required parameter `model_asset_size_id` when calling `delete_model_asset_size`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_asset_size_id' in params:
            path_params['model_asset_size_id'] = params['model_asset_size_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/model_asset_size/{model_asset_size_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_model_comment(self, model_comment_id, **kwargs):  # noqa: E501
        """Delete a model commentary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_model_comment(model_comment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_comment_id: UUID of a model comment (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_model_comment_with_http_info(model_comment_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_model_comment_with_http_info(model_comment_id, **kwargs)  # noqa: E501
            return data

    def delete_model_comment_with_http_info(self, model_comment_id, **kwargs):  # noqa: E501
        """Delete a model commentary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_model_comment_with_http_info(model_comment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_comment_id: UUID of a model comment (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_comment_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_model_comment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_comment_id' is set
        if ('model_comment_id' not in params or
                params['model_comment_id'] is None):
            raise ValueError("Missing the required parameter `model_comment_id` when calling `delete_model_comment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_comment_id' in params:
            path_params['model_comment_id'] = params['model_comment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/model_comment/{model_comment_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_model_holding(self, model_holding_id, **kwargs):  # noqa: E501
        """Delete a model holding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_model_holding(model_holding_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_holding_id: UUID of a model holding record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_model_holding_with_http_info(model_holding_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_model_holding_with_http_info(model_holding_id, **kwargs)  # noqa: E501
            return data

    def delete_model_holding_with_http_info(self, model_holding_id, **kwargs):  # noqa: E501
        """Delete a model holding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_model_holding_with_http_info(model_holding_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_holding_id: UUID of a model holding record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_holding_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_model_holding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_holding_id' is set
        if ('model_holding_id' not in params or
                params['model_holding_id'] is None):
            raise ValueError("Missing the required parameter `model_holding_id` when calling `delete_model_holding`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_holding_id' in params:
            path_params['model_holding_id'] = params['model_holding_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/model_holding/{model_holding_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_model_transaction(self, model_transaction_id, **kwargs):  # noqa: E501
        """Delete a model transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_model_transaction(model_transaction_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_transaction_id: UUID of a model transaction record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_model_transaction_with_http_info(model_transaction_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_model_transaction_with_http_info(model_transaction_id, **kwargs)  # noqa: E501
            return data

    def delete_model_transaction_with_http_info(self, model_transaction_id, **kwargs):  # noqa: E501
        """Delete a model transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_model_transaction_with_http_info(model_transaction_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_transaction_id: UUID of a model transaction record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_transaction_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_model_transaction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_transaction_id' is set
        if ('model_transaction_id' not in params or
                params['model_transaction_id'] is None):
            raise ValueError("Missing the required parameter `model_transaction_id` when calling `delete_model_transaction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_transaction_id' in params:
            path_params['model_transaction_id'] = params['model_transaction_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/model_transaction/{model_transaction_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_node(self, node_id, **kwargs):  # noqa: E501
        """Delete a node  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_node(node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_id: UUID of a node (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_node_with_http_info(node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_node_with_http_info(node_id, **kwargs)  # noqa: E501
            return data

    def delete_node_with_http_info(self, node_id, **kwargs):  # noqa: E501
        """Delete a node  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_node_with_http_info(node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_id: UUID of a node (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_id' is set
        if ('node_id' not in params or
                params['node_id'] is None):
            raise ValueError("Missing the required parameter `node_id` when calling `delete_node`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_id' in params:
            path_params['node_id'] = params['node_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/node/{node_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_node_relationship(self, node_relationship_id, **kwargs):  # noqa: E501
        """Delete a node relationship  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_node_relationship(node_relationship_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_relationship_id: UUID of a node relationship (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_node_relationship_with_http_info(node_relationship_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_node_relationship_with_http_info(node_relationship_id, **kwargs)  # noqa: E501
            return data

    def delete_node_relationship_with_http_info(self, node_relationship_id, **kwargs):  # noqa: E501
        """Delete a node relationship  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_node_relationship_with_http_info(node_relationship_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_relationship_id: UUID of a node relationship (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_relationship_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_node_relationship" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_relationship_id' is set
        if ('node_relationship_id' not in params or
                params['node_relationship_id'] is None):
            raise ValueError("Missing the required parameter `node_relationship_id` when calling `delete_node_relationship`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_relationship_id' in params:
            path_params['node_relationship_id'] = params['node_relationship_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/node_relationship/{node_relationship_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_order_record(self, order_id, **kwargs):  # noqa: E501
        """Delete an order record  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_order_record(order_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order_id: UUID of an order record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_order_record_with_http_info(order_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_order_record_with_http_info(order_id, **kwargs)  # noqa: E501
            return data

    def delete_order_record_with_http_info(self, order_id, **kwargs):  # noqa: E501
        """Delete an order record  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_order_record_with_http_info(order_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order_id: UUID of an order record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['order_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_order_record" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'order_id' is set
        if ('order_id' not in params or
                params['order_id'] is None):
            raise ValueError("Missing the required parameter `order_id` when calling `delete_order_record`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'order_id' in params:
            path_params['order_id'] = params['order_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/order/{order_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_order_status(self, order_status_id, **kwargs):  # noqa: E501
        """Delete an order status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_order_status(order_status_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order_status_id: UUID of an order status record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_order_status_with_http_info(order_status_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_order_status_with_http_info(order_status_id, **kwargs)  # noqa: E501
            return data

    def delete_order_status_with_http_info(self, order_status_id, **kwargs):  # noqa: E501
        """Delete an order status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_order_status_with_http_info(order_status_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order_status_id: UUID of an order status record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['order_status_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_order_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'order_status_id' is set
        if ('order_status_id' not in params or
                params['order_status_id'] is None):
            raise ValueError("Missing the required parameter `order_status_id` when calling `delete_order_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'order_status_id' in params:
            path_params['order_status_id'] = params['order_status_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/order_status/{order_status_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_order_tracking_record(self, order_track_id, **kwargs):  # noqa: E501
        """Delete an order tracking record  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_order_tracking_record(order_track_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order_track_id: UUID of an order tracking record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_order_tracking_record_with_http_info(order_track_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_order_tracking_record_with_http_info(order_track_id, **kwargs)  # noqa: E501
            return data

    def delete_order_tracking_record_with_http_info(self, order_track_id, **kwargs):  # noqa: E501
        """Delete an order tracking record  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_order_tracking_record_with_http_info(order_track_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order_track_id: UUID of an order tracking record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['order_track_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_order_tracking_record" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'order_track_id' is set
        if ('order_track_id' not in params or
                params['order_track_id'] is None):
            raise ValueError("Missing the required parameter `order_track_id` when calling `delete_order_tracking_record`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'order_track_id' in params:
            path_params['order_track_id'] = params['order_track_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/order_track/{order_track_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_portfolio(self, portfolio_id, **kwargs):  # noqa: E501
        """Delete a portfolio  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_portfolio(portfolio_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_id: UUID of a portfolio (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_portfolio_with_http_info(portfolio_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_portfolio_with_http_info(portfolio_id, **kwargs)  # noqa: E501
            return data

    def delete_portfolio_with_http_info(self, portfolio_id, **kwargs):  # noqa: E501
        """Delete a portfolio  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_portfolio_with_http_info(portfolio_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_id: UUID of a portfolio (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portfolio_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_portfolio" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portfolio_id' is set
        if ('portfolio_id' not in params or
                params['portfolio_id'] is None):
            raise ValueError("Missing the required parameter `portfolio_id` when calling `delete_portfolio`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portfolio_id' in params:
            path_params['portfolio_id'] = params['portfolio_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/portfolio/{portfolio_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_portfolio_asset_size(self, portfolio_asset_size_id, **kwargs):  # noqa: E501
        """Delete a portfolio asset size  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_portfolio_asset_size(portfolio_asset_size_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_asset_size_id: UUID of a portfolio asset size record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_portfolio_asset_size_with_http_info(portfolio_asset_size_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_portfolio_asset_size_with_http_info(portfolio_asset_size_id, **kwargs)  # noqa: E501
            return data

    def delete_portfolio_asset_size_with_http_info(self, portfolio_asset_size_id, **kwargs):  # noqa: E501
        """Delete a portfolio asset size  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_portfolio_asset_size_with_http_info(portfolio_asset_size_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_asset_size_id: UUID of a portfolio asset size record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portfolio_asset_size_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_portfolio_asset_size" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portfolio_asset_size_id' is set
        if ('portfolio_asset_size_id' not in params or
                params['portfolio_asset_size_id'] is None):
            raise ValueError("Missing the required parameter `portfolio_asset_size_id` when calling `delete_portfolio_asset_size`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portfolio_asset_size_id' in params:
            path_params['portfolio_asset_size_id'] = params['portfolio_asset_size_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/portfolio_asset_size/{portfolio_asset_size_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_portfolio_comment(self, portfolio_comment_id, **kwargs):  # noqa: E501
        """Delete a portfolio commentary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_portfolio_comment(portfolio_comment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_comment_id: UUID of a portfolio comment (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_portfolio_comment_with_http_info(portfolio_comment_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_portfolio_comment_with_http_info(portfolio_comment_id, **kwargs)  # noqa: E501
            return data

    def delete_portfolio_comment_with_http_info(self, portfolio_comment_id, **kwargs):  # noqa: E501
        """Delete a portfolio commentary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_portfolio_comment_with_http_info(portfolio_comment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_comment_id: UUID of a portfolio comment (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portfolio_comment_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_portfolio_comment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portfolio_comment_id' is set
        if ('portfolio_comment_id' not in params or
                params['portfolio_comment_id'] is None):
            raise ValueError("Missing the required parameter `portfolio_comment_id` when calling `delete_portfolio_comment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portfolio_comment_id' in params:
            path_params['portfolio_comment_id'] = params['portfolio_comment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/portfolio_comment/{portfolio_comment_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_portfolio_holding(self, portfolio_holding_id, **kwargs):  # noqa: E501
        """Delete a portfolio holding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_portfolio_holding(portfolio_holding_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_holding_id: UUID of a portfolio holding record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_portfolio_holding_with_http_info(portfolio_holding_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_portfolio_holding_with_http_info(portfolio_holding_id, **kwargs)  # noqa: E501
            return data

    def delete_portfolio_holding_with_http_info(self, portfolio_holding_id, **kwargs):  # noqa: E501
        """Delete a portfolio holding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_portfolio_holding_with_http_info(portfolio_holding_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_holding_id: UUID of a portfolio holding record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portfolio_holding_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_portfolio_holding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portfolio_holding_id' is set
        if ('portfolio_holding_id' not in params or
                params['portfolio_holding_id'] is None):
            raise ValueError("Missing the required parameter `portfolio_holding_id` when calling `delete_portfolio_holding`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portfolio_holding_id' in params:
            path_params['portfolio_holding_id'] = params['portfolio_holding_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/portfolio_holding/{portfolio_holding_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_portfolio_transaction(self, portfolio_transaction_id, **kwargs):  # noqa: E501
        """Delete a portfolio transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_portfolio_transaction(portfolio_transaction_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_transaction_id: UUID of a portfolio transaction record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_portfolio_transaction_with_http_info(portfolio_transaction_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_portfolio_transaction_with_http_info(portfolio_transaction_id, **kwargs)  # noqa: E501
            return data

    def delete_portfolio_transaction_with_http_info(self, portfolio_transaction_id, **kwargs):  # noqa: E501
        """Delete a portfolio transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_portfolio_transaction_with_http_info(portfolio_transaction_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_transaction_id: UUID of a portfolio transaction record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portfolio_transaction_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_portfolio_transaction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portfolio_transaction_id' is set
        if ('portfolio_transaction_id' not in params or
                params['portfolio_transaction_id'] is None):
            raise ValueError("Missing the required parameter `portfolio_transaction_id` when calling `delete_portfolio_transaction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portfolio_transaction_id' in params:
            path_params['portfolio_transaction_id'] = params['portfolio_transaction_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/portfolio_transaction/{portfolio_transaction_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_questionnaire(self, questionnaire_id, **kwargs):  # noqa: E501
        """Delete a questionnaire  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_questionnaire(questionnaire_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str questionnaire_id: UUID of a questionnaire (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_questionnaire_with_http_info(questionnaire_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_questionnaire_with_http_info(questionnaire_id, **kwargs)  # noqa: E501
            return data

    def delete_questionnaire_with_http_info(self, questionnaire_id, **kwargs):  # noqa: E501
        """Delete a questionnaire  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_questionnaire_with_http_info(questionnaire_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str questionnaire_id: UUID of a questionnaire (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['questionnaire_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_questionnaire" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'questionnaire_id' is set
        if ('questionnaire_id' not in params or
                params['questionnaire_id'] is None):
            raise ValueError("Missing the required parameter `questionnaire_id` when calling `delete_questionnaire`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'questionnaire_id' in params:
            path_params['questionnaire_id'] = params['questionnaire_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/questionnaire/{questionnaire_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_score(self, score_id, **kwargs):  # noqa: E501
        """Delete a score  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_score(score_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str score_id: UUID of a score record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_score_with_http_info(score_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_score_with_http_info(score_id, **kwargs)  # noqa: E501
            return data

    def delete_score_with_http_info(self, score_id, **kwargs):  # noqa: E501
        """Delete a score  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_score_with_http_info(score_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str score_id: UUID of a score record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['score_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_score" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'score_id' is set
        if ('score_id' not in params or
                params['score_id'] is None):
            raise ValueError("Missing the required parameter `score_id` when calling `delete_score`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'score_id' in params:
            path_params['score_id'] = params['score_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/score/{score_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_security(self, security_id, **kwargs):  # noqa: E501
        """Delete a security  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_security(security_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str security_id: UUID of a security (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_security_with_http_info(security_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_security_with_http_info(security_id, **kwargs)  # noqa: E501
            return data

    def delete_security_with_http_info(self, security_id, **kwargs):  # noqa: E501
        """Delete a security  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_security_with_http_info(security_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str security_id: UUID of a security (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['security_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_security" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'security_id' is set
        if ('security_id' not in params or
                params['security_id'] is None):
            raise ValueError("Missing the required parameter `security_id` when calling `delete_security`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'security_id' in params:
            path_params['security_id'] = params['security_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/security/{security_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_security_exclusion(self, security_exclusion_id, **kwargs):  # noqa: E501
        """Delete a security exclusion  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_security_exclusion(security_exclusion_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str security_exclusion_id: UUID of a security exclusion record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_security_exclusion_with_http_info(security_exclusion_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_security_exclusion_with_http_info(security_exclusion_id, **kwargs)  # noqa: E501
            return data

    def delete_security_exclusion_with_http_info(self, security_exclusion_id, **kwargs):  # noqa: E501
        """Delete a security exclusion  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_security_exclusion_with_http_info(security_exclusion_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str security_exclusion_id: UUID of a security exclusion record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['security_exclusion_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_security_exclusion" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'security_exclusion_id' is set
        if ('security_exclusion_id' not in params or
                params['security_exclusion_id'] is None):
            raise ValueError("Missing the required parameter `security_exclusion_id` when calling `delete_security_exclusion`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'security_exclusion_id' in params:
            path_params['security_exclusion_id'] = params['security_exclusion_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/security_exclusion/{security_exclusion_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_security_price(self, security_price_id, **kwargs):  # noqa: E501
        """Delete a security price  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_security_price(security_price_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str security_price_id: UUID of a security price record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_security_price_with_http_info(security_price_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_security_price_with_http_info(security_price_id, **kwargs)  # noqa: E501
            return data

    def delete_security_price_with_http_info(self, security_price_id, **kwargs):  # noqa: E501
        """Delete a security price  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_security_price_with_http_info(security_price_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str security_price_id: UUID of a security price record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['security_price_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_security_price" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'security_price_id' is set
        if ('security_price_id' not in params or
                params['security_price_id'] is None):
            raise ValueError("Missing the required parameter `security_price_id` when calling `delete_security_price`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'security_price_id' in params:
            path_params['security_price_id'] = params['security_price_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/security_price/{security_price_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_transaction_code(self, transaction_code_id, **kwargs):  # noqa: E501
        """Delete a transaction code  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_transaction_code(transaction_code_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transaction_code_id: UUID of a transaction code (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_transaction_code_with_http_info(transaction_code_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_transaction_code_with_http_info(transaction_code_id, **kwargs)  # noqa: E501
            return data

    def delete_transaction_code_with_http_info(self, transaction_code_id, **kwargs):  # noqa: E501
        """Delete a transaction code  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_transaction_code_with_http_info(transaction_code_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transaction_code_id: UUID of a transaction code (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transaction_code_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_transaction_code" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transaction_code_id' is set
        if ('transaction_code_id' not in params or
                params['transaction_code_id'] is None):
            raise ValueError("Missing the required parameter `transaction_code_id` when calling `delete_transaction_code`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transaction_code_id' in params:
            path_params['transaction_code_id'] = params['transaction_code_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/transaction_code/{transaction_code_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_transfer_request(self, transfer_id, **kwargs):  # noqa: E501
        """Delete a transfer request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_transfer_request(transfer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transfer_id: UUID of an account transfer record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_transfer_request_with_http_info(transfer_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_transfer_request_with_http_info(transfer_id, **kwargs)  # noqa: E501
            return data

    def delete_transfer_request_with_http_info(self, transfer_id, **kwargs):  # noqa: E501
        """Delete a transfer request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_transfer_request_with_http_info(transfer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transfer_id: UUID of an account transfer record (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transfer_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_transfer_request" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transfer_id' is set
        if ('transfer_id' not in params or
                params['transfer_id'] is None):
            raise ValueError("Missing the required parameter `transfer_id` when calling `delete_transfer_request`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transfer_id' in params:
            path_params['transfer_id'] = params['transfer_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/transfer/{transfer_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_withdrawal_request(self, withdrawal_id, **kwargs):  # noqa: E501
        """Delete a withdrawal request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_withdrawal_request(withdrawal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str withdrawal_id: UUID of a withdrawal request (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_withdrawal_request_with_http_info(withdrawal_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_withdrawal_request_with_http_info(withdrawal_id, **kwargs)  # noqa: E501
            return data

    def delete_withdrawal_request_with_http_info(self, withdrawal_id, **kwargs):  # noqa: E501
        """Delete a withdrawal request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_withdrawal_request_with_http_info(withdrawal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str withdrawal_id: UUID of a withdrawal request (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['withdrawal_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_withdrawal_request" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'withdrawal_id' is set
        if ('withdrawal_id' not in params or
                params['withdrawal_id'] is None):
            raise ValueError("Missing the required parameter `withdrawal_id` when calling `delete_withdrawal_request`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'withdrawal_id' in params:
            path_params['withdrawal_id'] = params['withdrawal_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/withdrawal/{withdrawal_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account(self, account_id, **kwargs):  # noqa: E501
        """Retrieve an account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :return: SpecificAccountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_account_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_account_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def get_account_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Retrieve an account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :return: SpecificAccountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `get_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account/{account_id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificAccountResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account_allocation(self, account_allocation_id, **kwargs):  # noqa: E501
        """Retrieve an account allocation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_allocation(account_allocation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_allocation_id: UUID of an account allocation (required)
        :return: SpecificAccountAllocationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_account_allocation_with_http_info(account_allocation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_account_allocation_with_http_info(account_allocation_id, **kwargs)  # noqa: E501
            return data

    def get_account_allocation_with_http_info(self, account_allocation_id, **kwargs):  # noqa: E501
        """Retrieve an account allocation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_allocation_with_http_info(account_allocation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_allocation_id: UUID of an account allocation (required)
        :return: SpecificAccountAllocationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_allocation_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_allocation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_allocation_id' is set
        if ('account_allocation_id' not in params or
                params['account_allocation_id'] is None):
            raise ValueError("Missing the required parameter `account_allocation_id` when calling `get_account_allocation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_allocation_id' in params:
            path_params['account_allocation_id'] = params['account_allocation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account_allocation/{account_allocation_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificAccountAllocationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account_allocations(self, **kwargs):  # noqa: E501
        """List all account allocations  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_allocations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetAccountAllocationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_account_allocations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_account_allocations_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_account_allocations_with_http_info(self, **kwargs):  # noqa: E501
        """List all account allocations  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_allocations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetAccountAllocationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_allocations" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_account_allocations`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_account_allocations`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account_allocation', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAccountAllocationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account_asset_sizes(self, account_id, **kwargs):  # noqa: E501
        """List all account asset sizes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_asset_sizes(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetAccountAssetSizeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_account_asset_sizes_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_account_asset_sizes_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def get_account_asset_sizes_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """List all account asset sizes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_asset_sizes_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetAccountAssetSizeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_asset_sizes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `get_account_asset_sizes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account/{account_id}/asset_size', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAccountAssetSizeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account_holdings(self, account_id, **kwargs):  # noqa: E501
        """List all account holdings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_holdings(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetAccountHoldingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_account_holdings_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_account_holdings_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def get_account_holdings_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """List all account holdings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_holdings_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetAccountHoldingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_holdings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `get_account_holdings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account/{account_id}/holding', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAccountHoldingResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account_performance(self, account_id, stat, **kwargs):  # noqa: E501
        """Get account performance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_performance(account_id, stat, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :param str stat: Performance statistic (required)
        :return: PerformanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_account_performance_with_http_info(account_id, stat, **kwargs)  # noqa: E501
        else:
            (data) = self.get_account_performance_with_http_info(account_id, stat, **kwargs)  # noqa: E501
            return data

    def get_account_performance_with_http_info(self, account_id, stat, **kwargs):  # noqa: E501
        """Get account performance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_performance_with_http_info(account_id, stat, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :param str stat: Performance statistic (required)
        :return: PerformanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'stat']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_performance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `get_account_performance`")  # noqa: E501
        # verify the required parameter 'stat' is set
        if ('stat' not in params or
                params['stat'] is None):
            raise ValueError("Missing the required parameter `stat` when calling `get_account_performance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []
        if 'stat' in params:
            query_params.append(('stat', params['stat']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account/{account_id}/performance', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PerformanceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account_permission(self, account_id, **kwargs):  # noqa: E501
        """Retrieve an account's permission  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_permission(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :return: SpecificAccountPermissionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_account_permission_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_account_permission_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def get_account_permission_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Retrieve an account's permission  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_permission_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :return: SpecificAccountPermissionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_permission" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `get_account_permission`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account_permission/{account_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificAccountPermissionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account_permissions(self, **kwargs):  # noqa: E501
        """List all account permissions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_permissions(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetAccountPermissionsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_account_permissions_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_account_permissions_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_account_permissions_with_http_info(self, **kwargs):  # noqa: E501
        """List all account permissions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_permissions_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetAccountPermissionsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_permissions" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_account_permissions`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_account_permissions`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account_permission', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAccountPermissionsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account_stage(self, stage_id, **kwargs):  # noqa: E501
        """Retrieve an account stage  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_stage(stage_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str stage_id: UUID of an account stage (required)
        :return: SpecificAccountStageResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_account_stage_with_http_info(stage_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_account_stage_with_http_info(stage_id, **kwargs)  # noqa: E501
            return data

    def get_account_stage_with_http_info(self, stage_id, **kwargs):  # noqa: E501
        """Retrieve an account stage  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_stage_with_http_info(stage_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str stage_id: UUID of an account stage (required)
        :return: SpecificAccountStageResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['stage_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_stage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'stage_id' is set
        if ('stage_id' not in params or
                params['stage_id'] is None):
            raise ValueError("Missing the required parameter `stage_id` when calling `get_account_stage`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'stage_id' in params:
            path_params['stage_id'] = params['stage_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/stage/{stage_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificAccountStageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account_stages(self, **kwargs):  # noqa: E501
        """List all account stages  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_stages(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetAccountStageResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_account_stages_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_account_stages_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_account_stages_with_http_info(self, **kwargs):  # noqa: E501
        """List all account stages  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_stages_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetAccountStageResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_stages" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_account_stages`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_account_stages`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/stage', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAccountStageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account_status(self, account_status_id, **kwargs):  # noqa: E501
        """Retrieve an account status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_status(account_status_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_status_id: UUID of an account status (required)
        :return: SpecificAccountStatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_account_status_with_http_info(account_status_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_account_status_with_http_info(account_status_id, **kwargs)  # noqa: E501
            return data

    def get_account_status_with_http_info(self, account_status_id, **kwargs):  # noqa: E501
        """Retrieve an account status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_status_with_http_info(account_status_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_status_id: UUID of an account status (required)
        :return: SpecificAccountStatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_status_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_status_id' is set
        if ('account_status_id' not in params or
                params['account_status_id'] is None):
            raise ValueError("Missing the required parameter `account_status_id` when calling `get_account_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_status_id' in params:
            path_params['account_status_id'] = params['account_status_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account_status/{account_status_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificAccountStatusResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account_statuses(self, **kwargs):  # noqa: E501
        """List all account statuses  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_statuses(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetAccountStatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_account_statuses_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_account_statuses_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_account_statuses_with_http_info(self, **kwargs):  # noqa: E501
        """List all account statuses  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_statuses_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetAccountStatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_statuses" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_account_statuses`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_account_statuses`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account_status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAccountStatusResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account_transactions(self, account_id, **kwargs):  # noqa: E501
        """List all account transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_transactions(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: AccountTransactionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_account_transactions_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_account_transactions_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def get_account_transactions_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """List all account transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_transactions_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: AccountTransactionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_transactions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `get_account_transactions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account/{account_id}/transaction', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccountTransactionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account_type(self, account_type_id, **kwargs):  # noqa: E501
        """Retrieve an account type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_type(account_type_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_type_id: UUID of an account type (required)
        :return: GetAccountTypeSubresponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_account_type_with_http_info(account_type_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_account_type_with_http_info(account_type_id, **kwargs)  # noqa: E501
            return data

    def get_account_type_with_http_info(self, account_type_id, **kwargs):  # noqa: E501
        """Retrieve an account type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_type_with_http_info(account_type_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_type_id: UUID of an account type (required)
        :return: GetAccountTypeSubresponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_type_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_type_id' is set
        if ('account_type_id' not in params or
                params['account_type_id'] is None):
            raise ValueError("Missing the required parameter `account_type_id` when calling `get_account_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_type_id' in params:
            path_params['account_type_id'] = params['account_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account_type/{account_type_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAccountTypeSubresponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account_types(self, **kwargs):  # noqa: E501
        """List all account types  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_types(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetAccountTypeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_account_types_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_account_types_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_account_types_with_http_info(self, **kwargs):  # noqa: E501
        """List all account types  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_types_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetAccountTypeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_types" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_account_types`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_account_types`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account_type', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAccountTypeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_accounts(self, **kwargs):  # noqa: E501
        """Get information for all accounts for all clients defined for your firm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_accounts(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetAccountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_accounts_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_accounts_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_accounts_with_http_info(self, **kwargs):  # noqa: E501
        """Get information for all accounts for all clients defined for your firm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_accounts_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetAccountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_accounts" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_accounts`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_accounts`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAccountResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_aggregation_account(self, aggregation_account_id, **kwargs):  # noqa: E501
        """Retrieve an aggregation account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_aggregation_account(aggregation_account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str aggregation_account_id: UUID of an aggregation account (required)
        :return: SpecificAggregationAccountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_aggregation_account_with_http_info(aggregation_account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_aggregation_account_with_http_info(aggregation_account_id, **kwargs)  # noqa: E501
            return data

    def get_aggregation_account_with_http_info(self, aggregation_account_id, **kwargs):  # noqa: E501
        """Retrieve an aggregation account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_aggregation_account_with_http_info(aggregation_account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str aggregation_account_id: UUID of an aggregation account (required)
        :return: SpecificAggregationAccountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['aggregation_account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_aggregation_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'aggregation_account_id' is set
        if ('aggregation_account_id' not in params or
                params['aggregation_account_id'] is None):
            raise ValueError("Missing the required parameter `aggregation_account_id` when calling `get_aggregation_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'aggregation_account_id' in params:
            path_params['aggregation_account_id'] = params['aggregation_account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/aggregation_account/{aggregation_account_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificAggregationAccountResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_aggregation_account_balance(self, aggregation_account_balance_id, **kwargs):  # noqa: E501
        """Retrieve an aggregation account balance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_aggregation_account_balance(aggregation_account_balance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str aggregation_account_balance_id: UUID of an aggregation account balance (required)
        :return: SpecificAggregationAccountBalanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_aggregation_account_balance_with_http_info(aggregation_account_balance_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_aggregation_account_balance_with_http_info(aggregation_account_balance_id, **kwargs)  # noqa: E501
            return data

    def get_aggregation_account_balance_with_http_info(self, aggregation_account_balance_id, **kwargs):  # noqa: E501
        """Retrieve an aggregation account balance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_aggregation_account_balance_with_http_info(aggregation_account_balance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str aggregation_account_balance_id: UUID of an aggregation account balance (required)
        :return: SpecificAggregationAccountBalanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['aggregation_account_balance_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_aggregation_account_balance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'aggregation_account_balance_id' is set
        if ('aggregation_account_balance_id' not in params or
                params['aggregation_account_balance_id'] is None):
            raise ValueError("Missing the required parameter `aggregation_account_balance_id` when calling `get_aggregation_account_balance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'aggregation_account_balance_id' in params:
            path_params['aggregation_account_balance_id'] = params['aggregation_account_balance_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/aggregation_account_balance/{aggregation_account_balance_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificAggregationAccountBalanceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_aggregation_account_balances(self, **kwargs):  # noqa: E501
        """List all aggregation account balances  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_aggregation_account_balances(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetAggregationAccountBalanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_aggregation_account_balances_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_aggregation_account_balances_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_aggregation_account_balances_with_http_info(self, **kwargs):  # noqa: E501
        """List all aggregation account balances  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_aggregation_account_balances_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetAggregationAccountBalanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_aggregation_account_balances" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_aggregation_account_balances`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_aggregation_account_balances`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/aggregation_account_balance', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAggregationAccountBalanceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_aggregation_account_holding(self, aggregation_account_holding_id, **kwargs):  # noqa: E501
        """Retrieve an aggregation account holding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_aggregation_account_holding(aggregation_account_holding_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str aggregation_account_holding_id: UUID of an aggregation account holding (required)
        :return: SpecificAggregationAccountHoldingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_aggregation_account_holding_with_http_info(aggregation_account_holding_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_aggregation_account_holding_with_http_info(aggregation_account_holding_id, **kwargs)  # noqa: E501
            return data

    def get_aggregation_account_holding_with_http_info(self, aggregation_account_holding_id, **kwargs):  # noqa: E501
        """Retrieve an aggregation account holding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_aggregation_account_holding_with_http_info(aggregation_account_holding_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str aggregation_account_holding_id: UUID of an aggregation account holding (required)
        :return: SpecificAggregationAccountHoldingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['aggregation_account_holding_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_aggregation_account_holding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'aggregation_account_holding_id' is set
        if ('aggregation_account_holding_id' not in params or
                params['aggregation_account_holding_id'] is None):
            raise ValueError("Missing the required parameter `aggregation_account_holding_id` when calling `get_aggregation_account_holding`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'aggregation_account_holding_id' in params:
            path_params['aggregation_account_holding_id'] = params['aggregation_account_holding_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/aggregation_account_holding/{aggregation_account_holding_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificAggregationAccountHoldingResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_aggregation_account_holdings(self, **kwargs):  # noqa: E501
        """List all aggregation account holdings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_aggregation_account_holdings(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetAggregationAccountHoldingsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_aggregation_account_holdings_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_aggregation_account_holdings_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_aggregation_account_holdings_with_http_info(self, **kwargs):  # noqa: E501
        """List all aggregation account holdings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_aggregation_account_holdings_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetAggregationAccountHoldingsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_aggregation_account_holdings" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_aggregation_account_holdings`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_aggregation_account_holdings`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/aggregation_account_holding', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAggregationAccountHoldingsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_aggregation_account_transaction(self, aggregation_account_transaction_id, **kwargs):  # noqa: E501
        """Retrieve an aggregation account transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_aggregation_account_transaction(aggregation_account_transaction_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str aggregation_account_transaction_id: UUID of an aggregation account transaction (required)
        :return: SpecificAggregationAccountTransactionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_aggregation_account_transaction_with_http_info(aggregation_account_transaction_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_aggregation_account_transaction_with_http_info(aggregation_account_transaction_id, **kwargs)  # noqa: E501
            return data

    def get_aggregation_account_transaction_with_http_info(self, aggregation_account_transaction_id, **kwargs):  # noqa: E501
        """Retrieve an aggregation account transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_aggregation_account_transaction_with_http_info(aggregation_account_transaction_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str aggregation_account_transaction_id: UUID of an aggregation account transaction (required)
        :return: SpecificAggregationAccountTransactionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['aggregation_account_transaction_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_aggregation_account_transaction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'aggregation_account_transaction_id' is set
        if ('aggregation_account_transaction_id' not in params or
                params['aggregation_account_transaction_id'] is None):
            raise ValueError("Missing the required parameter `aggregation_account_transaction_id` when calling `get_aggregation_account_transaction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'aggregation_account_transaction_id' in params:
            path_params['aggregation_account_transaction_id'] = params['aggregation_account_transaction_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/aggregation_account_transaction/{aggregation_account_transaction_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificAggregationAccountTransactionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_aggregation_account_transactions(self, **kwargs):  # noqa: E501
        """List all aggregation account transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_aggregation_account_transactions(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetAggregationAccountTransactionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_aggregation_account_transactions_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_aggregation_account_transactions_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_aggregation_account_transactions_with_http_info(self, **kwargs):  # noqa: E501
        """List all aggregation account transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_aggregation_account_transactions_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetAggregationAccountTransactionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_aggregation_account_transactions" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_aggregation_account_transactions`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_aggregation_account_transactions`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/aggregation_account_transaction', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAggregationAccountTransactionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_aggregation_accounts(self, **kwargs):  # noqa: E501
        """List all aggregation accounts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_aggregation_accounts(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetAggregationAccountsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_aggregation_accounts_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_aggregation_accounts_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_aggregation_accounts_with_http_info(self, **kwargs):  # noqa: E501
        """List all aggregation accounts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_aggregation_accounts_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetAggregationAccountsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_aggregation_accounts" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_aggregation_accounts`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_aggregation_accounts`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/aggregation_account', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAggregationAccountsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_allocation(self, allocation_id, **kwargs):  # noqa: E501
        """Retrieve an allocation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_allocation(allocation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str allocation_id: UUID of an allocation (required)
        :return: SpecificAllocationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_allocation_with_http_info(allocation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_allocation_with_http_info(allocation_id, **kwargs)  # noqa: E501
            return data

    def get_allocation_with_http_info(self, allocation_id, **kwargs):  # noqa: E501
        """Retrieve an allocation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_allocation_with_http_info(allocation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str allocation_id: UUID of an allocation (required)
        :return: SpecificAllocationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['allocation_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_allocation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'allocation_id' is set
        if ('allocation_id' not in params or
                params['allocation_id'] is None):
            raise ValueError("Missing the required parameter `allocation_id` when calling `get_allocation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'allocation_id' in params:
            path_params['allocation_id'] = params['allocation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/allocation/{allocation_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificAllocationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_allocation_asset_sizes(self, allocation_id, **kwargs):  # noqa: E501
        """List all allocation asset sizes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_allocation_asset_sizes(allocation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str allocation_id: UUID of an allocation (required)
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: AllocationAssetSizeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_allocation_asset_sizes_with_http_info(allocation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_allocation_asset_sizes_with_http_info(allocation_id, **kwargs)  # noqa: E501
            return data

    def get_allocation_asset_sizes_with_http_info(self, allocation_id, **kwargs):  # noqa: E501
        """List all allocation asset sizes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_allocation_asset_sizes_with_http_info(allocation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str allocation_id: UUID of an allocation (required)
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: AllocationAssetSizeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['allocation_id', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_allocation_asset_sizes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'allocation_id' is set
        if ('allocation_id' not in params or
                params['allocation_id'] is None):
            raise ValueError("Missing the required parameter `allocation_id` when calling `get_allocation_asset_sizes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'allocation_id' in params:
            path_params['allocation_id'] = params['allocation_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/allocation/{allocation_id}/asset_size', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AllocationAssetSizeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_allocation_composition(self, allocation_composition_id, **kwargs):  # noqa: E501
        """Retrieve an allocation composition  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_allocation_composition(allocation_composition_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str allocation_composition_id: UUID of an allocation composition (required)
        :return: SpecificAllocationCompositionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_allocation_composition_with_http_info(allocation_composition_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_allocation_composition_with_http_info(allocation_composition_id, **kwargs)  # noqa: E501
            return data

    def get_allocation_composition_with_http_info(self, allocation_composition_id, **kwargs):  # noqa: E501
        """Retrieve an allocation composition  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_allocation_composition_with_http_info(allocation_composition_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str allocation_composition_id: UUID of an allocation composition (required)
        :return: SpecificAllocationCompositionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['allocation_composition_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_allocation_composition" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'allocation_composition_id' is set
        if ('allocation_composition_id' not in params or
                params['allocation_composition_id'] is None):
            raise ValueError("Missing the required parameter `allocation_composition_id` when calling `get_allocation_composition`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'allocation_composition_id' in params:
            path_params['allocation_composition_id'] = params['allocation_composition_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/allocation_composition/{allocation_composition_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificAllocationCompositionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_allocation_compositions(self, **kwargs):  # noqa: E501
        """List all allocation compositions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_allocation_compositions(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetAllocationCompositionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_allocation_compositions_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_allocation_compositions_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_allocation_compositions_with_http_info(self, **kwargs):  # noqa: E501
        """List all allocation compositions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_allocation_compositions_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetAllocationCompositionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_allocation_compositions" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_allocation_compositions`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_allocation_compositions`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/allocation_composition', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAllocationCompositionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_allocation_holdings(self, allocation_id, **kwargs):  # noqa: E501
        """List all allocation holdings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_allocation_holdings(allocation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str allocation_id: UUID of an allocation (required)
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: AllocationHoldingsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_allocation_holdings_with_http_info(allocation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_allocation_holdings_with_http_info(allocation_id, **kwargs)  # noqa: E501
            return data

    def get_allocation_holdings_with_http_info(self, allocation_id, **kwargs):  # noqa: E501
        """List all allocation holdings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_allocation_holdings_with_http_info(allocation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str allocation_id: UUID of an allocation (required)
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: AllocationHoldingsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['allocation_id', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_allocation_holdings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'allocation_id' is set
        if ('allocation_id' not in params or
                params['allocation_id'] is None):
            raise ValueError("Missing the required parameter `allocation_id` when calling `get_allocation_holdings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'allocation_id' in params:
            path_params['allocation_id'] = params['allocation_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/allocation/{allocation_id}/holding', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AllocationHoldingsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_allocation_performance(self, allocation_id, stat, **kwargs):  # noqa: E501
        """Get allocation performance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_allocation_performance(allocation_id, stat, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str allocation_id: UUID of an allocation (required)
        :param str stat: Performance statistic (required)
        :return: PerformanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_allocation_performance_with_http_info(allocation_id, stat, **kwargs)  # noqa: E501
        else:
            (data) = self.get_allocation_performance_with_http_info(allocation_id, stat, **kwargs)  # noqa: E501
            return data

    def get_allocation_performance_with_http_info(self, allocation_id, stat, **kwargs):  # noqa: E501
        """Get allocation performance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_allocation_performance_with_http_info(allocation_id, stat, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str allocation_id: UUID of an allocation (required)
        :param str stat: Performance statistic (required)
        :return: PerformanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['allocation_id', 'stat']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_allocation_performance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'allocation_id' is set
        if ('allocation_id' not in params or
                params['allocation_id'] is None):
            raise ValueError("Missing the required parameter `allocation_id` when calling `get_allocation_performance`")  # noqa: E501
        # verify the required parameter 'stat' is set
        if ('stat' not in params or
                params['stat'] is None):
            raise ValueError("Missing the required parameter `stat` when calling `get_allocation_performance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'allocation_id' in params:
            path_params['allocation_id'] = params['allocation_id']  # noqa: E501

        query_params = []
        if 'stat' in params:
            query_params.append(('stat', params['stat']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/allocation/{allocation_id}/performance', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PerformanceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_allocation_transactions(self, allocation_id, **kwargs):  # noqa: E501
        """List all allocation transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_allocation_transactions(allocation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str allocation_id: UUID of an allocation (required)
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: AllocationTransactionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_allocation_transactions_with_http_info(allocation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_allocation_transactions_with_http_info(allocation_id, **kwargs)  # noqa: E501
            return data

    def get_allocation_transactions_with_http_info(self, allocation_id, **kwargs):  # noqa: E501
        """List all allocation transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_allocation_transactions_with_http_info(allocation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str allocation_id: UUID of an allocation (required)
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: AllocationTransactionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['allocation_id', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_allocation_transactions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'allocation_id' is set
        if ('allocation_id' not in params or
                params['allocation_id'] is None):
            raise ValueError("Missing the required parameter `allocation_id` when calling `get_allocation_transactions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'allocation_id' in params:
            path_params['allocation_id'] = params['allocation_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/allocation/{allocation_id}/transaction', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AllocationTransactionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_allocations(self, **kwargs):  # noqa: E501
        """List all allocations  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_allocations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetAllocationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_allocations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_allocations_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_allocations_with_http_info(self, **kwargs):  # noqa: E501
        """List all allocations  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_allocations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetAllocationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_allocations" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_allocations`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_allocations`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/allocation', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAllocationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bank_link(self, bank_link_id, **kwargs):  # noqa: E501
        """Retrieve a bank link  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bank_link(bank_link_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str bank_link_id: UUID of a bank link (required)
        :return: SpecificBankLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_bank_link_with_http_info(bank_link_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_bank_link_with_http_info(bank_link_id, **kwargs)  # noqa: E501
            return data

    def get_bank_link_with_http_info(self, bank_link_id, **kwargs):  # noqa: E501
        """Retrieve a bank link  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bank_link_with_http_info(bank_link_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str bank_link_id: UUID of a bank link (required)
        :return: SpecificBankLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bank_link_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bank_link" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bank_link_id' is set
        if ('bank_link_id' not in params or
                params['bank_link_id'] is None):
            raise ValueError("Missing the required parameter `bank_link_id` when calling `get_bank_link`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bank_link_id' in params:
            path_params['bank_link_id'] = params['bank_link_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/bank_link/{bank_link_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificBankLinkResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bank_links(self, **kwargs):  # noqa: E501
        """List all bank links  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bank_links(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetBankLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_bank_links_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_bank_links_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_bank_links_with_http_info(self, **kwargs):  # noqa: E501
        """List all bank links  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bank_links_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetBankLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bank_links" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_bank_links`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_bank_links`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/bank_link', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetBankLinkResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_benchmark(self, benchmark_id, **kwargs):  # noqa: E501
        """Retrieve a benchmark  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_benchmark(benchmark_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str benchmark_id: UUID of a benchmark (required)
        :return: SpecificBenchmarkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_benchmark_with_http_info(benchmark_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_benchmark_with_http_info(benchmark_id, **kwargs)  # noqa: E501
            return data

    def get_benchmark_with_http_info(self, benchmark_id, **kwargs):  # noqa: E501
        """Retrieve a benchmark  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_benchmark_with_http_info(benchmark_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str benchmark_id: UUID of a benchmark (required)
        :return: SpecificBenchmarkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['benchmark_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_benchmark" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'benchmark_id' is set
        if ('benchmark_id' not in params or
                params['benchmark_id'] is None):
            raise ValueError("Missing the required parameter `benchmark_id` when calling `get_benchmark`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'benchmark_id' in params:
            path_params['benchmark_id'] = params['benchmark_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/benchmark/{benchmark_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificBenchmarkResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_benchmark_asset_sizes(self, benchmark_id, **kwargs):  # noqa: E501
        """List all benchmark asset sizes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_benchmark_asset_sizes(benchmark_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str benchmark_id: UUID of a benchmark (required)
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: BenchmarkAssetSizeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_benchmark_asset_sizes_with_http_info(benchmark_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_benchmark_asset_sizes_with_http_info(benchmark_id, **kwargs)  # noqa: E501
            return data

    def get_benchmark_asset_sizes_with_http_info(self, benchmark_id, **kwargs):  # noqa: E501
        """List all benchmark asset sizes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_benchmark_asset_sizes_with_http_info(benchmark_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str benchmark_id: UUID of a benchmark (required)
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: BenchmarkAssetSizeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['benchmark_id', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_benchmark_asset_sizes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'benchmark_id' is set
        if ('benchmark_id' not in params or
                params['benchmark_id'] is None):
            raise ValueError("Missing the required parameter `benchmark_id` when calling `get_benchmark_asset_sizes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'benchmark_id' in params:
            path_params['benchmark_id'] = params['benchmark_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/benchmark/{benchmark_id}/asset_size', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BenchmarkAssetSizeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_benchmark_performance(self, benchmark_id, stat, **kwargs):  # noqa: E501
        """Get benchmark performance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_benchmark_performance(benchmark_id, stat, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str benchmark_id: UUID of a benchmark (required)
        :param str stat: Performance statistic (required)
        :return: PerformanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_benchmark_performance_with_http_info(benchmark_id, stat, **kwargs)  # noqa: E501
        else:
            (data) = self.get_benchmark_performance_with_http_info(benchmark_id, stat, **kwargs)  # noqa: E501
            return data

    def get_benchmark_performance_with_http_info(self, benchmark_id, stat, **kwargs):  # noqa: E501
        """Get benchmark performance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_benchmark_performance_with_http_info(benchmark_id, stat, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str benchmark_id: UUID of a benchmark (required)
        :param str stat: Performance statistic (required)
        :return: PerformanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['benchmark_id', 'stat']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_benchmark_performance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'benchmark_id' is set
        if ('benchmark_id' not in params or
                params['benchmark_id'] is None):
            raise ValueError("Missing the required parameter `benchmark_id` when calling `get_benchmark_performance`")  # noqa: E501
        # verify the required parameter 'stat' is set
        if ('stat' not in params or
                params['stat'] is None):
            raise ValueError("Missing the required parameter `stat` when calling `get_benchmark_performance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'benchmark_id' in params:
            path_params['benchmark_id'] = params['benchmark_id']  # noqa: E501

        query_params = []
        if 'stat' in params:
            query_params.append(('stat', params['stat']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/benchmark/{benchmark_id}/performance', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PerformanceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_benchmarks(self, **kwargs):  # noqa: E501
        """List all benchmarks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_benchmarks(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetBenchmarkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_benchmarks_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_benchmarks_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_benchmarks_with_http_info(self, **kwargs):  # noqa: E501
        """List all benchmarks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_benchmarks_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetBenchmarkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_benchmarks" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_benchmarks`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_benchmarks`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/benchmark', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetBenchmarkResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_budget(self, budget_id, **kwargs):  # noqa: E501
        """Retrieve a budget  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_budget(budget_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str budget_id: UUID of a budget (required)
        :return: SpecificBudgetResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_budget_with_http_info(budget_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_budget_with_http_info(budget_id, **kwargs)  # noqa: E501
            return data

    def get_budget_with_http_info(self, budget_id, **kwargs):  # noqa: E501
        """Retrieve a budget  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_budget_with_http_info(budget_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str budget_id: UUID of a budget (required)
        :return: SpecificBudgetResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['budget_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_budget" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'budget_id' is set
        if ('budget_id' not in params or
                params['budget_id'] is None):
            raise ValueError("Missing the required parameter `budget_id` when calling `get_budget`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'budget_id' in params:
            path_params['budget_id'] = params['budget_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/budget/{budget_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificBudgetResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_budgets(self, **kwargs):  # noqa: E501
        """List all budgets  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_budgets(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetBudgetResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_budgets_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_budgets_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_budgets_with_http_info(self, **kwargs):  # noqa: E501
        """List all budgets  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_budgets_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetBudgetResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_budgets" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_budgets`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_budgets`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/budget', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetBudgetResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bulk_orders(self, **kwargs):  # noqa: E501
        """List all bulk orders  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bulk_orders(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetBulkOrderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_bulk_orders_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_bulk_orders_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_bulk_orders_with_http_info(self, **kwargs):  # noqa: E501
        """List all bulk orders  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bulk_orders_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetBulkOrderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bulk_orders" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_bulk_orders`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_bulk_orders`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/order_bulk', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetBulkOrderResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_client(self, client_id, **kwargs):  # noqa: E501
        """Retrieve a client  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_client(client_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: UUID of a client (required)
        :return: SpecificClientResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_client_with_http_info(client_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_client_with_http_info(client_id, **kwargs)  # noqa: E501
            return data

    def get_client_with_http_info(self, client_id, **kwargs):  # noqa: E501
        """Retrieve a client  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_client_with_http_info(client_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: UUID of a client (required)
        :return: SpecificClientResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_client" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params or
                params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `get_client`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'client_id' in params:
            path_params['client_id'] = params['client_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/client/{client_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificClientResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_client_asset_sizes(self, client_id, **kwargs):  # noqa: E501
        """List all client asset sizes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_client_asset_sizes(client_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: UUID of a client (required)
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: ClientAssetSizeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_client_asset_sizes_with_http_info(client_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_client_asset_sizes_with_http_info(client_id, **kwargs)  # noqa: E501
            return data

    def get_client_asset_sizes_with_http_info(self, client_id, **kwargs):  # noqa: E501
        """List all client asset sizes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_client_asset_sizes_with_http_info(client_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: UUID of a client (required)
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: ClientAssetSizeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_client_asset_sizes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params or
                params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `get_client_asset_sizes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'client_id' in params:
            path_params['client_id'] = params['client_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/client/{client_id}/asset_size', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClientAssetSizeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_client_holdings(self, client_id, **kwargs):  # noqa: E501
        """List all client holdings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_client_holdings(client_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: UUID of a client (required)
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: ClientHoldingsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_client_holdings_with_http_info(client_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_client_holdings_with_http_info(client_id, **kwargs)  # noqa: E501
            return data

    def get_client_holdings_with_http_info(self, client_id, **kwargs):  # noqa: E501
        """List all client holdings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_client_holdings_with_http_info(client_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: UUID of a client (required)
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: ClientHoldingsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_client_holdings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params or
                params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `get_client_holdings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'client_id' in params:
            path_params['client_id'] = params['client_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/client/{client_id}/holding', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClientHoldingsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_client_hydro(self, client_hydro_id, **kwargs):  # noqa: E501
        """Retrieve a client-hydro relationship  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_client_hydro(client_hydro_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_hydro_id: UUID of a client-hydro relationship (required)
        :return: SpecificClientHydroResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_client_hydro_with_http_info(client_hydro_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_client_hydro_with_http_info(client_hydro_id, **kwargs)  # noqa: E501
            return data

    def get_client_hydro_with_http_info(self, client_hydro_id, **kwargs):  # noqa: E501
        """Retrieve a client-hydro relationship  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_client_hydro_with_http_info(client_hydro_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_hydro_id: UUID of a client-hydro relationship (required)
        :return: SpecificClientHydroResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_hydro_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_client_hydro" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_hydro_id' is set
        if ('client_hydro_id' not in params or
                params['client_hydro_id'] is None):
            raise ValueError("Missing the required parameter `client_hydro_id` when calling `get_client_hydro`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'client_hydro_id' in params:
            path_params['client_hydro_id'] = params['client_hydro_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/client_hydro/{client_hydro_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificClientHydroResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_client_hydros(self, **kwargs):  # noqa: E501
        """List all client-hydro relationships  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_client_hydros(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetClientHydroResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_client_hydros_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_client_hydros_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_client_hydros_with_http_info(self, **kwargs):  # noqa: E501
        """List all client-hydro relationships  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_client_hydros_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetClientHydroResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_client_hydros" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_client_hydros`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_client_hydros`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/client_hydro', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetClientHydroResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_client_performance(self, client_id, stat, **kwargs):  # noqa: E501
        """Get client performance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_client_performance(client_id, stat, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: UUID of a client (required)
        :param str stat: Performance statistic (required)
        :return: PerformanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_client_performance_with_http_info(client_id, stat, **kwargs)  # noqa: E501
        else:
            (data) = self.get_client_performance_with_http_info(client_id, stat, **kwargs)  # noqa: E501
            return data

    def get_client_performance_with_http_info(self, client_id, stat, **kwargs):  # noqa: E501
        """Get client performance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_client_performance_with_http_info(client_id, stat, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: UUID of a client (required)
        :param str stat: Performance statistic (required)
        :return: PerformanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id', 'stat']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_client_performance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params or
                params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `get_client_performance`")  # noqa: E501
        # verify the required parameter 'stat' is set
        if ('stat' not in params or
                params['stat'] is None):
            raise ValueError("Missing the required parameter `stat` when calling `get_client_performance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'client_id' in params:
            path_params['client_id'] = params['client_id']  # noqa: E501

        query_params = []
        if 'stat' in params:
            query_params.append(('stat', params['stat']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/client/{client_id}/performance', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PerformanceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_client_response(self, client_response_id, **kwargs):  # noqa: E501
        """Retrieve a client response  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_client_response(client_response_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_response_id: UUID of a client response (required)
        :return: SpecificClientResponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_client_response_with_http_info(client_response_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_client_response_with_http_info(client_response_id, **kwargs)  # noqa: E501
            return data

    def get_client_response_with_http_info(self, client_response_id, **kwargs):  # noqa: E501
        """Retrieve a client response  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_client_response_with_http_info(client_response_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_response_id: UUID of a client response (required)
        :return: SpecificClientResponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_response_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_client_response" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_response_id' is set
        if ('client_response_id' not in params or
                params['client_response_id'] is None):
            raise ValueError("Missing the required parameter `client_response_id` when calling `get_client_response`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'client_response_id' in params:
            path_params['client_response_id'] = params['client_response_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/client_response/{client_response_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificClientResponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_client_responses(self, **kwargs):  # noqa: E501
        """List all client responses  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_client_responses(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetClientResponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_client_responses_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_client_responses_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_client_responses_with_http_info(self, **kwargs):  # noqa: E501
        """List all client responses  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_client_responses_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetClientResponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_client_responses" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_client_responses`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_client_responses`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/client_response', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetClientResponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_client_transactions(self, client_id, **kwargs):  # noqa: E501
        """List all client transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_client_transactions(client_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: UUID of a client (required)
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: ClientTransactionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_client_transactions_with_http_info(client_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_client_transactions_with_http_info(client_id, **kwargs)  # noqa: E501
            return data

    def get_client_transactions_with_http_info(self, client_id, **kwargs):  # noqa: E501
        """List all client transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_client_transactions_with_http_info(client_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: UUID of a client (required)
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: ClientTransactionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_client_transactions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params or
                params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `get_client_transactions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'client_id' in params:
            path_params['client_id'] = params['client_id']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/client/{client_id}/transaction', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClientTransactionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_clients(self, **kwargs):  # noqa: E501
        """List all clients  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_clients(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetClientResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_clients_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_clients_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_clients_with_http_info(self, **kwargs):  # noqa: E501
        """List all clients  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_clients_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetClientResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_clients" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_clients`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_clients`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/client', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetClientResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_decision_tree(self, decision_tree_id, **kwargs):  # noqa: E501
        """Retrieve a decision tree  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decision_tree(decision_tree_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str decision_tree_id: UUID of a decision tree (required)
        :return: SpecificDecisionTreeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_decision_tree_with_http_info(decision_tree_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_decision_tree_with_http_info(decision_tree_id, **kwargs)  # noqa: E501
            return data

    def get_decision_tree_with_http_info(self, decision_tree_id, **kwargs):  # noqa: E501
        """Retrieve a decision tree  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decision_tree_with_http_info(decision_tree_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str decision_tree_id: UUID of a decision tree (required)
        :return: SpecificDecisionTreeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['decision_tree_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_decision_tree" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'decision_tree_id' is set
        if ('decision_tree_id' not in params or
                params['decision_tree_id'] is None):
            raise ValueError("Missing the required parameter `decision_tree_id` when calling `get_decision_tree`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'decision_tree_id' in params:
            path_params['decision_tree_id'] = params['decision_tree_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/decision_tree/{decision_tree_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificDecisionTreeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_decision_trees(self, **kwargs):  # noqa: E501
        """List all decision trees  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decision_trees(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetDecisionTreeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_decision_trees_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_decision_trees_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_decision_trees_with_http_info(self, **kwargs):  # noqa: E501
        """List all decision trees  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decision_trees_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetDecisionTreeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_decision_trees" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_decision_trees`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_decision_trees`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/decision_tree', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetDecisionTreeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_deposit_request(self, deposit_id, **kwargs):  # noqa: E501
        """Retrieve a deposit request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_deposit_request(deposit_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str deposit_id: UUID of a deposit record (required)
        :return: SpecificDepositRequestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_deposit_request_with_http_info(deposit_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_deposit_request_with_http_info(deposit_id, **kwargs)  # noqa: E501
            return data

    def get_deposit_request_with_http_info(self, deposit_id, **kwargs):  # noqa: E501
        """Retrieve a deposit request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_deposit_request_with_http_info(deposit_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str deposit_id: UUID of a deposit record (required)
        :return: SpecificDepositRequestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deposit_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_deposit_request" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deposit_id' is set
        if ('deposit_id' not in params or
                params['deposit_id'] is None):
            raise ValueError("Missing the required parameter `deposit_id` when calling `get_deposit_request`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deposit_id' in params:
            path_params['deposit_id'] = params['deposit_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/deposit/{deposit_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificDepositRequestResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_deposit_requests(self, **kwargs):  # noqa: E501
        """List all deposit requests  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_deposit_requests(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetDepositRequestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_deposit_requests_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_deposit_requests_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_deposit_requests_with_http_info(self, **kwargs):  # noqa: E501
        """List all deposit requests  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_deposit_requests_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetDepositRequestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_deposit_requests" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_deposit_requests`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_deposit_requests`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/deposit', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetDepositRequestResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_financial_offer(self, financial_offer_id, **kwargs):  # noqa: E501
        """Retrieve a financial offer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_financial_offer(financial_offer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str financial_offer_id: UUID of a financial offer (required)
        :return: SpecificFinancialOfferResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_financial_offer_with_http_info(financial_offer_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_financial_offer_with_http_info(financial_offer_id, **kwargs)  # noqa: E501
            return data

    def get_financial_offer_with_http_info(self, financial_offer_id, **kwargs):  # noqa: E501
        """Retrieve a financial offer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_financial_offer_with_http_info(financial_offer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str financial_offer_id: UUID of a financial offer (required)
        :return: SpecificFinancialOfferResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['financial_offer_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_financial_offer" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'financial_offer_id' is set
        if ('financial_offer_id' not in params or
                params['financial_offer_id'] is None):
            raise ValueError("Missing the required parameter `financial_offer_id` when calling `get_financial_offer`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'financial_offer_id' in params:
            path_params['financial_offer_id'] = params['financial_offer_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/financial_offer/{financial_offer_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificFinancialOfferResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_financial_offers(self, **kwargs):  # noqa: E501
        """List all financial offers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_financial_offers(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetFinancialOfferResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_financial_offers_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_financial_offers_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_financial_offers_with_http_info(self, **kwargs):  # noqa: E501
        """List all financial offers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_financial_offers_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetFinancialOfferResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_financial_offers" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_financial_offers`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_financial_offers`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/financial_offer', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetFinancialOfferResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_funding_request(self, funding_id, **kwargs):  # noqa: E501
        """Retrieve a funding request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_funding_request(funding_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str funding_id: UUID of a funding record (required)
        :return: SpecificFundingRequestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_funding_request_with_http_info(funding_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_funding_request_with_http_info(funding_id, **kwargs)  # noqa: E501
            return data

    def get_funding_request_with_http_info(self, funding_id, **kwargs):  # noqa: E501
        """Retrieve a funding request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_funding_request_with_http_info(funding_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str funding_id: UUID of a funding record (required)
        :return: SpecificFundingRequestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['funding_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_funding_request" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'funding_id' is set
        if ('funding_id' not in params or
                params['funding_id'] is None):
            raise ValueError("Missing the required parameter `funding_id` when calling `get_funding_request`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'funding_id' in params:
            path_params['funding_id'] = params['funding_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/funding/{funding_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificFundingRequestResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_funding_requests(self, **kwargs):  # noqa: E501
        """List all funding requests  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_funding_requests(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetFundingRequestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_funding_requests_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_funding_requests_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_funding_requests_with_http_info(self, **kwargs):  # noqa: E501
        """List all funding requests  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_funding_requests_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetFundingRequestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_funding_requests" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_funding_requests`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_funding_requests`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/funding', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetFundingRequestResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_goal(self, goal_id, **kwargs):  # noqa: E501
        """Retrieve a goal  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_goal(goal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str goal_id: UUID of a goal (required)
        :return: SpecificGoalResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_goal_with_http_info(goal_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_goal_with_http_info(goal_id, **kwargs)  # noqa: E501
            return data

    def get_goal_with_http_info(self, goal_id, **kwargs):  # noqa: E501
        """Retrieve a goal  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_goal_with_http_info(goal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str goal_id: UUID of a goal (required)
        :return: SpecificGoalResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['goal_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_goal" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'goal_id' is set
        if ('goal_id' not in params or
                params['goal_id'] is None):
            raise ValueError("Missing the required parameter `goal_id` when calling `get_goal`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'goal_id' in params:
            path_params['goal_id'] = params['goal_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/goal/{goal_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificGoalResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_goal_asset_sizes(self, goal_id, client_id, **kwargs):  # noqa: E501
        """List goal asset sizes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_goal_asset_sizes(goal_id, client_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str goal_id: UUID of a goal (required)
        :param str client_id: UUID of a client (required)
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GoalAssetSizeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_goal_asset_sizes_with_http_info(goal_id, client_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_goal_asset_sizes_with_http_info(goal_id, client_id, **kwargs)  # noqa: E501
            return data

    def get_goal_asset_sizes_with_http_info(self, goal_id, client_id, **kwargs):  # noqa: E501
        """List goal asset sizes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_goal_asset_sizes_with_http_info(goal_id, client_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str goal_id: UUID of a goal (required)
        :param str client_id: UUID of a client (required)
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GoalAssetSizeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['goal_id', 'client_id', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_goal_asset_sizes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'goal_id' is set
        if ('goal_id' not in params or
                params['goal_id'] is None):
            raise ValueError("Missing the required parameter `goal_id` when calling `get_goal_asset_sizes`")  # noqa: E501
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params or
                params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `get_goal_asset_sizes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'goal_id' in params:
            path_params['goal_id'] = params['goal_id']  # noqa: E501

        query_params = []
        if 'client_id' in params:
            query_params.append(('client_id', params['client_id']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/goal/{goal_id}/asset_size', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GoalAssetSizeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_goal_holdings(self, goal_id, client_id, **kwargs):  # noqa: E501
        """List goal holdings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_goal_holdings(goal_id, client_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str goal_id: UUID of a goal (required)
        :param str client_id: UUID of a client (required)
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GoalHoldingsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_goal_holdings_with_http_info(goal_id, client_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_goal_holdings_with_http_info(goal_id, client_id, **kwargs)  # noqa: E501
            return data

    def get_goal_holdings_with_http_info(self, goal_id, client_id, **kwargs):  # noqa: E501
        """List goal holdings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_goal_holdings_with_http_info(goal_id, client_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str goal_id: UUID of a goal (required)
        :param str client_id: UUID of a client (required)
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GoalHoldingsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['goal_id', 'client_id', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_goal_holdings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'goal_id' is set
        if ('goal_id' not in params or
                params['goal_id'] is None):
            raise ValueError("Missing the required parameter `goal_id` when calling `get_goal_holdings`")  # noqa: E501
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params or
                params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `get_goal_holdings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'goal_id' in params:
            path_params['goal_id'] = params['goal_id']  # noqa: E501

        query_params = []
        if 'client_id' in params:
            query_params.append(('client_id', params['client_id']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/goal/{goal_id}/holding', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GoalHoldingsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_goal_performance(self, goal_id, stat, client_id, **kwargs):  # noqa: E501
        """Get goal performance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_goal_performance(goal_id, stat, client_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str goal_id: UUID of a goal (required)
        :param str stat: Performance statistic (required)
        :param str client_id: UUID of a client (required)
        :return: PerformanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_goal_performance_with_http_info(goal_id, stat, client_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_goal_performance_with_http_info(goal_id, stat, client_id, **kwargs)  # noqa: E501
            return data

    def get_goal_performance_with_http_info(self, goal_id, stat, client_id, **kwargs):  # noqa: E501
        """Get goal performance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_goal_performance_with_http_info(goal_id, stat, client_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str goal_id: UUID of a goal (required)
        :param str stat: Performance statistic (required)
        :param str client_id: UUID of a client (required)
        :return: PerformanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['goal_id', 'stat', 'client_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_goal_performance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'goal_id' is set
        if ('goal_id' not in params or
                params['goal_id'] is None):
            raise ValueError("Missing the required parameter `goal_id` when calling `get_goal_performance`")  # noqa: E501
        # verify the required parameter 'stat' is set
        if ('stat' not in params or
                params['stat'] is None):
            raise ValueError("Missing the required parameter `stat` when calling `get_goal_performance`")  # noqa: E501
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params or
                params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `get_goal_performance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'goal_id' in params:
            path_params['goal_id'] = params['goal_id']  # noqa: E501

        query_params = []
        if 'stat' in params:
            query_params.append(('stat', params['stat']))  # noqa: E501
        if 'client_id' in params:
            query_params.append(('client_id', params['client_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/goal/{goal_id}/performance', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PerformanceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_goal_track_record(self, goal_track_id, **kwargs):  # noqa: E501
        """Retrieve a goal track record  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_goal_track_record(goal_track_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str goal_track_id: UUID of a goal tracking record (required)
        :return: SpecificGoalTrackResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_goal_track_record_with_http_info(goal_track_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_goal_track_record_with_http_info(goal_track_id, **kwargs)  # noqa: E501
            return data

    def get_goal_track_record_with_http_info(self, goal_track_id, **kwargs):  # noqa: E501
        """Retrieve a goal track record  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_goal_track_record_with_http_info(goal_track_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str goal_track_id: UUID of a goal tracking record (required)
        :return: SpecificGoalTrackResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['goal_track_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_goal_track_record" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'goal_track_id' is set
        if ('goal_track_id' not in params or
                params['goal_track_id'] is None):
            raise ValueError("Missing the required parameter `goal_track_id` when calling `get_goal_track_record`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'goal_track_id' in params:
            path_params['goal_track_id'] = params['goal_track_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/goal_track/{goal_track_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificGoalTrackResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_goal_track_records(self, **kwargs):  # noqa: E501
        """List all goal track records  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_goal_track_records(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetGoalTrackResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_goal_track_records_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_goal_track_records_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_goal_track_records_with_http_info(self, **kwargs):  # noqa: E501
        """List all goal track records  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_goal_track_records_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetGoalTrackResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_goal_track_records" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_goal_track_records`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_goal_track_records`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/goal_track', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetGoalTrackResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_goal_transactions(self, goal_id, client_id, **kwargs):  # noqa: E501
        """List goal transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_goal_transactions(goal_id, client_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str goal_id: UUID of a goal (required)
        :param str client_id: UUID of a client (required)
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GoalTransactionsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_goal_transactions_with_http_info(goal_id, client_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_goal_transactions_with_http_info(goal_id, client_id, **kwargs)  # noqa: E501
            return data

    def get_goal_transactions_with_http_info(self, goal_id, client_id, **kwargs):  # noqa: E501
        """List goal transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_goal_transactions_with_http_info(goal_id, client_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str goal_id: UUID of a goal (required)
        :param str client_id: UUID of a client (required)
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GoalTransactionsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['goal_id', 'client_id', 'page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_goal_transactions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'goal_id' is set
        if ('goal_id' not in params or
                params['goal_id'] is None):
            raise ValueError("Missing the required parameter `goal_id` when calling `get_goal_transactions`")  # noqa: E501
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params or
                params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `get_goal_transactions`")  # noqa: E501

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_goal_transactions`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_goal_transactions`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'goal_id' in params:
            path_params['goal_id'] = params['goal_id']  # noqa: E501

        query_params = []
        if 'client_id' in params:
            query_params.append(('client_id', params['client_id']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/goal/{goal_id}/transaction', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GoalTransactionsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_goals(self, **kwargs):  # noqa: E501
        """List all goals  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_goals(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetGoalResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_goals_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_goals_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_goals_with_http_info(self, **kwargs):  # noqa: E501
        """List all goals  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_goals_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetGoalResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_goals" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_goals`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_goals`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/goal', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetGoalResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_model(self, model_id, **kwargs):  # noqa: E501
        """Retrieve a model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model(model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_id: UUID of a model (required)
        :return: SpecificModelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_model_with_http_info(model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_model_with_http_info(model_id, **kwargs)  # noqa: E501
            return data

    def get_model_with_http_info(self, model_id, **kwargs):  # noqa: E501
        """Retrieve a model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_with_http_info(model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_id: UUID of a model (required)
        :return: SpecificModelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_id' is set
        if ('model_id' not in params or
                params['model_id'] is None):
            raise ValueError("Missing the required parameter `model_id` when calling `get_model`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_id' in params:
            path_params['model_id'] = params['model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/model/{model_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificModelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_model_asset_size(self, model_asset_size_id, **kwargs):  # noqa: E501
        """Retrieve a model asset size  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_asset_size(model_asset_size_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_asset_size_id: UUID of a model asset size record (required)
        :return: SpecificModelAssetSizeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_model_asset_size_with_http_info(model_asset_size_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_model_asset_size_with_http_info(model_asset_size_id, **kwargs)  # noqa: E501
            return data

    def get_model_asset_size_with_http_info(self, model_asset_size_id, **kwargs):  # noqa: E501
        """Retrieve a model asset size  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_asset_size_with_http_info(model_asset_size_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_asset_size_id: UUID of a model asset size record (required)
        :return: SpecificModelAssetSizeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_asset_size_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model_asset_size" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_asset_size_id' is set
        if ('model_asset_size_id' not in params or
                params['model_asset_size_id'] is None):
            raise ValueError("Missing the required parameter `model_asset_size_id` when calling `get_model_asset_size`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_asset_size_id' in params:
            path_params['model_asset_size_id'] = params['model_asset_size_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/model_asset_size/{model_asset_size_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificModelAssetSizeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_model_asset_sizes(self, **kwargs):  # noqa: E501
        """List all model asset sizes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_asset_sizes(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetModelAssetSizeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_model_asset_sizes_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_model_asset_sizes_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_model_asset_sizes_with_http_info(self, **kwargs):  # noqa: E501
        """List all model asset sizes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_asset_sizes_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetModelAssetSizeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model_asset_sizes" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_model_asset_sizes`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_model_asset_sizes`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/model_asset_size', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetModelAssetSizeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_model_comment(self, model_comment_id, **kwargs):  # noqa: E501
        """Retrieve a model commentary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_comment(model_comment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_comment_id: UUID of a model comment (required)
        :return: SpecificModelCommentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_model_comment_with_http_info(model_comment_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_model_comment_with_http_info(model_comment_id, **kwargs)  # noqa: E501
            return data

    def get_model_comment_with_http_info(self, model_comment_id, **kwargs):  # noqa: E501
        """Retrieve a model commentary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_comment_with_http_info(model_comment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_comment_id: UUID of a model comment (required)
        :return: SpecificModelCommentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_comment_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model_comment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_comment_id' is set
        if ('model_comment_id' not in params or
                params['model_comment_id'] is None):
            raise ValueError("Missing the required parameter `model_comment_id` when calling `get_model_comment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_comment_id' in params:
            path_params['model_comment_id'] = params['model_comment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/model_comment/{model_comment_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificModelCommentResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_model_comments(self, **kwargs):  # noqa: E501
        """List all model commentary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_comments(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetModelCommentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_model_comments_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_model_comments_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_model_comments_with_http_info(self, **kwargs):  # noqa: E501
        """List all model commentary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_comments_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetModelCommentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model_comments" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_model_comments`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_model_comments`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/model_comment', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetModelCommentResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_model_holding(self, model_holding_id, **kwargs):  # noqa: E501
        """Retrieve a model holding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_holding(model_holding_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_holding_id: UUID of a model holding record (required)
        :return: SpecificModelHoldingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_model_holding_with_http_info(model_holding_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_model_holding_with_http_info(model_holding_id, **kwargs)  # noqa: E501
            return data

    def get_model_holding_with_http_info(self, model_holding_id, **kwargs):  # noqa: E501
        """Retrieve a model holding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_holding_with_http_info(model_holding_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_holding_id: UUID of a model holding record (required)
        :return: SpecificModelHoldingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_holding_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model_holding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_holding_id' is set
        if ('model_holding_id' not in params or
                params['model_holding_id'] is None):
            raise ValueError("Missing the required parameter `model_holding_id` when calling `get_model_holding`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_holding_id' in params:
            path_params['model_holding_id'] = params['model_holding_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/model_holding/{model_holding_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificModelHoldingResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_model_holdings(self, **kwargs):  # noqa: E501
        """List all model holdings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_holdings(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetModelHoldingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_model_holdings_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_model_holdings_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_model_holdings_with_http_info(self, **kwargs):  # noqa: E501
        """List all model holdings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_holdings_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetModelHoldingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model_holdings" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_model_holdings`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_model_holdings`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/model_holding', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetModelHoldingResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_model_performance(self, model_id, stat, **kwargs):  # noqa: E501
        """Get model performance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_performance(model_id, stat, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_id: UUID of a model (required)
        :param str stat: Performance statistic (required)
        :return: PerformanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_model_performance_with_http_info(model_id, stat, **kwargs)  # noqa: E501
        else:
            (data) = self.get_model_performance_with_http_info(model_id, stat, **kwargs)  # noqa: E501
            return data

    def get_model_performance_with_http_info(self, model_id, stat, **kwargs):  # noqa: E501
        """Get model performance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_performance_with_http_info(model_id, stat, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_id: UUID of a model (required)
        :param str stat: Performance statistic (required)
        :return: PerformanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_id', 'stat']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model_performance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_id' is set
        if ('model_id' not in params or
                params['model_id'] is None):
            raise ValueError("Missing the required parameter `model_id` when calling `get_model_performance`")  # noqa: E501
        # verify the required parameter 'stat' is set
        if ('stat' not in params or
                params['stat'] is None):
            raise ValueError("Missing the required parameter `stat` when calling `get_model_performance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_id' in params:
            path_params['model_id'] = params['model_id']  # noqa: E501

        query_params = []
        if 'stat' in params:
            query_params.append(('stat', params['stat']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/model/{model_id}/performance', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PerformanceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_model_transaction(self, model_transaction_id, **kwargs):  # noqa: E501
        """Retrieve a model transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_transaction(model_transaction_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_transaction_id: UUID of a model transaction record (required)
        :return: SpecificModelTransactionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_model_transaction_with_http_info(model_transaction_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_model_transaction_with_http_info(model_transaction_id, **kwargs)  # noqa: E501
            return data

    def get_model_transaction_with_http_info(self, model_transaction_id, **kwargs):  # noqa: E501
        """Retrieve a model transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_transaction_with_http_info(model_transaction_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_transaction_id: UUID of a model transaction record (required)
        :return: SpecificModelTransactionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_transaction_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model_transaction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_transaction_id' is set
        if ('model_transaction_id' not in params or
                params['model_transaction_id'] is None):
            raise ValueError("Missing the required parameter `model_transaction_id` when calling `get_model_transaction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_transaction_id' in params:
            path_params['model_transaction_id'] = params['model_transaction_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/model_transaction/{model_transaction_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificModelTransactionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_model_transactions(self, **kwargs):  # noqa: E501
        """List all model transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_transactions(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetModelTransactionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_model_transactions_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_model_transactions_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_model_transactions_with_http_info(self, **kwargs):  # noqa: E501
        """List all model transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_transactions_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetModelTransactionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model_transactions" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_model_transactions`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_model_transactions`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/model_transaction', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetModelTransactionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_models(self, **kwargs):  # noqa: E501
        """List all models  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_models(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetModelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_models_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_models_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_models_with_http_info(self, **kwargs):  # noqa: E501
        """List all models  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_models_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetModelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_models" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_models`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_models`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/model', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetModelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_node(self, node_id, **kwargs):  # noqa: E501
        """Retrieve a node  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_node(node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_id: UUID of a node (required)
        :return: SpecificNodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_node_with_http_info(node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_node_with_http_info(node_id, **kwargs)  # noqa: E501
            return data

    def get_node_with_http_info(self, node_id, **kwargs):  # noqa: E501
        """Retrieve a node  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_node_with_http_info(node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_id: UUID of a node (required)
        :return: SpecificNodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_id' is set
        if ('node_id' not in params or
                params['node_id'] is None):
            raise ValueError("Missing the required parameter `node_id` when calling `get_node`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_id' in params:
            path_params['node_id'] = params['node_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/node/{node_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificNodeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_node_relationship(self, node_relationship_id, **kwargs):  # noqa: E501
        """Retrieve a node relationship  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_node_relationship(node_relationship_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_relationship_id: UUID of a node relationship (required)
        :return: SpecificNodeRelationshipResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_node_relationship_with_http_info(node_relationship_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_node_relationship_with_http_info(node_relationship_id, **kwargs)  # noqa: E501
            return data

    def get_node_relationship_with_http_info(self, node_relationship_id, **kwargs):  # noqa: E501
        """Retrieve a node relationship  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_node_relationship_with_http_info(node_relationship_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_relationship_id: UUID of a node relationship (required)
        :return: SpecificNodeRelationshipResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_relationship_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_node_relationship" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_relationship_id' is set
        if ('node_relationship_id' not in params or
                params['node_relationship_id'] is None):
            raise ValueError("Missing the required parameter `node_relationship_id` when calling `get_node_relationship`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_relationship_id' in params:
            path_params['node_relationship_id'] = params['node_relationship_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/node_relationship/{node_relationship_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificNodeRelationshipResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_node_relationships(self, **kwargs):  # noqa: E501
        """List all node relationships  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_node_relationships(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetNodeRelationshipResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_node_relationships_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_node_relationships_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_node_relationships_with_http_info(self, **kwargs):  # noqa: E501
        """List all node relationships  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_node_relationships_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetNodeRelationshipResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_node_relationships" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_node_relationships`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_node_relationships`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/node_relationship', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetNodeRelationshipResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_nodes(self, **kwargs):  # noqa: E501
        """List all nodes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_nodes(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetNodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_nodes_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_nodes_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_nodes_with_http_info(self, **kwargs):  # noqa: E501
        """List all nodes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_nodes_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetNodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_nodes" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_nodes`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_nodes`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/node', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetNodeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_order_record(self, order_id, **kwargs):  # noqa: E501
        """Retrieve an order record  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_order_record(order_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order_id: UUID of an order record (required)
        :return: SpecificOrderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_order_record_with_http_info(order_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_order_record_with_http_info(order_id, **kwargs)  # noqa: E501
            return data

    def get_order_record_with_http_info(self, order_id, **kwargs):  # noqa: E501
        """Retrieve an order record  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_order_record_with_http_info(order_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order_id: UUID of an order record (required)
        :return: SpecificOrderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['order_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_order_record" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'order_id' is set
        if ('order_id' not in params or
                params['order_id'] is None):
            raise ValueError("Missing the required parameter `order_id` when calling `get_order_record`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'order_id' in params:
            path_params['order_id'] = params['order_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/order/{order_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificOrderResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_order_records(self, **kwargs):  # noqa: E501
        """List all order records  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_order_records(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetOrderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_order_records_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_order_records_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_order_records_with_http_info(self, **kwargs):  # noqa: E501
        """List all order records  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_order_records_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetOrderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_order_records" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_order_records`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_order_records`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/order', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetOrderResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_order_status(self, order_status_id, **kwargs):  # noqa: E501
        """Retrieve an order status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_order_status(order_status_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order_status_id: UUID of an order status record (required)
        :return: SpecificOrderStatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_order_status_with_http_info(order_status_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_order_status_with_http_info(order_status_id, **kwargs)  # noqa: E501
            return data

    def get_order_status_with_http_info(self, order_status_id, **kwargs):  # noqa: E501
        """Retrieve an order status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_order_status_with_http_info(order_status_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order_status_id: UUID of an order status record (required)
        :return: SpecificOrderStatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['order_status_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_order_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'order_status_id' is set
        if ('order_status_id' not in params or
                params['order_status_id'] is None):
            raise ValueError("Missing the required parameter `order_status_id` when calling `get_order_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'order_status_id' in params:
            path_params['order_status_id'] = params['order_status_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/order_status/{order_status_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificOrderStatusResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_order_statuses(self, **kwargs):  # noqa: E501
        """List all order statuses  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_order_statuses(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetOrderStatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_order_statuses_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_order_statuses_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_order_statuses_with_http_info(self, **kwargs):  # noqa: E501
        """List all order statuses  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_order_statuses_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetOrderStatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_order_statuses" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_order_statuses`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_order_statuses`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/order_status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetOrderStatusResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_order_tracking_record(self, order_track_id, **kwargs):  # noqa: E501
        """Retrieve an order tracking record  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_order_tracking_record(order_track_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order_track_id: UUID of an order tracking record (required)
        :return: SpecificOrderTrackResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_order_tracking_record_with_http_info(order_track_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_order_tracking_record_with_http_info(order_track_id, **kwargs)  # noqa: E501
            return data

    def get_order_tracking_record_with_http_info(self, order_track_id, **kwargs):  # noqa: E501
        """Retrieve an order tracking record  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_order_tracking_record_with_http_info(order_track_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order_track_id: UUID of an order tracking record (required)
        :return: SpecificOrderTrackResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['order_track_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_order_tracking_record" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'order_track_id' is set
        if ('order_track_id' not in params or
                params['order_track_id'] is None):
            raise ValueError("Missing the required parameter `order_track_id` when calling `get_order_tracking_record`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'order_track_id' in params:
            path_params['order_track_id'] = params['order_track_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/order_track/{order_track_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificOrderTrackResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_order_tracking_records(self, **kwargs):  # noqa: E501
        """List all order tracking records  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_order_tracking_records(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetOrderTrackResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_order_tracking_records_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_order_tracking_records_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_order_tracking_records_with_http_info(self, **kwargs):  # noqa: E501
        """List all order tracking records  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_order_tracking_records_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetOrderTrackResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_order_tracking_records" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_order_tracking_records`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_order_tracking_records`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/order_track', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetOrderTrackResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_portfolio(self, portfolio_id, **kwargs):  # noqa: E501
        """Retrieve a portfolio  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_portfolio(portfolio_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_id: UUID of a portfolio (required)
        :return: SpecificPortfolioResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_portfolio_with_http_info(portfolio_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_portfolio_with_http_info(portfolio_id, **kwargs)  # noqa: E501
            return data

    def get_portfolio_with_http_info(self, portfolio_id, **kwargs):  # noqa: E501
        """Retrieve a portfolio  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_portfolio_with_http_info(portfolio_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_id: UUID of a portfolio (required)
        :return: SpecificPortfolioResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portfolio_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_portfolio" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portfolio_id' is set
        if ('portfolio_id' not in params or
                params['portfolio_id'] is None):
            raise ValueError("Missing the required parameter `portfolio_id` when calling `get_portfolio`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portfolio_id' in params:
            path_params['portfolio_id'] = params['portfolio_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/portfolio/{portfolio_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificPortfolioResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_portfolio_asset_size(self, portfolio_asset_size_id, **kwargs):  # noqa: E501
        """Retrieve a portfolio asset size  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_portfolio_asset_size(portfolio_asset_size_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_asset_size_id: UUID of a portfolio asset size record (required)
        :return: SpecificPortfolioAssetSizeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_portfolio_asset_size_with_http_info(portfolio_asset_size_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_portfolio_asset_size_with_http_info(portfolio_asset_size_id, **kwargs)  # noqa: E501
            return data

    def get_portfolio_asset_size_with_http_info(self, portfolio_asset_size_id, **kwargs):  # noqa: E501
        """Retrieve a portfolio asset size  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_portfolio_asset_size_with_http_info(portfolio_asset_size_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_asset_size_id: UUID of a portfolio asset size record (required)
        :return: SpecificPortfolioAssetSizeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portfolio_asset_size_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_portfolio_asset_size" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portfolio_asset_size_id' is set
        if ('portfolio_asset_size_id' not in params or
                params['portfolio_asset_size_id'] is None):
            raise ValueError("Missing the required parameter `portfolio_asset_size_id` when calling `get_portfolio_asset_size`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portfolio_asset_size_id' in params:
            path_params['portfolio_asset_size_id'] = params['portfolio_asset_size_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/portfolio_asset_size/{portfolio_asset_size_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificPortfolioAssetSizeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_portfolio_asset_sizes(self, **kwargs):  # noqa: E501
        """List all portfolio asset sizes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_portfolio_asset_sizes(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetPortfolioAssetSizeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_portfolio_asset_sizes_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_portfolio_asset_sizes_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_portfolio_asset_sizes_with_http_info(self, **kwargs):  # noqa: E501
        """List all portfolio asset sizes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_portfolio_asset_sizes_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetPortfolioAssetSizeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_portfolio_asset_sizes" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_portfolio_asset_sizes`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_portfolio_asset_sizes`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/portfolio_asset_size', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetPortfolioAssetSizeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_portfolio_comment(self, portfolio_comment_id, **kwargs):  # noqa: E501
        """Retrieve a portfolio commentary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_portfolio_comment(portfolio_comment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_comment_id: UUID of a portfolio comment (required)
        :return: SpecificPortfolioCommentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_portfolio_comment_with_http_info(portfolio_comment_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_portfolio_comment_with_http_info(portfolio_comment_id, **kwargs)  # noqa: E501
            return data

    def get_portfolio_comment_with_http_info(self, portfolio_comment_id, **kwargs):  # noqa: E501
        """Retrieve a portfolio commentary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_portfolio_comment_with_http_info(portfolio_comment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_comment_id: UUID of a portfolio comment (required)
        :return: SpecificPortfolioCommentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portfolio_comment_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_portfolio_comment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portfolio_comment_id' is set
        if ('portfolio_comment_id' not in params or
                params['portfolio_comment_id'] is None):
            raise ValueError("Missing the required parameter `portfolio_comment_id` when calling `get_portfolio_comment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portfolio_comment_id' in params:
            path_params['portfolio_comment_id'] = params['portfolio_comment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/portfolio_comment/{portfolio_comment_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificPortfolioCommentResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_portfolio_comments(self, **kwargs):  # noqa: E501
        """List all portfolio commentary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_portfolio_comments(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetPortfolioCommentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_portfolio_comments_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_portfolio_comments_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_portfolio_comments_with_http_info(self, **kwargs):  # noqa: E501
        """List all portfolio commentary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_portfolio_comments_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetPortfolioCommentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_portfolio_comments" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_portfolio_comments`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_portfolio_comments`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/portfolio_comment', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetPortfolioCommentResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_portfolio_holding(self, portfolio_holding_id, **kwargs):  # noqa: E501
        """Retrieve a portfolio holding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_portfolio_holding(portfolio_holding_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_holding_id: UUID of a portfolio holding record (required)
        :return: SpecificPortfolioHoldingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_portfolio_holding_with_http_info(portfolio_holding_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_portfolio_holding_with_http_info(portfolio_holding_id, **kwargs)  # noqa: E501
            return data

    def get_portfolio_holding_with_http_info(self, portfolio_holding_id, **kwargs):  # noqa: E501
        """Retrieve a portfolio holding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_portfolio_holding_with_http_info(portfolio_holding_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_holding_id: UUID of a portfolio holding record (required)
        :return: SpecificPortfolioHoldingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portfolio_holding_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_portfolio_holding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portfolio_holding_id' is set
        if ('portfolio_holding_id' not in params or
                params['portfolio_holding_id'] is None):
            raise ValueError("Missing the required parameter `portfolio_holding_id` when calling `get_portfolio_holding`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portfolio_holding_id' in params:
            path_params['portfolio_holding_id'] = params['portfolio_holding_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/portfolio_holding/{portfolio_holding_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificPortfolioHoldingResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_portfolio_holdings(self, **kwargs):  # noqa: E501
        """List all portfolio holdings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_portfolio_holdings(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetPortfolioHoldingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_portfolio_holdings_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_portfolio_holdings_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_portfolio_holdings_with_http_info(self, **kwargs):  # noqa: E501
        """List all portfolio holdings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_portfolio_holdings_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetPortfolioHoldingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_portfolio_holdings" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_portfolio_holdings`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_portfolio_holdings`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/portfolio_holding', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetPortfolioHoldingResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_portfolio_performance(self, portfolio_id, stat, **kwargs):  # noqa: E501
        """Get portfolio performance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_portfolio_performance(portfolio_id, stat, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_id: UUID of a portfolio (required)
        :param str stat: Performance statistic (required)
        :return: PerformanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_portfolio_performance_with_http_info(portfolio_id, stat, **kwargs)  # noqa: E501
        else:
            (data) = self.get_portfolio_performance_with_http_info(portfolio_id, stat, **kwargs)  # noqa: E501
            return data

    def get_portfolio_performance_with_http_info(self, portfolio_id, stat, **kwargs):  # noqa: E501
        """Get portfolio performance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_portfolio_performance_with_http_info(portfolio_id, stat, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_id: UUID of a portfolio (required)
        :param str stat: Performance statistic (required)
        :return: PerformanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portfolio_id', 'stat']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_portfolio_performance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portfolio_id' is set
        if ('portfolio_id' not in params or
                params['portfolio_id'] is None):
            raise ValueError("Missing the required parameter `portfolio_id` when calling `get_portfolio_performance`")  # noqa: E501
        # verify the required parameter 'stat' is set
        if ('stat' not in params or
                params['stat'] is None):
            raise ValueError("Missing the required parameter `stat` when calling `get_portfolio_performance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portfolio_id' in params:
            path_params['portfolio_id'] = params['portfolio_id']  # noqa: E501

        query_params = []
        if 'stat' in params:
            query_params.append(('stat', params['stat']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/portfolio/{portfolio_id}/performance', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PerformanceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_portfolio_transaction(self, portfolio_transaction_id, **kwargs):  # noqa: E501
        """Retrieve a portfolio transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_portfolio_transaction(portfolio_transaction_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_transaction_id: UUID of a portfolio transaction record (required)
        :return: SpecificPortfolioTransactionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_portfolio_transaction_with_http_info(portfolio_transaction_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_portfolio_transaction_with_http_info(portfolio_transaction_id, **kwargs)  # noqa: E501
            return data

    def get_portfolio_transaction_with_http_info(self, portfolio_transaction_id, **kwargs):  # noqa: E501
        """Retrieve a portfolio transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_portfolio_transaction_with_http_info(portfolio_transaction_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_transaction_id: UUID of a portfolio transaction record (required)
        :return: SpecificPortfolioTransactionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portfolio_transaction_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_portfolio_transaction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portfolio_transaction_id' is set
        if ('portfolio_transaction_id' not in params or
                params['portfolio_transaction_id'] is None):
            raise ValueError("Missing the required parameter `portfolio_transaction_id` when calling `get_portfolio_transaction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portfolio_transaction_id' in params:
            path_params['portfolio_transaction_id'] = params['portfolio_transaction_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/portfolio_transaction/{portfolio_transaction_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificPortfolioTransactionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_portfolio_transactions(self, **kwargs):  # noqa: E501
        """List all portfolio transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_portfolio_transactions(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetPortfolioTransactionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_portfolio_transactions_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_portfolio_transactions_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_portfolio_transactions_with_http_info(self, **kwargs):  # noqa: E501
        """List all portfolio transactions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_portfolio_transactions_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetPortfolioTransactionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_portfolio_transactions" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_portfolio_transactions`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_portfolio_transactions`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/portfolio_transaction', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetPortfolioTransactionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_portfolios(self, **kwargs):  # noqa: E501
        """List all portfolios  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_portfolios(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetPortfolioResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_portfolios_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_portfolios_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_portfolios_with_http_info(self, **kwargs):  # noqa: E501
        """List all portfolios  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_portfolios_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetPortfolioResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_portfolios" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_portfolios`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_portfolios`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/portfolio', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetPortfolioResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_questionnaire(self, questionnaire_id, **kwargs):  # noqa: E501
        """Retrieve a questionnaire  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_questionnaire(questionnaire_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str questionnaire_id: UUID of a questionnaire (required)
        :return: SpecificQuestionnaireResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_questionnaire_with_http_info(questionnaire_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_questionnaire_with_http_info(questionnaire_id, **kwargs)  # noqa: E501
            return data

    def get_questionnaire_with_http_info(self, questionnaire_id, **kwargs):  # noqa: E501
        """Retrieve a questionnaire  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_questionnaire_with_http_info(questionnaire_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str questionnaire_id: UUID of a questionnaire (required)
        :return: SpecificQuestionnaireResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['questionnaire_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_questionnaire" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'questionnaire_id' is set
        if ('questionnaire_id' not in params or
                params['questionnaire_id'] is None):
            raise ValueError("Missing the required parameter `questionnaire_id` when calling `get_questionnaire`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'questionnaire_id' in params:
            path_params['questionnaire_id'] = params['questionnaire_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/questionnaire/{questionnaire_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificQuestionnaireResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_questionnaires(self, **kwargs):  # noqa: E501
        """List all questionnaires  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_questionnaires(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetQuestionnaireResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_questionnaires_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_questionnaires_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_questionnaires_with_http_info(self, **kwargs):  # noqa: E501
        """List all questionnaires  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_questionnaires_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetQuestionnaireResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_questionnaires" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_questionnaires`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_questionnaires`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/questionnaire', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetQuestionnaireResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_score(self, score_id, **kwargs):  # noqa: E501
        """Retrieve a score  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_score(score_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str score_id: UUID of a score record (required)
        :return: SpecificScoreResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_score_with_http_info(score_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_score_with_http_info(score_id, **kwargs)  # noqa: E501
            return data

    def get_score_with_http_info(self, score_id, **kwargs):  # noqa: E501
        """Retrieve a score  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_score_with_http_info(score_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str score_id: UUID of a score record (required)
        :return: SpecificScoreResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['score_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_score" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'score_id' is set
        if ('score_id' not in params or
                params['score_id'] is None):
            raise ValueError("Missing the required parameter `score_id` when calling `get_score`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'score_id' in params:
            path_params['score_id'] = params['score_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/score/{score_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificScoreResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_scores(self, **kwargs):  # noqa: E501
        """List all scores  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_scores(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetScoreResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_scores_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_scores_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_scores_with_http_info(self, **kwargs):  # noqa: E501
        """List all scores  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_scores_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetScoreResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_scores" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_scores`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_scores`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/score', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetScoreResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_securities(self, **kwargs):  # noqa: E501
        """List all securities  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_securities(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetSecurityResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_securities_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_securities_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_securities_with_http_info(self, **kwargs):  # noqa: E501
        """List all securities  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_securities_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetSecurityResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_securities" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_securities`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_securities`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/security', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetSecurityResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_security(self, security_id, **kwargs):  # noqa: E501
        """Retrieve a security  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_security(security_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str security_id: UUID of a security (required)
        :return: SpecificSecurityResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_security_with_http_info(security_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_security_with_http_info(security_id, **kwargs)  # noqa: E501
            return data

    def get_security_with_http_info(self, security_id, **kwargs):  # noqa: E501
        """Retrieve a security  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_security_with_http_info(security_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str security_id: UUID of a security (required)
        :return: SpecificSecurityResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['security_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_security" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'security_id' is set
        if ('security_id' not in params or
                params['security_id'] is None):
            raise ValueError("Missing the required parameter `security_id` when calling `get_security`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'security_id' in params:
            path_params['security_id'] = params['security_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/security/{security_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificSecurityResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_security_exclusion(self, security_exclusion_id, **kwargs):  # noqa: E501
        """Retrieve a security exclusion  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_security_exclusion(security_exclusion_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str security_exclusion_id: UUID of a security exclusion record (required)
        :return: SpecificSecurityExclusionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_security_exclusion_with_http_info(security_exclusion_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_security_exclusion_with_http_info(security_exclusion_id, **kwargs)  # noqa: E501
            return data

    def get_security_exclusion_with_http_info(self, security_exclusion_id, **kwargs):  # noqa: E501
        """Retrieve a security exclusion  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_security_exclusion_with_http_info(security_exclusion_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str security_exclusion_id: UUID of a security exclusion record (required)
        :return: SpecificSecurityExclusionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['security_exclusion_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_security_exclusion" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'security_exclusion_id' is set
        if ('security_exclusion_id' not in params or
                params['security_exclusion_id'] is None):
            raise ValueError("Missing the required parameter `security_exclusion_id` when calling `get_security_exclusion`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'security_exclusion_id' in params:
            path_params['security_exclusion_id'] = params['security_exclusion_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/security_exclusion/{security_exclusion_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificSecurityExclusionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_security_exclusions(self, **kwargs):  # noqa: E501
        """List all security exclusions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_security_exclusions(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetSecurityExclusionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_security_exclusions_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_security_exclusions_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_security_exclusions_with_http_info(self, **kwargs):  # noqa: E501
        """List all security exclusions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_security_exclusions_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetSecurityExclusionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_security_exclusions" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_security_exclusions`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_security_exclusions`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/security_exclusion', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetSecurityExclusionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_security_performance(self, security_id, stat, **kwargs):  # noqa: E501
        """Get security performance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_security_performance(security_id, stat, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str security_id: UUID of a security (required)
        :param str stat: Performance statistic (required)
        :return: PerformanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_security_performance_with_http_info(security_id, stat, **kwargs)  # noqa: E501
        else:
            (data) = self.get_security_performance_with_http_info(security_id, stat, **kwargs)  # noqa: E501
            return data

    def get_security_performance_with_http_info(self, security_id, stat, **kwargs):  # noqa: E501
        """Get security performance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_security_performance_with_http_info(security_id, stat, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str security_id: UUID of a security (required)
        :param str stat: Performance statistic (required)
        :return: PerformanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['security_id', 'stat']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_security_performance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'security_id' is set
        if ('security_id' not in params or
                params['security_id'] is None):
            raise ValueError("Missing the required parameter `security_id` when calling `get_security_performance`")  # noqa: E501
        # verify the required parameter 'stat' is set
        if ('stat' not in params or
                params['stat'] is None):
            raise ValueError("Missing the required parameter `stat` when calling `get_security_performance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'security_id' in params:
            path_params['security_id'] = params['security_id']  # noqa: E501

        query_params = []
        if 'stat' in params:
            query_params.append(('stat', params['stat']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/security/{security_id}/performance', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PerformanceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_security_price(self, security_price_id, **kwargs):  # noqa: E501
        """Retrieve a security price  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_security_price(security_price_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str security_price_id: UUID of a security price record (required)
        :return: SpecificSecurityPriceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_security_price_with_http_info(security_price_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_security_price_with_http_info(security_price_id, **kwargs)  # noqa: E501
            return data

    def get_security_price_with_http_info(self, security_price_id, **kwargs):  # noqa: E501
        """Retrieve a security price  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_security_price_with_http_info(security_price_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str security_price_id: UUID of a security price record (required)
        :return: SpecificSecurityPriceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['security_price_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_security_price" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'security_price_id' is set
        if ('security_price_id' not in params or
                params['security_price_id'] is None):
            raise ValueError("Missing the required parameter `security_price_id` when calling `get_security_price`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'security_price_id' in params:
            path_params['security_price_id'] = params['security_price_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/security_price/{security_price_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificSecurityPriceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_security_prices(self, **kwargs):  # noqa: E501
        """List all security prices  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_security_prices(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetSecurityPriceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_security_prices_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_security_prices_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_security_prices_with_http_info(self, **kwargs):  # noqa: E501
        """List all security prices  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_security_prices_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetSecurityPriceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_security_prices" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_security_prices`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_security_prices`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/security_price', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetSecurityPriceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_transaction_code(self, transaction_code_id, **kwargs):  # noqa: E501
        """Retrieve a transaction code  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transaction_code(transaction_code_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transaction_code_id: UUID of a transaction code (required)
        :return: SpecificTransactionCodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_transaction_code_with_http_info(transaction_code_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_transaction_code_with_http_info(transaction_code_id, **kwargs)  # noqa: E501
            return data

    def get_transaction_code_with_http_info(self, transaction_code_id, **kwargs):  # noqa: E501
        """Retrieve a transaction code  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transaction_code_with_http_info(transaction_code_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transaction_code_id: UUID of a transaction code (required)
        :return: SpecificTransactionCodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transaction_code_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_transaction_code" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transaction_code_id' is set
        if ('transaction_code_id' not in params or
                params['transaction_code_id'] is None):
            raise ValueError("Missing the required parameter `transaction_code_id` when calling `get_transaction_code`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transaction_code_id' in params:
            path_params['transaction_code_id'] = params['transaction_code_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/transaction_code/{transaction_code_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificTransactionCodeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_transaction_codes(self, **kwargs):  # noqa: E501
        """List all transaction codes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transaction_codes(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetTransactionCodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_transaction_codes_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_transaction_codes_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_transaction_codes_with_http_info(self, **kwargs):  # noqa: E501
        """List all transaction codes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transaction_codes_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetTransactionCodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_transaction_codes" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_transaction_codes`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_transaction_codes`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/transaction_code', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetTransactionCodeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_transfer_request(self, transfer_id, **kwargs):  # noqa: E501
        """Retrieve a transfer request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transfer_request(transfer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transfer_id: UUID of an account transfer record (required)
        :return: SpecificTransferResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_transfer_request_with_http_info(transfer_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_transfer_request_with_http_info(transfer_id, **kwargs)  # noqa: E501
            return data

    def get_transfer_request_with_http_info(self, transfer_id, **kwargs):  # noqa: E501
        """Retrieve a transfer request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transfer_request_with_http_info(transfer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transfer_id: UUID of an account transfer record (required)
        :return: SpecificTransferResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transfer_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_transfer_request" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transfer_id' is set
        if ('transfer_id' not in params or
                params['transfer_id'] is None):
            raise ValueError("Missing the required parameter `transfer_id` when calling `get_transfer_request`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transfer_id' in params:
            path_params['transfer_id'] = params['transfer_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/transfer/{transfer_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificTransferResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_transfer_requests(self, **kwargs):  # noqa: E501
        """List all transfer requests  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transfer_requests(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetTransferResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_transfer_requests_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_transfer_requests_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_transfer_requests_with_http_info(self, **kwargs):  # noqa: E501
        """List all transfer requests  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_transfer_requests_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetTransferResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_transfer_requests" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_transfer_requests`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_transfer_requests`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/transfer', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetTransferResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_withdrawal_request(self, withdrawal_id, **kwargs):  # noqa: E501
        """Retrieve a withdrawal request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_withdrawal_request(withdrawal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str withdrawal_id: UUID of a withdrawal request (required)
        :return: SpecificWithdrawalResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_withdrawal_request_with_http_info(withdrawal_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_withdrawal_request_with_http_info(withdrawal_id, **kwargs)  # noqa: E501
            return data

    def get_withdrawal_request_with_http_info(self, withdrawal_id, **kwargs):  # noqa: E501
        """Retrieve a withdrawal request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_withdrawal_request_with_http_info(withdrawal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str withdrawal_id: UUID of a withdrawal request (required)
        :return: SpecificWithdrawalResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['withdrawal_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_withdrawal_request" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'withdrawal_id' is set
        if ('withdrawal_id' not in params or
                params['withdrawal_id'] is None):
            raise ValueError("Missing the required parameter `withdrawal_id` when calling `get_withdrawal_request`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'withdrawal_id' in params:
            path_params['withdrawal_id'] = params['withdrawal_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/withdrawal/{withdrawal_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificWithdrawalResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_withdrawal_requests(self, **kwargs):  # noqa: E501
        """List all withdrawal requests  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_withdrawal_requests(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetWithdrawalResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_withdrawal_requests_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_withdrawal_requests_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_withdrawal_requests_with_http_info(self, **kwargs):  # noqa: E501
        """List all withdrawal requests  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_withdrawal_requests_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number for the page that should be returned as the starting page. For example, if this is specified as 0, then the first page of the results will be the shown, if it is set as 3 then the third page of the results will be shown, and so on. The default is 0
        :param int size: The number or records to be included per page. The default is 25. There is no max value.
        :param str order_by: The field in the response body to order the list by. Default is update_date.
        :param bool ascending: If true, order the results in ascending order. For an alphabetical result this would be A-Z. If false, order the results in descending order. For an alphabetical result this would be Z-A. Default is false which would order by descending.
        :param str filter: Every field within an object using the GET method can be filtered except for fields stored under metadata. Filtering is especially useful for calls that return many different fields.
        :return: GetWithdrawalResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'size', 'order_by', 'ascending', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_withdrawal_requests" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_withdrawal_requests`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'size' in params and params['size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `size` when calling `get_withdrawal_requests`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'ascending' in params:
            query_params.append(('ascending', params['ascending']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/withdrawal', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetWithdrawalResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_account(self, payload, **kwargs):  # noqa: E501
        """Create an account under a client  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_account(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AccountCreatePayload payload: (required)
        :return: CreateAccountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_account_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_account_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_account_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create an account under a client  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_account_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AccountCreatePayload payload: (required)
        :return: CreateAccountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateAccountResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_account_allocation(self, payload, **kwargs):  # noqa: E501
        """Create an account allocation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_account_allocation(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AccountAllocationPayload payload: (required)
        :return: SpecificAccountAllocationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_account_allocation_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_account_allocation_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_account_allocation_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create an account allocation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_account_allocation_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AccountAllocationPayload payload: (required)
        :return: SpecificAccountAllocationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_account_allocation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_account_allocation`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account_allocation', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificAccountAllocationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_account_bulk_order(self, account_id, payload, **kwargs):  # noqa: E501
        """Bulk orders for an account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_account_bulk_order(account_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :param BulkOrderAccountPayload payload: (required)
        :return: BulkOrderFirmclientaccountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_account_bulk_order_with_http_info(account_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_account_bulk_order_with_http_info(account_id, payload, **kwargs)  # noqa: E501
            return data

    def post_account_bulk_order_with_http_info(self, account_id, payload, **kwargs):  # noqa: E501
        """Bulk orders for an account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_account_bulk_order_with_http_info(account_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :param BulkOrderAccountPayload payload: (required)
        :return: BulkOrderFirmclientaccountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_account_bulk_order" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `post_account_bulk_order`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_account_bulk_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account/{account_id}/order_bulk', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BulkOrderFirmclientaccountResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_account_rebalance_buy_only_order(self, account_id, payload, **kwargs):  # noqa: E501
        """Create buy-only account rebalance orders  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_account_rebalance_buy_only_order(account_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :param AccountRebalanceBuyOnlyOrderPayload payload: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_account_rebalance_buy_only_order_with_http_info(account_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_account_rebalance_buy_only_order_with_http_info(account_id, payload, **kwargs)  # noqa: E501
            return data

    def post_account_rebalance_buy_only_order_with_http_info(self, account_id, payload, **kwargs):  # noqa: E501
        """Create buy-only account rebalance orders  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_account_rebalance_buy_only_order_with_http_info(account_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :param AccountRebalanceBuyOnlyOrderPayload payload: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_account_rebalance_buy_only_order" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `post_account_rebalance_buy_only_order`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_account_rebalance_buy_only_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account/{account_id}/order_buy_only', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_account_rebalance_order(self, account_id, payload, **kwargs):  # noqa: E501
        """Create account rebalance orders  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_account_rebalance_order(account_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :param AccountRebalanceOrderPayload payload: (required)
        :return: SpecificOrderTrackResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_account_rebalance_order_with_http_info(account_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_account_rebalance_order_with_http_info(account_id, payload, **kwargs)  # noqa: E501
            return data

    def post_account_rebalance_order_with_http_info(self, account_id, payload, **kwargs):  # noqa: E501
        """Create account rebalance orders  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_account_rebalance_order_with_http_info(account_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :param AccountRebalanceOrderPayload payload: (required)
        :return: SpecificOrderTrackResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_account_rebalance_order" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `post_account_rebalance_order`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_account_rebalance_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account/{account_id}/order_rebalance', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificOrderTrackResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_account_rebalance_sell_only_order(self, account_id, payload, **kwargs):  # noqa: E501
        """Create sell-only account rebalance orders  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_account_rebalance_sell_only_order(account_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :param AccountRebalanceSellOnlyOrderPayload payload: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_account_rebalance_sell_only_order_with_http_info(account_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_account_rebalance_sell_only_order_with_http_info(account_id, payload, **kwargs)  # noqa: E501
            return data

    def post_account_rebalance_sell_only_order_with_http_info(self, account_id, payload, **kwargs):  # noqa: E501
        """Create sell-only account rebalance orders  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_account_rebalance_sell_only_order_with_http_info(account_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :param AccountRebalanceSellOnlyOrderPayload payload: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_account_rebalance_sell_only_order" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `post_account_rebalance_sell_only_order`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_account_rebalance_sell_only_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account/{account_id}/order_sell_only', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_account_sell_all_order(self, account_id, payload, **kwargs):  # noqa: E501
        """Sell all account order  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_account_sell_all_order(account_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :param SellAllAccountPayload payload: (required)
        :return: SellAllAccountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_account_sell_all_order_with_http_info(account_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_account_sell_all_order_with_http_info(account_id, payload, **kwargs)  # noqa: E501
            return data

    def post_account_sell_all_order_with_http_info(self, account_id, payload, **kwargs):  # noqa: E501
        """Sell all account order  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_account_sell_all_order_with_http_info(account_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :param SellAllAccountPayload payload: (required)
        :return: SellAllAccountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_account_sell_all_order" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `post_account_sell_all_order`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_account_sell_all_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account/{account_id}/order_sell_all', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SellAllAccountResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_account_stage(self, payload, **kwargs):  # noqa: E501
        """Create an account stage  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_account_stage(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AccountStagePayload payload: (required)
        :return: SpecificAccountStageResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_account_stage_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_account_stage_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_account_stage_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create an account stage  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_account_stage_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AccountStagePayload payload: (required)
        :return: SpecificAccountStageResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_account_stage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_account_stage`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/stage', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificAccountStageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_account_status(self, payload, **kwargs):  # noqa: E501
        """Create an account status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_account_status(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AccountStatusPayload payload: (required)
        :return: CreateAccountStatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_account_status_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_account_status_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_account_status_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create an account status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_account_status_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AccountStatusPayload payload: (required)
        :return: CreateAccountStatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_account_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_account_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account_status', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateAccountStatusResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_account_type(self, payload, **kwargs):  # noqa: E501
        """Create an account type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_account_type(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AccountTypePayload payload: (required)
        :return: GetAccountTypeSubresponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_account_type_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_account_type_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_account_type_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create an account type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_account_type_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AccountTypePayload payload: (required)
        :return: GetAccountTypeSubresponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_account_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_account_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account_type', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAccountTypeSubresponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_aggregation_account(self, payload, **kwargs):  # noqa: E501
        """Create an aggregation account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_aggregation_account(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AggregationAccountPayload payload: (required)
        :return: CreateAggregationAccountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_aggregation_account_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_aggregation_account_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_aggregation_account_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create an aggregation account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_aggregation_account_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AggregationAccountPayload payload: (required)
        :return: CreateAggregationAccountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_aggregation_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_aggregation_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/aggregation_account', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateAggregationAccountResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_aggregation_account_balance(self, payload, **kwargs):  # noqa: E501
        """Create an aggregation account balance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_aggregation_account_balance(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AggregationAccountBalancePayload payload: (required)
        :return: CreateAggregationAccountBalanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_aggregation_account_balance_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_aggregation_account_balance_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_aggregation_account_balance_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create an aggregation account balance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_aggregation_account_balance_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AggregationAccountBalancePayload payload: (required)
        :return: CreateAggregationAccountBalanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_aggregation_account_balance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_aggregation_account_balance`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/aggregation_account_balance', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateAggregationAccountBalanceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_aggregation_account_holding(self, payload, **kwargs):  # noqa: E501
        """Create an aggregation account holding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_aggregation_account_holding(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AggregationAccountHoldingPayload payload: (required)
        :return: CreateAggregationAccountHoldingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_aggregation_account_holding_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_aggregation_account_holding_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_aggregation_account_holding_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create an aggregation account holding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_aggregation_account_holding_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AggregationAccountHoldingPayload payload: (required)
        :return: CreateAggregationAccountHoldingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_aggregation_account_holding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_aggregation_account_holding`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/aggregation_account_holding', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateAggregationAccountHoldingResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_aggregation_account_transaction(self, payload, **kwargs):  # noqa: E501
        """Create an aggregation account transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_aggregation_account_transaction(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AggregationAccountTransactionPayload payload: (required)
        :return: CreateAggregationAccountTransactionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_aggregation_account_transaction_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_aggregation_account_transaction_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_aggregation_account_transaction_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create an aggregation account transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_aggregation_account_transaction_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AggregationAccountTransactionPayload payload: (required)
        :return: CreateAggregationAccountTransactionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_aggregation_account_transaction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_aggregation_account_transaction`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/aggregation_account_transaction', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateAggregationAccountTransactionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_allocation(self, payload, **kwargs):  # noqa: E501
        """Create an allocation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_allocation(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AllocationPayload payload: (required)
        :return: CreateAllocationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_allocation_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_allocation_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_allocation_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create an allocation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_allocation_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AllocationPayload payload: (required)
        :return: CreateAllocationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_allocation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_allocation`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/allocation', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateAllocationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_allocation_composition(self, payload, **kwargs):  # noqa: E501
        """Create an allocation composition  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_allocation_composition(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AllocationCompositionPayload payload: (required)
        :return: CreateAllocationCompositionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_allocation_composition_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_allocation_composition_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_allocation_composition_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create an allocation composition  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_allocation_composition_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AllocationCompositionPayload payload: (required)
        :return: CreateAllocationCompositionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_allocation_composition" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_allocation_composition`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/allocation_composition', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateAllocationCompositionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_bank_link(self, payload, **kwargs):  # noqa: E501
        """Create a bank link  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_bank_link(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BankLinkPayload payload: (required)
        :return: CreateBankLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_bank_link_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_bank_link_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_bank_link_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a bank link  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_bank_link_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BankLinkPayload payload: (required)
        :return: CreateBankLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_bank_link" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_bank_link`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/bank_link', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateBankLinkResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_benchmark(self, payload, **kwargs):  # noqa: E501
        """Create a benchmark  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_benchmark(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BenchmarkPayload payload: (required)
        :return: CreateBenchmarkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_benchmark_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_benchmark_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_benchmark_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a benchmark  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_benchmark_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BenchmarkPayload payload: (required)
        :return: CreateBenchmarkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_benchmark" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_benchmark`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/benchmark', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateBenchmarkResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_budget(self, payload, **kwargs):  # noqa: E501
        """Create a budget  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_budget(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BudgetPayload payload: (required)
        :return: CreateBudgetResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_budget_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_budget_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_budget_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a budget  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_budget_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BudgetPayload payload: (required)
        :return: CreateBudgetResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_budget" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_budget`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/budget', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateBudgetResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_bulk_order(self, payload, **kwargs):  # noqa: E501
        """Bulk orders for your firm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_bulk_order(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BulkOrderFirmPayload payload: (required)
        :return: BulkOrderFirmclientaccountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_bulk_order_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_bulk_order_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_bulk_order_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Bulk orders for your firm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_bulk_order_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BulkOrderFirmPayload payload: (required)
        :return: BulkOrderFirmclientaccountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_bulk_order" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_bulk_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/order_bulk', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BulkOrderFirmclientaccountResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_client(self, payload, **kwargs):  # noqa: E501
        """Create a client  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_client(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClientPayload payload: (required)
        :return: CreateClientResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_client_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_client_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_client_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a client  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_client_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClientPayload payload: (required)
        :return: CreateClientResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_client" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_client`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/client', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateClientResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_client_bulk_order(self, client_id, payload, **kwargs):  # noqa: E501
        """Bulk orders for a client  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_client_bulk_order(client_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: UUID of a client (required)
        :param BulkOrderClientPayload payload: (required)
        :return: BulkOrderFirmclientaccountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_client_bulk_order_with_http_info(client_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_client_bulk_order_with_http_info(client_id, payload, **kwargs)  # noqa: E501
            return data

    def post_client_bulk_order_with_http_info(self, client_id, payload, **kwargs):  # noqa: E501
        """Bulk orders for a client  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_client_bulk_order_with_http_info(client_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: UUID of a client (required)
        :param BulkOrderClientPayload payload: (required)
        :return: BulkOrderFirmclientaccountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_client_bulk_order" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params or
                params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `post_client_bulk_order`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_client_bulk_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'client_id' in params:
            path_params['client_id'] = params['client_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/client/{client_id}/order_bulk', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BulkOrderFirmclientaccountResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_client_hydro(self, payload, **kwargs):  # noqa: E501
        """Create a client-hydro relationship  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_client_hydro(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClientHydroPayload payload: (required)
        :return: CreateClientHydroResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_client_hydro_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_client_hydro_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_client_hydro_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a client-hydro relationship  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_client_hydro_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClientHydroPayload payload: (required)
        :return: CreateClientHydroResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_client_hydro" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_client_hydro`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/client_hydro', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateClientHydroResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_client_response(self, payload, **kwargs):  # noqa: E501
        """Create a client response  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_client_response(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClientResponsePayload payload: (required)
        :return: CreateClientResponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_client_response_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_client_response_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_client_response_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a client response  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_client_response_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClientResponsePayload payload: (required)
        :return: CreateClientResponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_client_response" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_client_response`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/client_response', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateClientResponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_decision_tree(self, payload, **kwargs):  # noqa: E501
        """Create a decision tree  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_decision_tree(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DecisionTreePayload payload: (required)
        :return: CreateDecisionTreeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_decision_tree_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_decision_tree_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_decision_tree_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a decision tree  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_decision_tree_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DecisionTreePayload payload: (required)
        :return: CreateDecisionTreeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_decision_tree" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_decision_tree`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/decision_tree', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateDecisionTreeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_deposit_request(self, payload, **kwargs):  # noqa: E501
        """Create a deposit request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_deposit_request(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DepositRequestPayload payload: (required)
        :return: CreateDepositRequestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_deposit_request_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_deposit_request_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_deposit_request_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a deposit request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_deposit_request_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DepositRequestPayload payload: (required)
        :return: CreateDepositRequestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_deposit_request" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_deposit_request`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/deposit', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateDepositRequestResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_financial_offer(self, payload, **kwargs):  # noqa: E501
        """Create a financial offer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_financial_offer(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FinancialOfferPayload payload: (required)
        :return: CreateFinancialOfferResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_financial_offer_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_financial_offer_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_financial_offer_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a financial offer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_financial_offer_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FinancialOfferPayload payload: (required)
        :return: CreateFinancialOfferResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_financial_offer" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_financial_offer`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/financial_offer', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateFinancialOfferResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_funding_request(self, payload, **kwargs):  # noqa: E501
        """Create a funding request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_funding_request(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FundingRequestPayload payload: (required)
        :return: CreateFundingRequestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_funding_request_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_funding_request_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_funding_request_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a funding request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_funding_request_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FundingRequestPayload payload: (required)
        :return: CreateFundingRequestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_funding_request" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_funding_request`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/funding', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateFundingRequestResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_goal(self, payload, **kwargs):  # noqa: E501
        """Create a goal  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_goal(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GoalPayload payload: (required)
        :return: CreateGoalResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_goal_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_goal_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_goal_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a goal  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_goal_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GoalPayload payload: (required)
        :return: CreateGoalResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_goal" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_goal`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/goal', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateGoalResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_goal_track_record(self, payload, **kwargs):  # noqa: E501
        """Create a goal track record  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_goal_track_record(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GoalTrackPayload payload: (required)
        :return: CreateGoalTrackResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_goal_track_record_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_goal_track_record_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_goal_track_record_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a goal track record  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_goal_track_record_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GoalTrackPayload payload: (required)
        :return: CreateGoalTrackResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_goal_track_record" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_goal_track_record`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/goal_track', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateGoalTrackResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_model(self, payload, **kwargs):  # noqa: E501
        """Create a model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_model(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ModelPayload payload: (required)
        :return: CreateModelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_model_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_model_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_model_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_model_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ModelPayload payload: (required)
        :return: CreateModelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_model" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_model`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/model', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateModelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_model_asset_size(self, payload, **kwargs):  # noqa: E501
        """Create a model asset size  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_model_asset_size(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ModelAssetSizePayload payload: (required)
        :return: CreateModelAssetSizeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_model_asset_size_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_model_asset_size_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_model_asset_size_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a model asset size  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_model_asset_size_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ModelAssetSizePayload payload: (required)
        :return: CreateModelAssetSizeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_model_asset_size" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_model_asset_size`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/model_asset_size', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateModelAssetSizeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_model_comment(self, payload, **kwargs):  # noqa: E501
        """Create a model commentary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_model_comment(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ModelCommentPayload payload: (required)
        :return: CreateModelCommentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_model_comment_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_model_comment_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_model_comment_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a model commentary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_model_comment_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ModelCommentPayload payload: (required)
        :return: CreateModelCommentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_model_comment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_model_comment`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/model_comment', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateModelCommentResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_model_holding(self, payload, **kwargs):  # noqa: E501
        """Create a model holding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_model_holding(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ModelHoldingPayload payload: (required)
        :return: CreateModelHoldingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_model_holding_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_model_holding_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_model_holding_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a model holding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_model_holding_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ModelHoldingPayload payload: (required)
        :return: CreateModelHoldingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_model_holding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_model_holding`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/model_holding', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateModelHoldingResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_model_transaction(self, payload, **kwargs):  # noqa: E501
        """Create a model transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_model_transaction(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ModelTransactionPayload payload: (required)
        :return: CreateModelTransactionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_model_transaction_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_model_transaction_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_model_transaction_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a model transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_model_transaction_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ModelTransactionPayload payload: (required)
        :return: CreateModelTransactionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_model_transaction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_model_transaction`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/model_transaction', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateModelTransactionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_node(self, payload, **kwargs):  # noqa: E501
        """Create a node  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_node(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NodePayload payload: (required)
        :return: CreateNodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_node_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_node_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_node_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a node  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_node_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NodePayload payload: (required)
        :return: CreateNodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_node`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/node', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateNodeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_node_relationship(self, payload, **kwargs):  # noqa: E501
        """Create a node relationship  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_node_relationship(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NodeRelationshipPayload payload: (required)
        :return: CreateNodeRelationshipResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_node_relationship_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_node_relationship_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_node_relationship_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a node relationship  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_node_relationship_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NodeRelationshipPayload payload: (required)
        :return: CreateNodeRelationshipResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_node_relationship" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_node_relationship`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/node_relationship', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateNodeRelationshipResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_order_record(self, payload, **kwargs):  # noqa: E501
        """Create an order record  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_order_record(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param OrderPayload payload: (required)
        :return: CreateOrderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_order_record_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_order_record_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_order_record_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create an order record  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_order_record_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param OrderPayload payload: (required)
        :return: CreateOrderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_order_record" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_order_record`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/order', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateOrderResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_order_status(self, payload, **kwargs):  # noqa: E501
        """Create an order status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_order_status(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param OrderStatusPayload payload: (required)
        :return: CreateOrderStatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_order_status_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_order_status_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_order_status_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create an order status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_order_status_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param OrderStatusPayload payload: (required)
        :return: CreateOrderStatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_order_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_order_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/order_status', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateOrderStatusResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_order_tracking_record(self, payload, **kwargs):  # noqa: E501
        """Create an order tracking record  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_order_tracking_record(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param OrderTrackPayload payload: (required)
        :return: CreateOrderTrackResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_order_tracking_record_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_order_tracking_record_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_order_tracking_record_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create an order tracking record  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_order_tracking_record_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param OrderTrackPayload payload: (required)
        :return: CreateOrderTrackResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_order_tracking_record" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_order_tracking_record`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/order_track', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateOrderTrackResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_portfolio(self, payload, **kwargs):  # noqa: E501
        """Create a portfolio  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_portfolio(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PortfolioPayload payload: (required)
        :return: CreatePortfolioResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_portfolio_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_portfolio_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_portfolio_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a portfolio  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_portfolio_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PortfolioPayload payload: (required)
        :return: CreatePortfolioResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_portfolio" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_portfolio`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/portfolio', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreatePortfolioResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_portfolio_asset_size(self, payload, **kwargs):  # noqa: E501
        """Create a portfolio asset size  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_portfolio_asset_size(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PortfolioAssetSizePayload payload: (required)
        :return: CreatePortfolioAssetSizeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_portfolio_asset_size_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_portfolio_asset_size_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_portfolio_asset_size_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a portfolio asset size  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_portfolio_asset_size_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PortfolioAssetSizePayload payload: (required)
        :return: CreatePortfolioAssetSizeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_portfolio_asset_size" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_portfolio_asset_size`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/portfolio_asset_size', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreatePortfolioAssetSizeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_portfolio_comment(self, payload, **kwargs):  # noqa: E501
        """Create a portfolio commentary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_portfolio_comment(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PortfolioCommentPayload payload: (required)
        :return: CreatePortfolioCommentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_portfolio_comment_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_portfolio_comment_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_portfolio_comment_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a portfolio commentary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_portfolio_comment_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PortfolioCommentPayload payload: (required)
        :return: CreatePortfolioCommentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_portfolio_comment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_portfolio_comment`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/portfolio_comment', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreatePortfolioCommentResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_portfolio_holding(self, payload, **kwargs):  # noqa: E501
        """Create a portfolio holding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_portfolio_holding(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PortfolioHoldingPayload payload: (required)
        :return: CreatePortfolioHoldingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_portfolio_holding_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_portfolio_holding_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_portfolio_holding_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a portfolio holding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_portfolio_holding_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PortfolioHoldingPayload payload: (required)
        :return: CreatePortfolioHoldingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_portfolio_holding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_portfolio_holding`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/portfolio_holding', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreatePortfolioHoldingResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_portfolio_rebalance_buy_only_order(self, portfolio_id, payload, **kwargs):  # noqa: E501
        """Create buy-only portfolio rebalance orders  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_portfolio_rebalance_buy_only_order(portfolio_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_id: UUID of a portfolio (required)
        :param PortfolioRebalanceBuyOnlyOrderPayload payload: (required)
        :return: PortfolioRebalanceBuyOnlyOrderPayload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_portfolio_rebalance_buy_only_order_with_http_info(portfolio_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_portfolio_rebalance_buy_only_order_with_http_info(portfolio_id, payload, **kwargs)  # noqa: E501
            return data

    def post_portfolio_rebalance_buy_only_order_with_http_info(self, portfolio_id, payload, **kwargs):  # noqa: E501
        """Create buy-only portfolio rebalance orders  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_portfolio_rebalance_buy_only_order_with_http_info(portfolio_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_id: UUID of a portfolio (required)
        :param PortfolioRebalanceBuyOnlyOrderPayload payload: (required)
        :return: PortfolioRebalanceBuyOnlyOrderPayload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portfolio_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_portfolio_rebalance_buy_only_order" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portfolio_id' is set
        if ('portfolio_id' not in params or
                params['portfolio_id'] is None):
            raise ValueError("Missing the required parameter `portfolio_id` when calling `post_portfolio_rebalance_buy_only_order`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_portfolio_rebalance_buy_only_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portfolio_id' in params:
            path_params['portfolio_id'] = params['portfolio_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/portfolio/{portfolio_id}/order_buy_only', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PortfolioRebalanceBuyOnlyOrderPayload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_portfolio_rebalance_order(self, portfolio_id, payload, **kwargs):  # noqa: E501
        """Create portfolio rebalance orders  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_portfolio_rebalance_order(portfolio_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_id: UUID of a portfolio (required)
        :param PortfolioRebalanceOrderPayload payload: (required)
        :return: PortfolioRebalanceOrderPayload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_portfolio_rebalance_order_with_http_info(portfolio_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_portfolio_rebalance_order_with_http_info(portfolio_id, payload, **kwargs)  # noqa: E501
            return data

    def post_portfolio_rebalance_order_with_http_info(self, portfolio_id, payload, **kwargs):  # noqa: E501
        """Create portfolio rebalance orders  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_portfolio_rebalance_order_with_http_info(portfolio_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_id: UUID of a portfolio (required)
        :param PortfolioRebalanceOrderPayload payload: (required)
        :return: PortfolioRebalanceOrderPayload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portfolio_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_portfolio_rebalance_order" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portfolio_id' is set
        if ('portfolio_id' not in params or
                params['portfolio_id'] is None):
            raise ValueError("Missing the required parameter `portfolio_id` when calling `post_portfolio_rebalance_order`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_portfolio_rebalance_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portfolio_id' in params:
            path_params['portfolio_id'] = params['portfolio_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/portfolio/{portfolio_id}/order_rebalance', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PortfolioRebalanceOrderPayload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_portfolio_rebalance_sell_only_order(self, portfolio_id, payload, **kwargs):  # noqa: E501
        """Create sell-only portfolio rebalance orders  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_portfolio_rebalance_sell_only_order(portfolio_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_id: UUID of a portfolio (required)
        :param PortfolioRebalanceSellOnlyOrderPayload payload: (required)
        :return: PortfolioRebalanceSellOnlyOrderPayload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_portfolio_rebalance_sell_only_order_with_http_info(portfolio_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_portfolio_rebalance_sell_only_order_with_http_info(portfolio_id, payload, **kwargs)  # noqa: E501
            return data

    def post_portfolio_rebalance_sell_only_order_with_http_info(self, portfolio_id, payload, **kwargs):  # noqa: E501
        """Create sell-only portfolio rebalance orders  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_portfolio_rebalance_sell_only_order_with_http_info(portfolio_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_id: UUID of a portfolio (required)
        :param PortfolioRebalanceSellOnlyOrderPayload payload: (required)
        :return: PortfolioRebalanceSellOnlyOrderPayload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portfolio_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_portfolio_rebalance_sell_only_order" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portfolio_id' is set
        if ('portfolio_id' not in params or
                params['portfolio_id'] is None):
            raise ValueError("Missing the required parameter `portfolio_id` when calling `post_portfolio_rebalance_sell_only_order`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_portfolio_rebalance_sell_only_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portfolio_id' in params:
            path_params['portfolio_id'] = params['portfolio_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/portfolio/{portfolio_id}/order_sell_only', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PortfolioRebalanceSellOnlyOrderPayload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_portfolio_sell_all_order(self, portfolio_id, payload, **kwargs):  # noqa: E501
        """Sell all portfolio order  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_portfolio_sell_all_order(portfolio_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_id: UUID of a portfolio (required)
        :param SellAllPortfolioPayload payload: (required)
        :return: SellAllPortfolioResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_portfolio_sell_all_order_with_http_info(portfolio_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_portfolio_sell_all_order_with_http_info(portfolio_id, payload, **kwargs)  # noqa: E501
            return data

    def post_portfolio_sell_all_order_with_http_info(self, portfolio_id, payload, **kwargs):  # noqa: E501
        """Sell all portfolio order  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_portfolio_sell_all_order_with_http_info(portfolio_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_id: UUID of a portfolio (required)
        :param SellAllPortfolioPayload payload: (required)
        :return: SellAllPortfolioResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portfolio_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_portfolio_sell_all_order" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portfolio_id' is set
        if ('portfolio_id' not in params or
                params['portfolio_id'] is None):
            raise ValueError("Missing the required parameter `portfolio_id` when calling `post_portfolio_sell_all_order`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_portfolio_sell_all_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portfolio_id' in params:
            path_params['portfolio_id'] = params['portfolio_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/portfolio/{portfolio_id}/order_sell_all', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SellAllPortfolioResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_portfolio_transaction(self, payload, **kwargs):  # noqa: E501
        """Create a portfolio transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_portfolio_transaction(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PortfolioTransactionPayload payload: (required)
        :return: CreatePortfolioTransactionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_portfolio_transaction_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_portfolio_transaction_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_portfolio_transaction_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a portfolio transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_portfolio_transaction_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PortfolioTransactionPayload payload: (required)
        :return: CreatePortfolioTransactionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_portfolio_transaction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_portfolio_transaction`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/portfolio_transaction', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreatePortfolioTransactionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_questionnaire(self, payload, **kwargs):  # noqa: E501
        """Create a questionnaire  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_questionnaire(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param QuestionnairePayload payload: (required)
        :return: CreateQuestionnaireResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_questionnaire_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_questionnaire_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_questionnaire_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a questionnaire  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_questionnaire_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param QuestionnairePayload payload: (required)
        :return: CreateQuestionnaireResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_questionnaire" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_questionnaire`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/questionnaire', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateQuestionnaireResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_score(self, payload, **kwargs):  # noqa: E501
        """Create a score  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_score(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ScorePayload payload: (required)
        :return: CreateScoreResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_score_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_score_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_score_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a score  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_score_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ScorePayload payload: (required)
        :return: CreateScoreResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_score" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_score`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/score', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateScoreResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_security(self, payload, **kwargs):  # noqa: E501
        """Create a security  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_security(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SecurityPayload payload: (required)
        :return: CreateSecurityResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_security_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_security_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_security_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a security  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_security_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SecurityPayload payload: (required)
        :return: CreateSecurityResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_security" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_security`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/security', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateSecurityResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_security_exclusion(self, payload, **kwargs):  # noqa: E501
        """Create a security exclusion  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_security_exclusion(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SecurityExclusionPayload payload: (required)
        :return: CreateSecurityExclusionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_security_exclusion_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_security_exclusion_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_security_exclusion_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a security exclusion  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_security_exclusion_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SecurityExclusionPayload payload: (required)
        :return: CreateSecurityExclusionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_security_exclusion" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_security_exclusion`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/security_exclusion', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateSecurityExclusionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_security_price(self, payload, **kwargs):  # noqa: E501
        """Create a security price  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_security_price(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SecurityPricePayload payload: (required)
        :return: CreateSecurityPriceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_security_price_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_security_price_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_security_price_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a security price  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_security_price_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SecurityPricePayload payload: (required)
        :return: CreateSecurityPriceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_security_price" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_security_price`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/security_price', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateSecurityPriceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_transaction_code(self, payload, **kwargs):  # noqa: E501
        """Create a transaction code  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_transaction_code(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TransactionCodePayload payload: (required)
        :return: CreateTransactionCodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_transaction_code_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_transaction_code_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_transaction_code_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a transaction code  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_transaction_code_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TransactionCodePayload payload: (required)
        :return: CreateTransactionCodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_transaction_code" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_transaction_code`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/transaction_code', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateTransactionCodeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_transfer_request(self, payload, **kwargs):  # noqa: E501
        """Create a transfer request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_transfer_request(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TransferRequestPayload payload: (required)
        :return: CreateTransferResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_transfer_request_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_transfer_request_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_transfer_request_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a transfer request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_transfer_request_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TransferRequestPayload payload: (required)
        :return: CreateTransferResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_transfer_request" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_transfer_request`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/transfer', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateTransferResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_withdrawal_request(self, payload, **kwargs):  # noqa: E501
        """Create a withdrawal request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_withdrawal_request(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WithdrawalPayload payload: (required)
        :return: CreateWithdrawalResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_withdrawal_request_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.post_withdrawal_request_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def post_withdrawal_request_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Create a withdrawal request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_withdrawal_request_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WithdrawalPayload payload: (required)
        :return: CreateWithdrawalResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_withdrawal_request" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `post_withdrawal_request`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/withdrawal', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateWithdrawalResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def subscribe_account(self, account_id, payload, **kwargs):  # noqa: E501
        """Subscribe an account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.subscribe_account(account_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :param AccountSubscribePayload payload: (required)
        :return: SubscribeAccountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.subscribe_account_with_http_info(account_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.subscribe_account_with_http_info(account_id, payload, **kwargs)  # noqa: E501
            return data

    def subscribe_account_with_http_info(self, account_id, payload, **kwargs):  # noqa: E501
        """Subscribe an account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.subscribe_account_with_http_info(account_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :param AccountSubscribePayload payload: (required)
        :return: SubscribeAccountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method subscribe_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `subscribe_account`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `subscribe_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account/{account_id}/subscribe', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SubscribeAccountResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_account(self, account_id, payload, **kwargs):  # noqa: E501
        """Update an account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_account(account_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :param AccountCreatePayload payload: (required)
        :return: SpecificAccountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_account_with_http_info(account_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_account_with_http_info(account_id, payload, **kwargs)  # noqa: E501
            return data

    def update_account_with_http_info(self, account_id, payload, **kwargs):  # noqa: E501
        """Update an account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_account_with_http_info(account_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :param AccountCreatePayload payload: (required)
        :return: SpecificAccountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `update_account`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account/{account_id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificAccountResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_account_allocation(self, account_allocation_id, payload, **kwargs):  # noqa: E501
        """Update an account allocation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_account_allocation(account_allocation_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_allocation_id: UUID of an account allocation (required)
        :param AccountAllocationPayload payload: (required)
        :return: SpecificAccountAllocationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_account_allocation_with_http_info(account_allocation_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_account_allocation_with_http_info(account_allocation_id, payload, **kwargs)  # noqa: E501
            return data

    def update_account_allocation_with_http_info(self, account_allocation_id, payload, **kwargs):  # noqa: E501
        """Update an account allocation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_account_allocation_with_http_info(account_allocation_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_allocation_id: UUID of an account allocation (required)
        :param AccountAllocationPayload payload: (required)
        :return: SpecificAccountAllocationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_allocation_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_account_allocation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_allocation_id' is set
        if ('account_allocation_id' not in params or
                params['account_allocation_id'] is None):
            raise ValueError("Missing the required parameter `account_allocation_id` when calling `update_account_allocation`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_account_allocation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_allocation_id' in params:
            path_params['account_allocation_id'] = params['account_allocation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account_allocation/{account_allocation_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificAccountAllocationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_account_permission(self, account_id, payload, **kwargs):  # noqa: E501
        """Update an account's permissions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_account_permission(account_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :param AccountPermissionPayload payload: (required)
        :return: SpecificAccountPermissionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_account_permission_with_http_info(account_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_account_permission_with_http_info(account_id, payload, **kwargs)  # noqa: E501
            return data

    def update_account_permission_with_http_info(self, account_id, payload, **kwargs):  # noqa: E501
        """Update an account's permissions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_account_permission_with_http_info(account_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: UUID of an account (required)
        :param AccountPermissionPayload payload: (required)
        :return: SpecificAccountPermissionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_account_permission" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `update_account_permission`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_account_permission`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account_permission/{account_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificAccountPermissionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_account_stage(self, stage_id, payload, **kwargs):  # noqa: E501
        """Update an account stage  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_account_stage(stage_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str stage_id: UUID of an account stage (required)
        :param AccountStagePayload payload: (required)
        :return: SpecificAccountStageResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_account_stage_with_http_info(stage_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_account_stage_with_http_info(stage_id, payload, **kwargs)  # noqa: E501
            return data

    def update_account_stage_with_http_info(self, stage_id, payload, **kwargs):  # noqa: E501
        """Update an account stage  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_account_stage_with_http_info(stage_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str stage_id: UUID of an account stage (required)
        :param AccountStagePayload payload: (required)
        :return: SpecificAccountStageResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['stage_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_account_stage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'stage_id' is set
        if ('stage_id' not in params or
                params['stage_id'] is None):
            raise ValueError("Missing the required parameter `stage_id` when calling `update_account_stage`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_account_stage`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'stage_id' in params:
            path_params['stage_id'] = params['stage_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/stage/{stage_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificAccountStageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_account_status(self, account_status_id, payload, **kwargs):  # noqa: E501
        """Update an account status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_account_status(account_status_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_status_id: UUID of an account status (required)
        :param AccountStatusPayload payload: (required)
        :return: SpecificAccountStatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_account_status_with_http_info(account_status_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_account_status_with_http_info(account_status_id, payload, **kwargs)  # noqa: E501
            return data

    def update_account_status_with_http_info(self, account_status_id, payload, **kwargs):  # noqa: E501
        """Update an account status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_account_status_with_http_info(account_status_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_status_id: UUID of an account status (required)
        :param AccountStatusPayload payload: (required)
        :return: SpecificAccountStatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_status_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_account_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_status_id' is set
        if ('account_status_id' not in params or
                params['account_status_id'] is None):
            raise ValueError("Missing the required parameter `account_status_id` when calling `update_account_status`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_account_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_status_id' in params:
            path_params['account_status_id'] = params['account_status_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account_status/{account_status_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificAccountStatusResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_account_type(self, account_type_id, payload, **kwargs):  # noqa: E501
        """Update an account type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_account_type(account_type_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_type_id: UUID of an account type (required)
        :param AccountTypePayload payload: (required)
        :return: GetAccountTypeSubresponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_account_type_with_http_info(account_type_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_account_type_with_http_info(account_type_id, payload, **kwargs)  # noqa: E501
            return data

    def update_account_type_with_http_info(self, account_type_id, payload, **kwargs):  # noqa: E501
        """Update an account type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_account_type_with_http_info(account_type_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_type_id: UUID of an account type (required)
        :param AccountTypePayload payload: (required)
        :return: GetAccountTypeSubresponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_type_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_account_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_type_id' is set
        if ('account_type_id' not in params or
                params['account_type_id'] is None):
            raise ValueError("Missing the required parameter `account_type_id` when calling `update_account_type`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_account_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_type_id' in params:
            path_params['account_type_id'] = params['account_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/account_type/{account_type_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAccountTypeSubresponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_aggregation_account(self, aggregation_account_id, payload, **kwargs):  # noqa: E501
        """Update an aggregation account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_aggregation_account(aggregation_account_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str aggregation_account_id: UUID of an aggregation account (required)
        :param AggregationAccountPayload payload: (required)
        :return: SpecificAggregationAccountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_aggregation_account_with_http_info(aggregation_account_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_aggregation_account_with_http_info(aggregation_account_id, payload, **kwargs)  # noqa: E501
            return data

    def update_aggregation_account_with_http_info(self, aggregation_account_id, payload, **kwargs):  # noqa: E501
        """Update an aggregation account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_aggregation_account_with_http_info(aggregation_account_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str aggregation_account_id: UUID of an aggregation account (required)
        :param AggregationAccountPayload payload: (required)
        :return: SpecificAggregationAccountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['aggregation_account_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_aggregation_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'aggregation_account_id' is set
        if ('aggregation_account_id' not in params or
                params['aggregation_account_id'] is None):
            raise ValueError("Missing the required parameter `aggregation_account_id` when calling `update_aggregation_account`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_aggregation_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'aggregation_account_id' in params:
            path_params['aggregation_account_id'] = params['aggregation_account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/aggregation_account/{aggregation_account_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificAggregationAccountResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_aggregation_account_balance(self, aggregation_account_balance_id, payload, **kwargs):  # noqa: E501
        """Update an aggregation account balance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_aggregation_account_balance(aggregation_account_balance_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str aggregation_account_balance_id: UUID of an aggregation account balance (required)
        :param AggregationAccountBalancePayload payload: (required)
        :return: SpecificAggregationAccountBalanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_aggregation_account_balance_with_http_info(aggregation_account_balance_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_aggregation_account_balance_with_http_info(aggregation_account_balance_id, payload, **kwargs)  # noqa: E501
            return data

    def update_aggregation_account_balance_with_http_info(self, aggregation_account_balance_id, payload, **kwargs):  # noqa: E501
        """Update an aggregation account balance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_aggregation_account_balance_with_http_info(aggregation_account_balance_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str aggregation_account_balance_id: UUID of an aggregation account balance (required)
        :param AggregationAccountBalancePayload payload: (required)
        :return: SpecificAggregationAccountBalanceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['aggregation_account_balance_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_aggregation_account_balance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'aggregation_account_balance_id' is set
        if ('aggregation_account_balance_id' not in params or
                params['aggregation_account_balance_id'] is None):
            raise ValueError("Missing the required parameter `aggregation_account_balance_id` when calling `update_aggregation_account_balance`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_aggregation_account_balance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'aggregation_account_balance_id' in params:
            path_params['aggregation_account_balance_id'] = params['aggregation_account_balance_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/aggregation_account_balance/{aggregation_account_balance_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificAggregationAccountBalanceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_aggregation_account_holding(self, aggregation_account_holding_id, payload, **kwargs):  # noqa: E501
        """Update an aggregation account holding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_aggregation_account_holding(aggregation_account_holding_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str aggregation_account_holding_id: UUID of an aggregation account holding (required)
        :param AggregationAccountHoldingPayload payload: (required)
        :return: SpecificAggregationAccountHoldingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_aggregation_account_holding_with_http_info(aggregation_account_holding_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_aggregation_account_holding_with_http_info(aggregation_account_holding_id, payload, **kwargs)  # noqa: E501
            return data

    def update_aggregation_account_holding_with_http_info(self, aggregation_account_holding_id, payload, **kwargs):  # noqa: E501
        """Update an aggregation account holding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_aggregation_account_holding_with_http_info(aggregation_account_holding_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str aggregation_account_holding_id: UUID of an aggregation account holding (required)
        :param AggregationAccountHoldingPayload payload: (required)
        :return: SpecificAggregationAccountHoldingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['aggregation_account_holding_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_aggregation_account_holding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'aggregation_account_holding_id' is set
        if ('aggregation_account_holding_id' not in params or
                params['aggregation_account_holding_id'] is None):
            raise ValueError("Missing the required parameter `aggregation_account_holding_id` when calling `update_aggregation_account_holding`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_aggregation_account_holding`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'aggregation_account_holding_id' in params:
            path_params['aggregation_account_holding_id'] = params['aggregation_account_holding_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/aggregation_account_holding/{aggregation_account_holding_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificAggregationAccountHoldingResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_aggregation_account_transaction(self, aggregation_account_transaction_id, payload, **kwargs):  # noqa: E501
        """Update an aggregation account transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_aggregation_account_transaction(aggregation_account_transaction_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str aggregation_account_transaction_id: UUID of an aggregation account transaction (required)
        :param AggregationAccountTransactionPayload payload: (required)
        :return: SpecificAggregationAccountTransactionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_aggregation_account_transaction_with_http_info(aggregation_account_transaction_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_aggregation_account_transaction_with_http_info(aggregation_account_transaction_id, payload, **kwargs)  # noqa: E501
            return data

    def update_aggregation_account_transaction_with_http_info(self, aggregation_account_transaction_id, payload, **kwargs):  # noqa: E501
        """Update an aggregation account transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_aggregation_account_transaction_with_http_info(aggregation_account_transaction_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str aggregation_account_transaction_id: UUID of an aggregation account transaction (required)
        :param AggregationAccountTransactionPayload payload: (required)
        :return: SpecificAggregationAccountTransactionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['aggregation_account_transaction_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_aggregation_account_transaction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'aggregation_account_transaction_id' is set
        if ('aggregation_account_transaction_id' not in params or
                params['aggregation_account_transaction_id'] is None):
            raise ValueError("Missing the required parameter `aggregation_account_transaction_id` when calling `update_aggregation_account_transaction`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_aggregation_account_transaction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'aggregation_account_transaction_id' in params:
            path_params['aggregation_account_transaction_id'] = params['aggregation_account_transaction_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/aggregation_account_transaction/{aggregation_account_transaction_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificAggregationAccountTransactionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_allocation(self, allocation_id, payload, **kwargs):  # noqa: E501
        """Update an allocation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_allocation(allocation_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str allocation_id: UUID of an allocation (required)
        :param AllocationPayload payload: (required)
        :return: SpecificAllocationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_allocation_with_http_info(allocation_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_allocation_with_http_info(allocation_id, payload, **kwargs)  # noqa: E501
            return data

    def update_allocation_with_http_info(self, allocation_id, payload, **kwargs):  # noqa: E501
        """Update an allocation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_allocation_with_http_info(allocation_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str allocation_id: UUID of an allocation (required)
        :param AllocationPayload payload: (required)
        :return: SpecificAllocationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['allocation_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_allocation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'allocation_id' is set
        if ('allocation_id' not in params or
                params['allocation_id'] is None):
            raise ValueError("Missing the required parameter `allocation_id` when calling `update_allocation`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_allocation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'allocation_id' in params:
            path_params['allocation_id'] = params['allocation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/allocation/{allocation_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificAllocationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_allocation_composition(self, allocation_composition_id, payload, **kwargs):  # noqa: E501
        """Update an allocation composition  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_allocation_composition(allocation_composition_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str allocation_composition_id: UUID of an allocation composition (required)
        :param AllocationCompositionPayload payload: (required)
        :return: GetAllocationCompositionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_allocation_composition_with_http_info(allocation_composition_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_allocation_composition_with_http_info(allocation_composition_id, payload, **kwargs)  # noqa: E501
            return data

    def update_allocation_composition_with_http_info(self, allocation_composition_id, payload, **kwargs):  # noqa: E501
        """Update an allocation composition  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_allocation_composition_with_http_info(allocation_composition_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str allocation_composition_id: UUID of an allocation composition (required)
        :param AllocationCompositionPayload payload: (required)
        :return: GetAllocationCompositionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['allocation_composition_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_allocation_composition" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'allocation_composition_id' is set
        if ('allocation_composition_id' not in params or
                params['allocation_composition_id'] is None):
            raise ValueError("Missing the required parameter `allocation_composition_id` when calling `update_allocation_composition`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_allocation_composition`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'allocation_composition_id' in params:
            path_params['allocation_composition_id'] = params['allocation_composition_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/allocation_composition/{allocation_composition_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAllocationCompositionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_bank_link(self, bank_link_id, payload, **kwargs):  # noqa: E501
        """Update a bank link  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_bank_link(bank_link_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str bank_link_id: UUID of a bank link (required)
        :param BankLinkPayload payload: (required)
        :return: SpecificBankLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_bank_link_with_http_info(bank_link_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_bank_link_with_http_info(bank_link_id, payload, **kwargs)  # noqa: E501
            return data

    def update_bank_link_with_http_info(self, bank_link_id, payload, **kwargs):  # noqa: E501
        """Update a bank link  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_bank_link_with_http_info(bank_link_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str bank_link_id: UUID of a bank link (required)
        :param BankLinkPayload payload: (required)
        :return: SpecificBankLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bank_link_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_bank_link" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bank_link_id' is set
        if ('bank_link_id' not in params or
                params['bank_link_id'] is None):
            raise ValueError("Missing the required parameter `bank_link_id` when calling `update_bank_link`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_bank_link`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bank_link_id' in params:
            path_params['bank_link_id'] = params['bank_link_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/bank_link/{bank_link_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificBankLinkResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_benchmark(self, benchmark_id, payload, **kwargs):  # noqa: E501
        """Update a benchmark  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_benchmark(benchmark_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str benchmark_id: UUID of a benchmark (required)
        :param BenchmarkPayload payload: (required)
        :return: SpecificBenchmarkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_benchmark_with_http_info(benchmark_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_benchmark_with_http_info(benchmark_id, payload, **kwargs)  # noqa: E501
            return data

    def update_benchmark_with_http_info(self, benchmark_id, payload, **kwargs):  # noqa: E501
        """Update a benchmark  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_benchmark_with_http_info(benchmark_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str benchmark_id: UUID of a benchmark (required)
        :param BenchmarkPayload payload: (required)
        :return: SpecificBenchmarkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['benchmark_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_benchmark" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'benchmark_id' is set
        if ('benchmark_id' not in params or
                params['benchmark_id'] is None):
            raise ValueError("Missing the required parameter `benchmark_id` when calling `update_benchmark`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_benchmark`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'benchmark_id' in params:
            path_params['benchmark_id'] = params['benchmark_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/benchmark/{benchmark_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificBenchmarkResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_budget(self, budget_id, payload, **kwargs):  # noqa: E501
        """Update a budget  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_budget(budget_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str budget_id: UUID of a budget (required)
        :param BudgetPayload payload: (required)
        :return: SpecificBudgetResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_budget_with_http_info(budget_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_budget_with_http_info(budget_id, payload, **kwargs)  # noqa: E501
            return data

    def update_budget_with_http_info(self, budget_id, payload, **kwargs):  # noqa: E501
        """Update a budget  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_budget_with_http_info(budget_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str budget_id: UUID of a budget (required)
        :param BudgetPayload payload: (required)
        :return: SpecificBudgetResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['budget_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_budget" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'budget_id' is set
        if ('budget_id' not in params or
                params['budget_id'] is None):
            raise ValueError("Missing the required parameter `budget_id` when calling `update_budget`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_budget`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'budget_id' in params:
            path_params['budget_id'] = params['budget_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/budget/{budget_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificBudgetResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_client(self, client_id, payload, **kwargs):  # noqa: E501
        """Update a client  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_client(client_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: UUID of a client (required)
        :param ClientPayload payload: (required)
        :return: SpecificClientResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_client_with_http_info(client_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_client_with_http_info(client_id, payload, **kwargs)  # noqa: E501
            return data

    def update_client_with_http_info(self, client_id, payload, **kwargs):  # noqa: E501
        """Update a client  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_client_with_http_info(client_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: UUID of a client (required)
        :param ClientPayload payload: (required)
        :return: SpecificClientResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_client" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params or
                params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `update_client`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_client`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'client_id' in params:
            path_params['client_id'] = params['client_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/client/{client_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificClientResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_client_hydro(self, client_hydro_id, payload, **kwargs):  # noqa: E501
        """Update a client-hydro relationship  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_client_hydro(client_hydro_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_hydro_id: UUID of a client-hydro relationship (required)
        :param ClientHydroPayload payload: (required)
        :return: SpecificClientHydroResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_client_hydro_with_http_info(client_hydro_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_client_hydro_with_http_info(client_hydro_id, payload, **kwargs)  # noqa: E501
            return data

    def update_client_hydro_with_http_info(self, client_hydro_id, payload, **kwargs):  # noqa: E501
        """Update a client-hydro relationship  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_client_hydro_with_http_info(client_hydro_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_hydro_id: UUID of a client-hydro relationship (required)
        :param ClientHydroPayload payload: (required)
        :return: SpecificClientHydroResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_hydro_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_client_hydro" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_hydro_id' is set
        if ('client_hydro_id' not in params or
                params['client_hydro_id'] is None):
            raise ValueError("Missing the required parameter `client_hydro_id` when calling `update_client_hydro`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_client_hydro`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'client_hydro_id' in params:
            path_params['client_hydro_id'] = params['client_hydro_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/client_hydro/{client_hydro_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificClientHydroResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_client_response(self, client_response_id, payload, **kwargs):  # noqa: E501
        """Update a client response  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_client_response(client_response_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_response_id: UUID of a client response (required)
        :param ClientResponsePayload payload: (required)
        :return: SpecificClientResponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_client_response_with_http_info(client_response_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_client_response_with_http_info(client_response_id, payload, **kwargs)  # noqa: E501
            return data

    def update_client_response_with_http_info(self, client_response_id, payload, **kwargs):  # noqa: E501
        """Update a client response  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_client_response_with_http_info(client_response_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_response_id: UUID of a client response (required)
        :param ClientResponsePayload payload: (required)
        :return: SpecificClientResponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_response_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_client_response" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_response_id' is set
        if ('client_response_id' not in params or
                params['client_response_id'] is None):
            raise ValueError("Missing the required parameter `client_response_id` when calling `update_client_response`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_client_response`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'client_response_id' in params:
            path_params['client_response_id'] = params['client_response_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/client_response/{client_response_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificClientResponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_decision_tree(self, decision_tree_id, payload, **kwargs):  # noqa: E501
        """Update a decision tree  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_decision_tree(decision_tree_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str decision_tree_id: UUID of a decision tree (required)
        :param DecisionTreePayload payload: (required)
        :return: SpecificDecisionTreeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_decision_tree_with_http_info(decision_tree_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_decision_tree_with_http_info(decision_tree_id, payload, **kwargs)  # noqa: E501
            return data

    def update_decision_tree_with_http_info(self, decision_tree_id, payload, **kwargs):  # noqa: E501
        """Update a decision tree  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_decision_tree_with_http_info(decision_tree_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str decision_tree_id: UUID of a decision tree (required)
        :param DecisionTreePayload payload: (required)
        :return: SpecificDecisionTreeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['decision_tree_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_decision_tree" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'decision_tree_id' is set
        if ('decision_tree_id' not in params or
                params['decision_tree_id'] is None):
            raise ValueError("Missing the required parameter `decision_tree_id` when calling `update_decision_tree`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_decision_tree`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'decision_tree_id' in params:
            path_params['decision_tree_id'] = params['decision_tree_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/decision_tree/{decision_tree_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificDecisionTreeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_deposit_request(self, deposit_id, payload, **kwargs):  # noqa: E501
        """Update a deposit request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_deposit_request(deposit_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str deposit_id: UUID of a deposit record (required)
        :param DepositRequestPayload payload: (required)
        :return: SpecificDepositRequestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_deposit_request_with_http_info(deposit_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_deposit_request_with_http_info(deposit_id, payload, **kwargs)  # noqa: E501
            return data

    def update_deposit_request_with_http_info(self, deposit_id, payload, **kwargs):  # noqa: E501
        """Update a deposit request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_deposit_request_with_http_info(deposit_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str deposit_id: UUID of a deposit record (required)
        :param DepositRequestPayload payload: (required)
        :return: SpecificDepositRequestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deposit_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_deposit_request" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deposit_id' is set
        if ('deposit_id' not in params or
                params['deposit_id'] is None):
            raise ValueError("Missing the required parameter `deposit_id` when calling `update_deposit_request`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_deposit_request`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deposit_id' in params:
            path_params['deposit_id'] = params['deposit_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/deposit/{deposit_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificDepositRequestResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_financial_offer(self, financial_offer_id, payload, **kwargs):  # noqa: E501
        """Update a financial offer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_financial_offer(financial_offer_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str financial_offer_id: UUID of a financial offer (required)
        :param FinancialOfferPayload payload: (required)
        :return: SpecificFinancialOfferResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_financial_offer_with_http_info(financial_offer_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_financial_offer_with_http_info(financial_offer_id, payload, **kwargs)  # noqa: E501
            return data

    def update_financial_offer_with_http_info(self, financial_offer_id, payload, **kwargs):  # noqa: E501
        """Update a financial offer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_financial_offer_with_http_info(financial_offer_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str financial_offer_id: UUID of a financial offer (required)
        :param FinancialOfferPayload payload: (required)
        :return: SpecificFinancialOfferResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['financial_offer_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_financial_offer" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'financial_offer_id' is set
        if ('financial_offer_id' not in params or
                params['financial_offer_id'] is None):
            raise ValueError("Missing the required parameter `financial_offer_id` when calling `update_financial_offer`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_financial_offer`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'financial_offer_id' in params:
            path_params['financial_offer_id'] = params['financial_offer_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/financial_offer/{financial_offer_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificFinancialOfferResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_funding_request(self, funding_id, payload, **kwargs):  # noqa: E501
        """Update a funding request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_funding_request(funding_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str funding_id: UUID of a funding record (required)
        :param FundingRequestPayload payload: (required)
        :return: SpecificFundingRequestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_funding_request_with_http_info(funding_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_funding_request_with_http_info(funding_id, payload, **kwargs)  # noqa: E501
            return data

    def update_funding_request_with_http_info(self, funding_id, payload, **kwargs):  # noqa: E501
        """Update a funding request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_funding_request_with_http_info(funding_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str funding_id: UUID of a funding record (required)
        :param FundingRequestPayload payload: (required)
        :return: SpecificFundingRequestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['funding_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_funding_request" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'funding_id' is set
        if ('funding_id' not in params or
                params['funding_id'] is None):
            raise ValueError("Missing the required parameter `funding_id` when calling `update_funding_request`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_funding_request`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'funding_id' in params:
            path_params['funding_id'] = params['funding_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/funding/{funding_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificFundingRequestResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_goal(self, goal_id, payload, **kwargs):  # noqa: E501
        """Update a goal  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_goal(goal_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str goal_id: UUID of a goal (required)
        :param GoalPayload payload: (required)
        :return: SpecificGoalResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_goal_with_http_info(goal_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_goal_with_http_info(goal_id, payload, **kwargs)  # noqa: E501
            return data

    def update_goal_with_http_info(self, goal_id, payload, **kwargs):  # noqa: E501
        """Update a goal  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_goal_with_http_info(goal_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str goal_id: UUID of a goal (required)
        :param GoalPayload payload: (required)
        :return: SpecificGoalResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['goal_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_goal" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'goal_id' is set
        if ('goal_id' not in params or
                params['goal_id'] is None):
            raise ValueError("Missing the required parameter `goal_id` when calling `update_goal`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_goal`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'goal_id' in params:
            path_params['goal_id'] = params['goal_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/goal/{goal_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificGoalResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_goal_track_record(self, goal_track_id, payload, **kwargs):  # noqa: E501
        """Update a goal track record  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_goal_track_record(goal_track_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str goal_track_id: UUID of a goal tracking record (required)
        :param GoalTrackPayload payload: (required)
        :return: SpecificGoalTrackResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_goal_track_record_with_http_info(goal_track_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_goal_track_record_with_http_info(goal_track_id, payload, **kwargs)  # noqa: E501
            return data

    def update_goal_track_record_with_http_info(self, goal_track_id, payload, **kwargs):  # noqa: E501
        """Update a goal track record  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_goal_track_record_with_http_info(goal_track_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str goal_track_id: UUID of a goal tracking record (required)
        :param GoalTrackPayload payload: (required)
        :return: SpecificGoalTrackResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['goal_track_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_goal_track_record" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'goal_track_id' is set
        if ('goal_track_id' not in params or
                params['goal_track_id'] is None):
            raise ValueError("Missing the required parameter `goal_track_id` when calling `update_goal_track_record`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_goal_track_record`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'goal_track_id' in params:
            path_params['goal_track_id'] = params['goal_track_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/goal_track/{goal_track_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificGoalTrackResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_model(self, model_id, payload, **kwargs):  # noqa: E501
        """Update a model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_model(model_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_id: UUID of a model (required)
        :param ModelPayload payload: (required)
        :return: SpecificModelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_model_with_http_info(model_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_model_with_http_info(model_id, payload, **kwargs)  # noqa: E501
            return data

    def update_model_with_http_info(self, model_id, payload, **kwargs):  # noqa: E501
        """Update a model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_model_with_http_info(model_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_id: UUID of a model (required)
        :param ModelPayload payload: (required)
        :return: SpecificModelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_model" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_id' is set
        if ('model_id' not in params or
                params['model_id'] is None):
            raise ValueError("Missing the required parameter `model_id` when calling `update_model`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_model`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_id' in params:
            path_params['model_id'] = params['model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/model/{model_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificModelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_model_asset_size(self, model_asset_size_id, payload, **kwargs):  # noqa: E501
        """Update a model asset size  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_model_asset_size(model_asset_size_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_asset_size_id: UUID of a model asset size record (required)
        :param ModelAssetSizePayload payload: (required)
        :return: SpecificModelAssetSizeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_model_asset_size_with_http_info(model_asset_size_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_model_asset_size_with_http_info(model_asset_size_id, payload, **kwargs)  # noqa: E501
            return data

    def update_model_asset_size_with_http_info(self, model_asset_size_id, payload, **kwargs):  # noqa: E501
        """Update a model asset size  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_model_asset_size_with_http_info(model_asset_size_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_asset_size_id: UUID of a model asset size record (required)
        :param ModelAssetSizePayload payload: (required)
        :return: SpecificModelAssetSizeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_asset_size_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_model_asset_size" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_asset_size_id' is set
        if ('model_asset_size_id' not in params or
                params['model_asset_size_id'] is None):
            raise ValueError("Missing the required parameter `model_asset_size_id` when calling `update_model_asset_size`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_model_asset_size`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_asset_size_id' in params:
            path_params['model_asset_size_id'] = params['model_asset_size_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/model_asset_size/{model_asset_size_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificModelAssetSizeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_model_comment(self, model_comment_id, payload, **kwargs):  # noqa: E501
        """Update a model commentary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_model_comment(model_comment_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_comment_id: UUID of a model comment (required)
        :param ModelCommentPayload payload: (required)
        :return: SpecificModelCommentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_model_comment_with_http_info(model_comment_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_model_comment_with_http_info(model_comment_id, payload, **kwargs)  # noqa: E501
            return data

    def update_model_comment_with_http_info(self, model_comment_id, payload, **kwargs):  # noqa: E501
        """Update a model commentary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_model_comment_with_http_info(model_comment_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_comment_id: UUID of a model comment (required)
        :param ModelCommentPayload payload: (required)
        :return: SpecificModelCommentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_comment_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_model_comment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_comment_id' is set
        if ('model_comment_id' not in params or
                params['model_comment_id'] is None):
            raise ValueError("Missing the required parameter `model_comment_id` when calling `update_model_comment`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_model_comment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_comment_id' in params:
            path_params['model_comment_id'] = params['model_comment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/model_comment/{model_comment_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificModelCommentResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_model_composition(self, model_id, payload, **kwargs):  # noqa: E501
        """Change a model composition  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_model_composition(model_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_id: UUID of a model (required)
        :param ModelCompositionPayload payload: (required)
        :return: ChangeModelCompositionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_model_composition_with_http_info(model_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_model_composition_with_http_info(model_id, payload, **kwargs)  # noqa: E501
            return data

    def update_model_composition_with_http_info(self, model_id, payload, **kwargs):  # noqa: E501
        """Change a model composition  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_model_composition_with_http_info(model_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_id: UUID of a model (required)
        :param ModelCompositionPayload payload: (required)
        :return: ChangeModelCompositionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_model_composition" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_id' is set
        if ('model_id' not in params or
                params['model_id'] is None):
            raise ValueError("Missing the required parameter `model_id` when calling `update_model_composition`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_model_composition`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_id' in params:
            path_params['model_id'] = params['model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/model/{model_id}/model_change', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ChangeModelCompositionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_model_holding(self, model_holding_id, payload, **kwargs):  # noqa: E501
        """Update a model holding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_model_holding(model_holding_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_holding_id: UUID of a model holding record (required)
        :param ModelHoldingPayload payload: (required)
        :return: SpecificModelHoldingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_model_holding_with_http_info(model_holding_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_model_holding_with_http_info(model_holding_id, payload, **kwargs)  # noqa: E501
            return data

    def update_model_holding_with_http_info(self, model_holding_id, payload, **kwargs):  # noqa: E501
        """Update a model holding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_model_holding_with_http_info(model_holding_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_holding_id: UUID of a model holding record (required)
        :param ModelHoldingPayload payload: (required)
        :return: SpecificModelHoldingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_holding_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_model_holding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_holding_id' is set
        if ('model_holding_id' not in params or
                params['model_holding_id'] is None):
            raise ValueError("Missing the required parameter `model_holding_id` when calling `update_model_holding`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_model_holding`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_holding_id' in params:
            path_params['model_holding_id'] = params['model_holding_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/model_holding/{model_holding_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificModelHoldingResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_model_transaction(self, model_transaction_id, payload, **kwargs):  # noqa: E501
        """Update a model transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_model_transaction(model_transaction_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_transaction_id: UUID of a model transaction record (required)
        :param ModelTransactionPayload payload: (required)
        :return: SpecificModelTransactionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_model_transaction_with_http_info(model_transaction_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_model_transaction_with_http_info(model_transaction_id, payload, **kwargs)  # noqa: E501
            return data

    def update_model_transaction_with_http_info(self, model_transaction_id, payload, **kwargs):  # noqa: E501
        """Update a model transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_model_transaction_with_http_info(model_transaction_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_transaction_id: UUID of a model transaction record (required)
        :param ModelTransactionPayload payload: (required)
        :return: SpecificModelTransactionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_transaction_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_model_transaction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_transaction_id' is set
        if ('model_transaction_id' not in params or
                params['model_transaction_id'] is None):
            raise ValueError("Missing the required parameter `model_transaction_id` when calling `update_model_transaction`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_model_transaction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_transaction_id' in params:
            path_params['model_transaction_id'] = params['model_transaction_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/model_transaction/{model_transaction_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificModelTransactionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_node(self, node_id, payload, **kwargs):  # noqa: E501
        """Update a node  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_node(node_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_id: UUID of a node (required)
        :param NodePayload payload: (required)
        :return: SpecificNodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_node_with_http_info(node_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_node_with_http_info(node_id, payload, **kwargs)  # noqa: E501
            return data

    def update_node_with_http_info(self, node_id, payload, **kwargs):  # noqa: E501
        """Update a node  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_node_with_http_info(node_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_id: UUID of a node (required)
        :param NodePayload payload: (required)
        :return: SpecificNodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_id' is set
        if ('node_id' not in params or
                params['node_id'] is None):
            raise ValueError("Missing the required parameter `node_id` when calling `update_node`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_node`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_id' in params:
            path_params['node_id'] = params['node_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/node/{node_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificNodeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_node_relationship(self, node_relationship_id, payload, **kwargs):  # noqa: E501
        """Update a node relationship  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_node_relationship(node_relationship_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_relationship_id: UUID of a node relationship (required)
        :param NodeRelationshipPayload payload: (required)
        :return: SpecificNodeRelationshipResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_node_relationship_with_http_info(node_relationship_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_node_relationship_with_http_info(node_relationship_id, payload, **kwargs)  # noqa: E501
            return data

    def update_node_relationship_with_http_info(self, node_relationship_id, payload, **kwargs):  # noqa: E501
        """Update a node relationship  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_node_relationship_with_http_info(node_relationship_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_relationship_id: UUID of a node relationship (required)
        :param NodeRelationshipPayload payload: (required)
        :return: SpecificNodeRelationshipResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_relationship_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_node_relationship" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_relationship_id' is set
        if ('node_relationship_id' not in params or
                params['node_relationship_id'] is None):
            raise ValueError("Missing the required parameter `node_relationship_id` when calling `update_node_relationship`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_node_relationship`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_relationship_id' in params:
            path_params['node_relationship_id'] = params['node_relationship_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/node_relationship/{node_relationship_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificNodeRelationshipResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_order_record(self, order_id, payload, **kwargs):  # noqa: E501
        """Update an order record  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_order_record(order_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order_id: UUID of an order record (required)
        :param OrderPayload payload: (required)
        :return: SpecificOrderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_order_record_with_http_info(order_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_order_record_with_http_info(order_id, payload, **kwargs)  # noqa: E501
            return data

    def update_order_record_with_http_info(self, order_id, payload, **kwargs):  # noqa: E501
        """Update an order record  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_order_record_with_http_info(order_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order_id: UUID of an order record (required)
        :param OrderPayload payload: (required)
        :return: SpecificOrderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['order_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_order_record" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'order_id' is set
        if ('order_id' not in params or
                params['order_id'] is None):
            raise ValueError("Missing the required parameter `order_id` when calling `update_order_record`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_order_record`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'order_id' in params:
            path_params['order_id'] = params['order_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/order/{order_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificOrderResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_order_status(self, order_status_id, payload, **kwargs):  # noqa: E501
        """Update an order status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_order_status(order_status_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order_status_id: UUID of an order status record (required)
        :param OrderStatusPayload payload: (required)
        :return: SpecificOrderStatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_order_status_with_http_info(order_status_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_order_status_with_http_info(order_status_id, payload, **kwargs)  # noqa: E501
            return data

    def update_order_status_with_http_info(self, order_status_id, payload, **kwargs):  # noqa: E501
        """Update an order status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_order_status_with_http_info(order_status_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order_status_id: UUID of an order status record (required)
        :param OrderStatusPayload payload: (required)
        :return: SpecificOrderStatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['order_status_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_order_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'order_status_id' is set
        if ('order_status_id' not in params or
                params['order_status_id'] is None):
            raise ValueError("Missing the required parameter `order_status_id` when calling `update_order_status`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_order_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'order_status_id' in params:
            path_params['order_status_id'] = params['order_status_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/order_status/{order_status_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificOrderStatusResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_order_tracking_record(self, order_track_id, payload, **kwargs):  # noqa: E501
        """Update an order tracking record  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_order_tracking_record(order_track_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order_track_id: UUID of an order tracking record (required)
        :param OrderTrackPayload payload: (required)
        :return: SpecificOrderTrackResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_order_tracking_record_with_http_info(order_track_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_order_tracking_record_with_http_info(order_track_id, payload, **kwargs)  # noqa: E501
            return data

    def update_order_tracking_record_with_http_info(self, order_track_id, payload, **kwargs):  # noqa: E501
        """Update an order tracking record  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_order_tracking_record_with_http_info(order_track_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order_track_id: UUID of an order tracking record (required)
        :param OrderTrackPayload payload: (required)
        :return: SpecificOrderTrackResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['order_track_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_order_tracking_record" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'order_track_id' is set
        if ('order_track_id' not in params or
                params['order_track_id'] is None):
            raise ValueError("Missing the required parameter `order_track_id` when calling `update_order_tracking_record`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_order_tracking_record`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'order_track_id' in params:
            path_params['order_track_id'] = params['order_track_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/order_track/{order_track_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificOrderTrackResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_portfolio(self, portfolio_id, payload, **kwargs):  # noqa: E501
        """Update a portfolio  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_portfolio(portfolio_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_id: UUID of a portfolio (required)
        :param PortfolioPayload payload: (required)
        :return: SpecificPortfolioResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_portfolio_with_http_info(portfolio_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_portfolio_with_http_info(portfolio_id, payload, **kwargs)  # noqa: E501
            return data

    def update_portfolio_with_http_info(self, portfolio_id, payload, **kwargs):  # noqa: E501
        """Update a portfolio  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_portfolio_with_http_info(portfolio_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_id: UUID of a portfolio (required)
        :param PortfolioPayload payload: (required)
        :return: SpecificPortfolioResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portfolio_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_portfolio" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portfolio_id' is set
        if ('portfolio_id' not in params or
                params['portfolio_id'] is None):
            raise ValueError("Missing the required parameter `portfolio_id` when calling `update_portfolio`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_portfolio`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portfolio_id' in params:
            path_params['portfolio_id'] = params['portfolio_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/portfolio/{portfolio_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificPortfolioResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_portfolio_asset_size(self, portfolio_asset_size_id, payload, **kwargs):  # noqa: E501
        """Update a portfolio asset size  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_portfolio_asset_size(portfolio_asset_size_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_asset_size_id: UUID of a portfolio asset size record (required)
        :param PortfolioAssetSizePayload payload: (required)
        :return: SpecificPortfolioAssetSizeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_portfolio_asset_size_with_http_info(portfolio_asset_size_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_portfolio_asset_size_with_http_info(portfolio_asset_size_id, payload, **kwargs)  # noqa: E501
            return data

    def update_portfolio_asset_size_with_http_info(self, portfolio_asset_size_id, payload, **kwargs):  # noqa: E501
        """Update a portfolio asset size  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_portfolio_asset_size_with_http_info(portfolio_asset_size_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_asset_size_id: UUID of a portfolio asset size record (required)
        :param PortfolioAssetSizePayload payload: (required)
        :return: SpecificPortfolioAssetSizeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portfolio_asset_size_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_portfolio_asset_size" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portfolio_asset_size_id' is set
        if ('portfolio_asset_size_id' not in params or
                params['portfolio_asset_size_id'] is None):
            raise ValueError("Missing the required parameter `portfolio_asset_size_id` when calling `update_portfolio_asset_size`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_portfolio_asset_size`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portfolio_asset_size_id' in params:
            path_params['portfolio_asset_size_id'] = params['portfolio_asset_size_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/portfolio_asset_size/{portfolio_asset_size_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificPortfolioAssetSizeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_portfolio_comment(self, portfolio_comment_id, payload, **kwargs):  # noqa: E501
        """Update a portfolio commentary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_portfolio_comment(portfolio_comment_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_comment_id: UUID of a portfolio comment (required)
        :param PortfolioCommentPayload payload: (required)
        :return: SpecificPortfolioCommentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_portfolio_comment_with_http_info(portfolio_comment_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_portfolio_comment_with_http_info(portfolio_comment_id, payload, **kwargs)  # noqa: E501
            return data

    def update_portfolio_comment_with_http_info(self, portfolio_comment_id, payload, **kwargs):  # noqa: E501
        """Update a portfolio commentary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_portfolio_comment_with_http_info(portfolio_comment_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_comment_id: UUID of a portfolio comment (required)
        :param PortfolioCommentPayload payload: (required)
        :return: SpecificPortfolioCommentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portfolio_comment_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_portfolio_comment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portfolio_comment_id' is set
        if ('portfolio_comment_id' not in params or
                params['portfolio_comment_id'] is None):
            raise ValueError("Missing the required parameter `portfolio_comment_id` when calling `update_portfolio_comment`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_portfolio_comment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portfolio_comment_id' in params:
            path_params['portfolio_comment_id'] = params['portfolio_comment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/portfolio_comment/{portfolio_comment_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificPortfolioCommentResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_portfolio_holding(self, portfolio_holding_id, payload, **kwargs):  # noqa: E501
        """Update a portfolio holding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_portfolio_holding(portfolio_holding_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_holding_id: UUID of a portfolio holding record (required)
        :param PortfolioHoldingPayload payload: (required)
        :return: SpecificPortfolioHoldingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_portfolio_holding_with_http_info(portfolio_holding_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_portfolio_holding_with_http_info(portfolio_holding_id, payload, **kwargs)  # noqa: E501
            return data

    def update_portfolio_holding_with_http_info(self, portfolio_holding_id, payload, **kwargs):  # noqa: E501
        """Update a portfolio holding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_portfolio_holding_with_http_info(portfolio_holding_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_holding_id: UUID of a portfolio holding record (required)
        :param PortfolioHoldingPayload payload: (required)
        :return: SpecificPortfolioHoldingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portfolio_holding_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_portfolio_holding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portfolio_holding_id' is set
        if ('portfolio_holding_id' not in params or
                params['portfolio_holding_id'] is None):
            raise ValueError("Missing the required parameter `portfolio_holding_id` when calling `update_portfolio_holding`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_portfolio_holding`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portfolio_holding_id' in params:
            path_params['portfolio_holding_id'] = params['portfolio_holding_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/portfolio_holding/{portfolio_holding_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificPortfolioHoldingResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_portfolio_transaction(self, portfolio_transaction_id, payload, **kwargs):  # noqa: E501
        """Update a portfolio transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_portfolio_transaction(portfolio_transaction_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_transaction_id: UUID of a portfolio transaction record (required)
        :param PortfolioTransactionPayload payload: (required)
        :return: SpecificPortfolioTransactionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_portfolio_transaction_with_http_info(portfolio_transaction_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_portfolio_transaction_with_http_info(portfolio_transaction_id, payload, **kwargs)  # noqa: E501
            return data

    def update_portfolio_transaction_with_http_info(self, portfolio_transaction_id, payload, **kwargs):  # noqa: E501
        """Update a portfolio transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_portfolio_transaction_with_http_info(portfolio_transaction_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str portfolio_transaction_id: UUID of a portfolio transaction record (required)
        :param PortfolioTransactionPayload payload: (required)
        :return: SpecificPortfolioTransactionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portfolio_transaction_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_portfolio_transaction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portfolio_transaction_id' is set
        if ('portfolio_transaction_id' not in params or
                params['portfolio_transaction_id'] is None):
            raise ValueError("Missing the required parameter `portfolio_transaction_id` when calling `update_portfolio_transaction`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_portfolio_transaction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portfolio_transaction_id' in params:
            path_params['portfolio_transaction_id'] = params['portfolio_transaction_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/portfolio_transaction/{portfolio_transaction_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificPortfolioTransactionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_questionnaire(self, questionnaire_id, payload, **kwargs):  # noqa: E501
        """Update a questionnaire  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_questionnaire(questionnaire_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str questionnaire_id: UUID of a questionnaire (required)
        :param QuestionnairePayload payload: (required)
        :return: SpecificQuestionnaireResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_questionnaire_with_http_info(questionnaire_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_questionnaire_with_http_info(questionnaire_id, payload, **kwargs)  # noqa: E501
            return data

    def update_questionnaire_with_http_info(self, questionnaire_id, payload, **kwargs):  # noqa: E501
        """Update a questionnaire  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_questionnaire_with_http_info(questionnaire_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str questionnaire_id: UUID of a questionnaire (required)
        :param QuestionnairePayload payload: (required)
        :return: SpecificQuestionnaireResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['questionnaire_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_questionnaire" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'questionnaire_id' is set
        if ('questionnaire_id' not in params or
                params['questionnaire_id'] is None):
            raise ValueError("Missing the required parameter `questionnaire_id` when calling `update_questionnaire`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_questionnaire`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'questionnaire_id' in params:
            path_params['questionnaire_id'] = params['questionnaire_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/questionnaire/{questionnaire_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificQuestionnaireResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_score(self, score_id, payload, **kwargs):  # noqa: E501
        """Update a score  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_score(score_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str score_id: UUID of a score record (required)
        :param ScorePayload payload: (required)
        :return: SpecificScoreResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_score_with_http_info(score_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_score_with_http_info(score_id, payload, **kwargs)  # noqa: E501
            return data

    def update_score_with_http_info(self, score_id, payload, **kwargs):  # noqa: E501
        """Update a score  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_score_with_http_info(score_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str score_id: UUID of a score record (required)
        :param ScorePayload payload: (required)
        :return: SpecificScoreResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['score_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_score" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'score_id' is set
        if ('score_id' not in params or
                params['score_id'] is None):
            raise ValueError("Missing the required parameter `score_id` when calling `update_score`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_score`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'score_id' in params:
            path_params['score_id'] = params['score_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/score/{score_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificScoreResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_security(self, security_id, payload, **kwargs):  # noqa: E501
        """Update a security  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_security(security_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str security_id: UUID of a security (required)
        :param SecurityPayload payload: (required)
        :return: SpecificSecurityResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_security_with_http_info(security_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_security_with_http_info(security_id, payload, **kwargs)  # noqa: E501
            return data

    def update_security_with_http_info(self, security_id, payload, **kwargs):  # noqa: E501
        """Update a security  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_security_with_http_info(security_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str security_id: UUID of a security (required)
        :param SecurityPayload payload: (required)
        :return: SpecificSecurityResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['security_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_security" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'security_id' is set
        if ('security_id' not in params or
                params['security_id'] is None):
            raise ValueError("Missing the required parameter `security_id` when calling `update_security`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_security`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'security_id' in params:
            path_params['security_id'] = params['security_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/security/{security_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificSecurityResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_security_exclusion(self, security_exclusion_id, payload, **kwargs):  # noqa: E501
        """Update a security exclusion  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_security_exclusion(security_exclusion_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str security_exclusion_id: UUID of a security exclusion record (required)
        :param SecurityExclusionPayload payload: (required)
        :return: SpecificSecurityExclusionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_security_exclusion_with_http_info(security_exclusion_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_security_exclusion_with_http_info(security_exclusion_id, payload, **kwargs)  # noqa: E501
            return data

    def update_security_exclusion_with_http_info(self, security_exclusion_id, payload, **kwargs):  # noqa: E501
        """Update a security exclusion  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_security_exclusion_with_http_info(security_exclusion_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str security_exclusion_id: UUID of a security exclusion record (required)
        :param SecurityExclusionPayload payload: (required)
        :return: SpecificSecurityExclusionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['security_exclusion_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_security_exclusion" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'security_exclusion_id' is set
        if ('security_exclusion_id' not in params or
                params['security_exclusion_id'] is None):
            raise ValueError("Missing the required parameter `security_exclusion_id` when calling `update_security_exclusion`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_security_exclusion`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'security_exclusion_id' in params:
            path_params['security_exclusion_id'] = params['security_exclusion_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/security_exclusion/{security_exclusion_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificSecurityExclusionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_security_price(self, security_price_id, payload, **kwargs):  # noqa: E501
        """Update a security price  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_security_price(security_price_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str security_price_id: UUID of a security price record (required)
        :param SecurityPricePayload payload: (required)
        :return: SpecificSecurityPriceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_security_price_with_http_info(security_price_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_security_price_with_http_info(security_price_id, payload, **kwargs)  # noqa: E501
            return data

    def update_security_price_with_http_info(self, security_price_id, payload, **kwargs):  # noqa: E501
        """Update a security price  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_security_price_with_http_info(security_price_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str security_price_id: UUID of a security price record (required)
        :param SecurityPricePayload payload: (required)
        :return: SpecificSecurityPriceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['security_price_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_security_price" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'security_price_id' is set
        if ('security_price_id' not in params or
                params['security_price_id'] is None):
            raise ValueError("Missing the required parameter `security_price_id` when calling `update_security_price`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_security_price`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'security_price_id' in params:
            path_params['security_price_id'] = params['security_price_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/security_price/{security_price_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificSecurityPriceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_transaction_code(self, transaction_code_id, payload, **kwargs):  # noqa: E501
        """Update a transaction code  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_transaction_code(transaction_code_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transaction_code_id: UUID of a transaction code (required)
        :param TransactionCodePayload payload: (required)
        :return: SpecificTransactionCodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_transaction_code_with_http_info(transaction_code_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_transaction_code_with_http_info(transaction_code_id, payload, **kwargs)  # noqa: E501
            return data

    def update_transaction_code_with_http_info(self, transaction_code_id, payload, **kwargs):  # noqa: E501
        """Update a transaction code  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_transaction_code_with_http_info(transaction_code_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transaction_code_id: UUID of a transaction code (required)
        :param TransactionCodePayload payload: (required)
        :return: SpecificTransactionCodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transaction_code_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_transaction_code" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transaction_code_id' is set
        if ('transaction_code_id' not in params or
                params['transaction_code_id'] is None):
            raise ValueError("Missing the required parameter `transaction_code_id` when calling `update_transaction_code`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_transaction_code`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transaction_code_id' in params:
            path_params['transaction_code_id'] = params['transaction_code_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/transaction_code/{transaction_code_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificTransactionCodeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_transfer_request(self, transfer_id, payload, **kwargs):  # noqa: E501
        """Update a transfer request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_transfer_request(transfer_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transfer_id: UUID of an account transfer record (required)
        :param TransferRequestPayload payload: (required)
        :return: SpecificTransferResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_transfer_request_with_http_info(transfer_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_transfer_request_with_http_info(transfer_id, payload, **kwargs)  # noqa: E501
            return data

    def update_transfer_request_with_http_info(self, transfer_id, payload, **kwargs):  # noqa: E501
        """Update a transfer request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_transfer_request_with_http_info(transfer_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str transfer_id: UUID of an account transfer record (required)
        :param TransferRequestPayload payload: (required)
        :return: SpecificTransferResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transfer_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_transfer_request" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transfer_id' is set
        if ('transfer_id' not in params or
                params['transfer_id'] is None):
            raise ValueError("Missing the required parameter `transfer_id` when calling `update_transfer_request`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_transfer_request`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transfer_id' in params:
            path_params['transfer_id'] = params['transfer_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/transfer/{transfer_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificTransferResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_withdrawal_request(self, withdrawal_id, payload, **kwargs):  # noqa: E501
        """Update a withdrawal request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_withdrawal_request(withdrawal_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str withdrawal_id: UUID of a withdrawal request (required)
        :param WithdrawalPayload payload: (required)
        :return: SpecificWithdrawalResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_withdrawal_request_with_http_info(withdrawal_id, payload, **kwargs)  # noqa: E501
        else:
            (data) = self.update_withdrawal_request_with_http_info(withdrawal_id, payload, **kwargs)  # noqa: E501
            return data

    def update_withdrawal_request_with_http_info(self, withdrawal_id, payload, **kwargs):  # noqa: E501
        """Update a withdrawal request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_withdrawal_request_with_http_info(withdrawal_id, payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str withdrawal_id: UUID of a withdrawal request (required)
        :param WithdrawalPayload payload: (required)
        :return: SpecificWithdrawalResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['withdrawal_id', 'payload']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_withdrawal_request" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'withdrawal_id' is set
        if ('withdrawal_id' not in params or
                params['withdrawal_id'] is None):
            raise ValueError("Missing the required parameter `withdrawal_id` when calling `update_withdrawal_request`")  # noqa: E501
        # verify the required parameter 'payload' is set
        if ('payload' not in params or
                params['payload'] is None):
            raise ValueError("Missing the required parameter `payload` when calling `update_withdrawal_request`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'withdrawal_id' in params:
            path_params['withdrawal_id'] = params['withdrawal_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payload' in params:
            body_params = params['payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth']  # noqa: E501

        return self.api_client.call_api(
            '/nucleus/v1/withdrawal/{withdrawal_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpecificWithdrawalResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
