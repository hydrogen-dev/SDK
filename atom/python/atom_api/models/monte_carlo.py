# coding: utf-8

"""
    Hydrogen Atom API

    The Hydrogen Atom API  # noqa: E501

    OpenAPI spec version: 1.0.1
    Contact: info@hydrogenplatform.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six


class MonteCarlo(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'cf': 'list[list[float]]',
        'mu': 'list[float]',
        'sigma': 'list[float]',
        'ret_mod': 'list[float]',
        'init_bal': 'int',
        'n': 'int',
        'remove_outliers': 'bool',
        'result_type': 'str',
        'p': 'list[float]',
        'min_bal': 'list[float]',
        'max_bal': 'list[float]',
        'min_sample': 'list[float]',
        'max_sample': 'list[float]'
    }

    attribute_map = {
        'cf': 'cf',
        'mu': 'mu',
        'sigma': 'sigma',
        'ret_mod': 'ret_mod',
        'init_bal': 'init_bal',
        'n': 'n',
        'remove_outliers': 'remove_outliers',
        'result_type': 'result_type',
        'p': 'p',
        'min_bal': 'min_bal',
        'max_bal': 'max_bal',
        'min_sample': 'min_sample',
        'max_sample': 'max_sample'
    }

    def __init__(self, cf=None, mu=None, sigma=None, ret_mod=None, init_bal=None, n=None, remove_outliers=False, result_type='raw', p=None, min_bal=None, max_bal=None, min_sample=None, max_sample=None):  # noqa: E501
        """MonteCarlo - a model defined in Swagger"""  # noqa: E501

        self._cf = None
        self._mu = None
        self._sigma = None
        self._ret_mod = None
        self._init_bal = None
        self._n = None
        self._remove_outliers = None
        self._result_type = None
        self._p = None
        self._min_bal = None
        self._max_bal = None
        self._min_sample = None
        self._max_sample = None
        self.discriminator = None

        self.cf = cf
        self.mu = mu
        self.sigma = sigma
        if ret_mod is not None:
            self.ret_mod = ret_mod
        if init_bal is not None:
            self.init_bal = init_bal
        if n is not None:
            self.n = n
        if remove_outliers is not None:
            self.remove_outliers = remove_outliers
        if result_type is not None:
            self.result_type = result_type
        if p is not None:
            self.p = p
        if min_bal is not None:
            self.min_bal = min_bal
        if max_bal is not None:
            self.max_bal = max_bal
        if min_sample is not None:
            self.min_sample = min_sample
        if max_sample is not None:
            self.max_sample = max_sample

    @property
    def cf(self):
        """Gets the cf of this MonteCarlo.  # noqa: E501

        The cash flows to occur during the simulation  # noqa: E501

        :return: The cf of this MonteCarlo.  # noqa: E501
        :rtype: list[list[float]]
        """
        return self._cf

    @cf.setter
    def cf(self, cf):
        """Sets the cf of this MonteCarlo.

        The cash flows to occur during the simulation  # noqa: E501

        :param cf: The cf of this MonteCarlo.  # noqa: E501
        :type: list[list[float]]
        """
        if cf is None:
            raise ValueError("Invalid value for `cf`, must not be `None`")  # noqa: E501

        self._cf = cf

    @property
    def mu(self):
        """Gets the mu of this MonteCarlo.  # noqa: E501

        The periodic mean portfolio return  # noqa: E501

        :return: The mu of this MonteCarlo.  # noqa: E501
        :rtype: list[float]
        """
        return self._mu

    @mu.setter
    def mu(self, mu):
        """Sets the mu of this MonteCarlo.

        The periodic mean portfolio return  # noqa: E501

        :param mu: The mu of this MonteCarlo.  # noqa: E501
        :type: list[float]
        """
        if mu is None:
            raise ValueError("Invalid value for `mu`, must not be `None`")  # noqa: E501

        self._mu = mu

    @property
    def sigma(self):
        """Gets the sigma of this MonteCarlo.  # noqa: E501

        The periodic portfolio standard deviation  # noqa: E501

        :return: The sigma of this MonteCarlo.  # noqa: E501
        :rtype: list[float]
        """
        return self._sigma

    @sigma.setter
    def sigma(self, sigma):
        """Sets the sigma of this MonteCarlo.

        The periodic portfolio standard deviation  # noqa: E501

        :param sigma: The sigma of this MonteCarlo.  # noqa: E501
        :type: list[float]
        """
        if sigma is None:
            raise ValueError("Invalid value for `sigma`, must not be `None`")  # noqa: E501

        self._sigma = sigma

    @property
    def ret_mod(self):
        """Gets the ret_mod of this MonteCarlo.  # noqa: E501

        A periodic return modifier  # noqa: E501

        :return: The ret_mod of this MonteCarlo.  # noqa: E501
        :rtype: list[float]
        """
        return self._ret_mod

    @ret_mod.setter
    def ret_mod(self, ret_mod):
        """Sets the ret_mod of this MonteCarlo.

        A periodic return modifier  # noqa: E501

        :param ret_mod: The ret_mod of this MonteCarlo.  # noqa: E501
        :type: list[float]
        """

        self._ret_mod = ret_mod

    @property
    def init_bal(self):
        """Gets the init_bal of this MonteCarlo.  # noqa: E501

        The initial investment at time zero  # noqa: E501

        :return: The init_bal of this MonteCarlo.  # noqa: E501
        :rtype: int
        """
        return self._init_bal

    @init_bal.setter
    def init_bal(self, init_bal):
        """Sets the init_bal of this MonteCarlo.

        The initial investment at time zero  # noqa: E501

        :param init_bal: The init_bal of this MonteCarlo.  # noqa: E501
        :type: int
        """
        if init_bal is not None and init_bal < 0:  # noqa: E501
            raise ValueError("Invalid value for `init_bal`, must be a value greater than or equal to `0`")  # noqa: E501

        self._init_bal = init_bal

    @property
    def n(self):
        """Gets the n of this MonteCarlo.  # noqa: E501

        The number of simulations to run  # noqa: E501

        :return: The n of this MonteCarlo.  # noqa: E501
        :rtype: int
        """
        return self._n

    @n.setter
    def n(self, n):
        """Sets the n of this MonteCarlo.

        The number of simulations to run  # noqa: E501

        :param n: The n of this MonteCarlo.  # noqa: E501
        :type: int
        """
        if n is not None and n <= 0:  # noqa: E501
            raise ValueError("Invalid value for `n`, must be a value greater than `0`")  # noqa: E501

        self._n = n

    @property
    def remove_outliers(self):
        """Gets the remove_outliers of this MonteCarlo.  # noqa: E501

        If true, remove outlying results  # noqa: E501

        :return: The remove_outliers of this MonteCarlo.  # noqa: E501
        :rtype: bool
        """
        return self._remove_outliers

    @remove_outliers.setter
    def remove_outliers(self, remove_outliers):
        """Sets the remove_outliers of this MonteCarlo.

        If true, remove outlying results  # noqa: E501

        :param remove_outliers: The remove_outliers of this MonteCarlo.  # noqa: E501
        :type: bool
        """

        self._remove_outliers = remove_outliers

    @property
    def result_type(self):
        """Gets the result_type of this MonteCarlo.  # noqa: E501

        The type of simulation results to display in the output  # noqa: E501

        :return: The result_type of this MonteCarlo.  # noqa: E501
        :rtype: str
        """
        return self._result_type

    @result_type.setter
    def result_type(self, result_type):
        """Sets the result_type of this MonteCarlo.

        The type of simulation results to display in the output  # noqa: E501

        :param result_type: The result_type of this MonteCarlo.  # noqa: E501
        :type: str
        """
        allowed_values = ["raw", "mean", "median", "percentiles", "custom"]  # noqa: E501
        if result_type not in allowed_values:
            raise ValueError(
                "Invalid value for `result_type` ({0}), must be one of {1}"  # noqa: E501
                .format(result_type, allowed_values)
            )

        self._result_type = result_type

    @property
    def p(self):
        """Gets the p of this MonteCarlo.  # noqa: E501

        Custom result percentiles  # noqa: E501

        :return: The p of this MonteCarlo.  # noqa: E501
        :rtype: list[float]
        """
        return self._p

    @p.setter
    def p(self, p):
        """Sets the p of this MonteCarlo.

        Custom result percentiles  # noqa: E501

        :param p: The p of this MonteCarlo.  # noqa: E501
        :type: list[float]
        """

        self._p = p

    @property
    def min_bal(self):
        """Gets the min_bal of this MonteCarlo.  # noqa: E501

        A lower bound to enforce on the periodic balance. Each item in the array corresponds to a period in the simulation. If the length of the array is less than the number of simulation periods, it is conformed to the appropriate length by persisting the final value in the array.  # noqa: E501

        :return: The min_bal of this MonteCarlo.  # noqa: E501
        :rtype: list[float]
        """
        return self._min_bal

    @min_bal.setter
    def min_bal(self, min_bal):
        """Sets the min_bal of this MonteCarlo.

        A lower bound to enforce on the periodic balance. Each item in the array corresponds to a period in the simulation. If the length of the array is less than the number of simulation periods, it is conformed to the appropriate length by persisting the final value in the array.  # noqa: E501

        :param min_bal: The min_bal of this MonteCarlo.  # noqa: E501
        :type: list[float]
        """

        self._min_bal = min_bal

    @property
    def max_bal(self):
        """Gets the max_bal of this MonteCarlo.  # noqa: E501

        An upper bound to enforce on the periodic balance. Each item in the array corresponds to a period in the simulation. If the length of the array is less than the number of simulation periods, it is conformed to the appropriate length by persisting the final value in the array.  # noqa: E501

        :return: The max_bal of this MonteCarlo.  # noqa: E501
        :rtype: list[float]
        """
        return self._max_bal

    @max_bal.setter
    def max_bal(self, max_bal):
        """Sets the max_bal of this MonteCarlo.

        An upper bound to enforce on the periodic balance. Each item in the array corresponds to a period in the simulation. If the length of the array is less than the number of simulation periods, it is conformed to the appropriate length by persisting the final value in the array.  # noqa: E501

        :param max_bal: The max_bal of this MonteCarlo.  # noqa: E501
        :type: list[float]
        """

        self._max_bal = max_bal

    @property
    def min_sample(self):
        """Gets the min_sample of this MonteCarlo.  # noqa: E501

        A lower bound to enforce on the randomly sampled periodic return. Each item in the array corresponds to a period in the simulation. If the length of the array is less than the number of simulation periods, it is conformed to the appropriate length by persisting the final value in the array.  # noqa: E501

        :return: The min_sample of this MonteCarlo.  # noqa: E501
        :rtype: list[float]
        """
        return self._min_sample

    @min_sample.setter
    def min_sample(self, min_sample):
        """Sets the min_sample of this MonteCarlo.

        A lower bound to enforce on the randomly sampled periodic return. Each item in the array corresponds to a period in the simulation. If the length of the array is less than the number of simulation periods, it is conformed to the appropriate length by persisting the final value in the array.  # noqa: E501

        :param min_sample: The min_sample of this MonteCarlo.  # noqa: E501
        :type: list[float]
        """

        self._min_sample = min_sample

    @property
    def max_sample(self):
        """Gets the max_sample of this MonteCarlo.  # noqa: E501

        An upper bound to enforce on the randomly sampled periodic return. Each item in the array corresponds to a period in the simulation. If the length of the array is less than the number of simulation periods, it is conformed to the appropriate length by persisting the final value in the array.  # noqa: E501

        :return: The max_sample of this MonteCarlo.  # noqa: E501
        :rtype: list[float]
        """
        return self._max_sample

    @max_sample.setter
    def max_sample(self, max_sample):
        """Sets the max_sample of this MonteCarlo.

        An upper bound to enforce on the randomly sampled periodic return. Each item in the array corresponds to a period in the simulation. If the length of the array is less than the number of simulation periods, it is conformed to the appropriate length by persisting the final value in the array.  # noqa: E501

        :param max_sample: The max_sample of this MonteCarlo.  # noqa: E501
        :type: list[float]
        """

        self._max_sample = max_sample

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(MonteCarlo, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, MonteCarlo):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
