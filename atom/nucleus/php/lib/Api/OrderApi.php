<?php
/**
 * OrderApi
 * PHP version 5
 *
 * @category Class
 * @package  com\hydrogen\nucleus
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Hydrogen Nucleus API
 *
 * The Hydrogen Nucleus API
 *
 * OpenAPI spec version: 1.9.5
 * Contact: info@hydrogenplatform.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.19
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace com\hydrogen\nucleus\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use com\hydrogen\nucleus\ApiException;
use com\hydrogen\nucleus\Configuration;
use com\hydrogen\nucleus\HeaderSelector;
use com\hydrogen\nucleus\ObjectSerializer;

/**
 * OrderApi Class Doc Comment
 *
 * @category Class
 * @package  com\hydrogen\nucleus
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class OrderApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createAccountOrderBulkUsingPost
     *
     * Bulk orders for an account
     *
     * @param  string $account_id account_id (required)
     * @param  \com\hydrogen\nucleus\Model\TokenDateRequest $req req (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com\hydrogen\nucleus\Model\Order[]
     */
    public function createAccountOrderBulkUsingPost($account_id, $req)
    {
        list($response) = $this->createAccountOrderBulkUsingPostWithHttpInfo($account_id, $req);
        return $response;
    }

    /**
     * Operation createAccountOrderBulkUsingPostWithHttpInfo
     *
     * Bulk orders for an account
     *
     * @param  string $account_id account_id (required)
     * @param  \com\hydrogen\nucleus\Model\TokenDateRequest $req req (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com\hydrogen\nucleus\Model\Order[], HTTP status code, HTTP response headers (array of strings)
     */
    public function createAccountOrderBulkUsingPostWithHttpInfo($account_id, $req)
    {
        $returnType = '\com\hydrogen\nucleus\Model\Order[]';
        $request = $this->createAccountOrderBulkUsingPostRequest($account_id, $req);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com\hydrogen\nucleus\Model\Order[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAccountOrderBulkUsingPostAsync
     *
     * Bulk orders for an account
     *
     * @param  string $account_id account_id (required)
     * @param  \com\hydrogen\nucleus\Model\TokenDateRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAccountOrderBulkUsingPostAsync($account_id, $req)
    {
        return $this->createAccountOrderBulkUsingPostAsyncWithHttpInfo($account_id, $req)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAccountOrderBulkUsingPostAsyncWithHttpInfo
     *
     * Bulk orders for an account
     *
     * @param  string $account_id account_id (required)
     * @param  \com\hydrogen\nucleus\Model\TokenDateRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAccountOrderBulkUsingPostAsyncWithHttpInfo($account_id, $req)
    {
        $returnType = '\com\hydrogen\nucleus\Model\Order[]';
        $request = $this->createAccountOrderBulkUsingPostRequest($account_id, $req);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAccountOrderBulkUsingPost'
     *
     * @param  string $account_id account_id (required)
     * @param  \com\hydrogen\nucleus\Model\TokenDateRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createAccountOrderBulkUsingPostRequest($account_id, $req)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling createAccountOrderBulkUsingPost'
            );
        }
        // verify the required parameter 'req' is set
        if ($req === null || (is_array($req) && count($req) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $req when calling createAccountOrderBulkUsingPost'
            );
        }

        $resourcePath = '/nucleus/v1/account/{account_id}/order_bulk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'account_id' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($req)) {
            $_tempBody = $req;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAccountOrderBuyOnlyUsingPost
     *
     * Create buy-only account rebalance orders
     *
     * @param  string $account_id account_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com\hydrogen\nucleus\Model\OrderVoClone[]
     */
    public function createAccountOrderBuyOnlyUsingPost($account_id, $req)
    {
        list($response) = $this->createAccountOrderBuyOnlyUsingPostWithHttpInfo($account_id, $req);
        return $response;
    }

    /**
     * Operation createAccountOrderBuyOnlyUsingPostWithHttpInfo
     *
     * Create buy-only account rebalance orders
     *
     * @param  string $account_id account_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com\hydrogen\nucleus\Model\OrderVoClone[], HTTP status code, HTTP response headers (array of strings)
     */
    public function createAccountOrderBuyOnlyUsingPostWithHttpInfo($account_id, $req)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderVoClone[]';
        $request = $this->createAccountOrderBuyOnlyUsingPostRequest($account_id, $req);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com\hydrogen\nucleus\Model\OrderVoClone[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAccountOrderBuyOnlyUsingPostAsync
     *
     * Create buy-only account rebalance orders
     *
     * @param  string $account_id account_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAccountOrderBuyOnlyUsingPostAsync($account_id, $req)
    {
        return $this->createAccountOrderBuyOnlyUsingPostAsyncWithHttpInfo($account_id, $req)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAccountOrderBuyOnlyUsingPostAsyncWithHttpInfo
     *
     * Create buy-only account rebalance orders
     *
     * @param  string $account_id account_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAccountOrderBuyOnlyUsingPostAsyncWithHttpInfo($account_id, $req)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderVoClone[]';
        $request = $this->createAccountOrderBuyOnlyUsingPostRequest($account_id, $req);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAccountOrderBuyOnlyUsingPost'
     *
     * @param  string $account_id account_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createAccountOrderBuyOnlyUsingPostRequest($account_id, $req)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling createAccountOrderBuyOnlyUsingPost'
            );
        }
        // verify the required parameter 'req' is set
        if ($req === null || (is_array($req) && count($req) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $req when calling createAccountOrderBuyOnlyUsingPost'
            );
        }

        $resourcePath = '/nucleus/v1/account/{account_id}/order_buy_only';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'account_id' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($req)) {
            $_tempBody = $req;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAccountOrderRebalanceUsingPost
     *
     * Create account rebalance orders
     *
     * @param  string $account_id account_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com\hydrogen\nucleus\Model\OrderVoClone[]
     */
    public function createAccountOrderRebalanceUsingPost($account_id, $req)
    {
        list($response) = $this->createAccountOrderRebalanceUsingPostWithHttpInfo($account_id, $req);
        return $response;
    }

    /**
     * Operation createAccountOrderRebalanceUsingPostWithHttpInfo
     *
     * Create account rebalance orders
     *
     * @param  string $account_id account_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com\hydrogen\nucleus\Model\OrderVoClone[], HTTP status code, HTTP response headers (array of strings)
     */
    public function createAccountOrderRebalanceUsingPostWithHttpInfo($account_id, $req)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderVoClone[]';
        $request = $this->createAccountOrderRebalanceUsingPostRequest($account_id, $req);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com\hydrogen\nucleus\Model\OrderVoClone[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAccountOrderRebalanceUsingPostAsync
     *
     * Create account rebalance orders
     *
     * @param  string $account_id account_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAccountOrderRebalanceUsingPostAsync($account_id, $req)
    {
        return $this->createAccountOrderRebalanceUsingPostAsyncWithHttpInfo($account_id, $req)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAccountOrderRebalanceUsingPostAsyncWithHttpInfo
     *
     * Create account rebalance orders
     *
     * @param  string $account_id account_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAccountOrderRebalanceUsingPostAsyncWithHttpInfo($account_id, $req)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderVoClone[]';
        $request = $this->createAccountOrderRebalanceUsingPostRequest($account_id, $req);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAccountOrderRebalanceUsingPost'
     *
     * @param  string $account_id account_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createAccountOrderRebalanceUsingPostRequest($account_id, $req)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling createAccountOrderRebalanceUsingPost'
            );
        }
        // verify the required parameter 'req' is set
        if ($req === null || (is_array($req) && count($req) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $req when calling createAccountOrderRebalanceUsingPost'
            );
        }

        $resourcePath = '/nucleus/v1/account/{account_id}/order_rebalance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'account_id' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($req)) {
            $_tempBody = $req;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAccountOrderReconciliation
     *
     * Create account reconciliation order
     *
     * @param  string $account_id account_id (required)
     * @param  \com\hydrogen\nucleus\Model\OrderReconcileRequest $req req (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com\hydrogen\nucleus\Model\OrderReconcileReturnObject
     */
    public function createAccountOrderReconciliation($account_id, $req)
    {
        list($response) = $this->createAccountOrderReconciliationWithHttpInfo($account_id, $req);
        return $response;
    }

    /**
     * Operation createAccountOrderReconciliationWithHttpInfo
     *
     * Create account reconciliation order
     *
     * @param  string $account_id account_id (required)
     * @param  \com\hydrogen\nucleus\Model\OrderReconcileRequest $req req (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com\hydrogen\nucleus\Model\OrderReconcileReturnObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAccountOrderReconciliationWithHttpInfo($account_id, $req)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderReconcileReturnObject';
        $request = $this->createAccountOrderReconciliationRequest($account_id, $req);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com\hydrogen\nucleus\Model\OrderReconcileReturnObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAccountOrderReconciliationAsync
     *
     * Create account reconciliation order
     *
     * @param  string $account_id account_id (required)
     * @param  \com\hydrogen\nucleus\Model\OrderReconcileRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAccountOrderReconciliationAsync($account_id, $req)
    {
        return $this->createAccountOrderReconciliationAsyncWithHttpInfo($account_id, $req)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAccountOrderReconciliationAsyncWithHttpInfo
     *
     * Create account reconciliation order
     *
     * @param  string $account_id account_id (required)
     * @param  \com\hydrogen\nucleus\Model\OrderReconcileRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAccountOrderReconciliationAsyncWithHttpInfo($account_id, $req)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderReconcileReturnObject';
        $request = $this->createAccountOrderReconciliationRequest($account_id, $req);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAccountOrderReconciliation'
     *
     * @param  string $account_id account_id (required)
     * @param  \com\hydrogen\nucleus\Model\OrderReconcileRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createAccountOrderReconciliationRequest($account_id, $req)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling createAccountOrderReconciliation'
            );
        }
        // verify the required parameter 'req' is set
        if ($req === null || (is_array($req) && count($req) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $req when calling createAccountOrderReconciliation'
            );
        }

        $resourcePath = '/nucleus/v1/account/{account_id}/order_reconciliation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'account_id' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($req)) {
            $_tempBody = $req;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAccountOrderSellAllUsingPost
     *
     * Sell all account order
     *
     * @param  string $account_id account_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com\hydrogen\nucleus\Model\OrderVoClone[]
     */
    public function createAccountOrderSellAllUsingPost($account_id, $req)
    {
        list($response) = $this->createAccountOrderSellAllUsingPostWithHttpInfo($account_id, $req);
        return $response;
    }

    /**
     * Operation createAccountOrderSellAllUsingPostWithHttpInfo
     *
     * Sell all account order
     *
     * @param  string $account_id account_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com\hydrogen\nucleus\Model\OrderVoClone[], HTTP status code, HTTP response headers (array of strings)
     */
    public function createAccountOrderSellAllUsingPostWithHttpInfo($account_id, $req)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderVoClone[]';
        $request = $this->createAccountOrderSellAllUsingPostRequest($account_id, $req);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com\hydrogen\nucleus\Model\OrderVoClone[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAccountOrderSellAllUsingPostAsync
     *
     * Sell all account order
     *
     * @param  string $account_id account_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAccountOrderSellAllUsingPostAsync($account_id, $req)
    {
        return $this->createAccountOrderSellAllUsingPostAsyncWithHttpInfo($account_id, $req)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAccountOrderSellAllUsingPostAsyncWithHttpInfo
     *
     * Sell all account order
     *
     * @param  string $account_id account_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAccountOrderSellAllUsingPostAsyncWithHttpInfo($account_id, $req)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderVoClone[]';
        $request = $this->createAccountOrderSellAllUsingPostRequest($account_id, $req);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAccountOrderSellAllUsingPost'
     *
     * @param  string $account_id account_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createAccountOrderSellAllUsingPostRequest($account_id, $req)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling createAccountOrderSellAllUsingPost'
            );
        }
        // verify the required parameter 'req' is set
        if ($req === null || (is_array($req) && count($req) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $req when calling createAccountOrderSellAllUsingPost'
            );
        }

        $resourcePath = '/nucleus/v1/account/{account_id}/order_sell_all';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'account_id' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($req)) {
            $_tempBody = $req;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAccountOrderSellOnlyUsingPost
     *
     * Create sell-only account rebalance orders
     *
     * @param  string $account_id account_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com\hydrogen\nucleus\Model\OrderVoClone[]
     */
    public function createAccountOrderSellOnlyUsingPost($account_id, $req)
    {
        list($response) = $this->createAccountOrderSellOnlyUsingPostWithHttpInfo($account_id, $req);
        return $response;
    }

    /**
     * Operation createAccountOrderSellOnlyUsingPostWithHttpInfo
     *
     * Create sell-only account rebalance orders
     *
     * @param  string $account_id account_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com\hydrogen\nucleus\Model\OrderVoClone[], HTTP status code, HTTP response headers (array of strings)
     */
    public function createAccountOrderSellOnlyUsingPostWithHttpInfo($account_id, $req)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderVoClone[]';
        $request = $this->createAccountOrderSellOnlyUsingPostRequest($account_id, $req);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com\hydrogen\nucleus\Model\OrderVoClone[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAccountOrderSellOnlyUsingPostAsync
     *
     * Create sell-only account rebalance orders
     *
     * @param  string $account_id account_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAccountOrderSellOnlyUsingPostAsync($account_id, $req)
    {
        return $this->createAccountOrderSellOnlyUsingPostAsyncWithHttpInfo($account_id, $req)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAccountOrderSellOnlyUsingPostAsyncWithHttpInfo
     *
     * Create sell-only account rebalance orders
     *
     * @param  string $account_id account_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAccountOrderSellOnlyUsingPostAsyncWithHttpInfo($account_id, $req)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderVoClone[]';
        $request = $this->createAccountOrderSellOnlyUsingPostRequest($account_id, $req);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAccountOrderSellOnlyUsingPost'
     *
     * @param  string $account_id account_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createAccountOrderSellOnlyUsingPostRequest($account_id, $req)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling createAccountOrderSellOnlyUsingPost'
            );
        }
        // verify the required parameter 'req' is set
        if ($req === null || (is_array($req) && count($req) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $req when calling createAccountOrderSellOnlyUsingPost'
            );
        }

        $resourcePath = '/nucleus/v1/account/{account_id}/order_sell_only';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'account_id' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($req)) {
            $_tempBody = $req;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createClientOrderBulkUsingPost
     *
     * Bulk orders for a client
     *
     * @param  string $client_id client_id (required)
     * @param  \com\hydrogen\nucleus\Model\TokenDateRequest $req req (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com\hydrogen\nucleus\Model\Order[]
     */
    public function createClientOrderBulkUsingPost($client_id, $req)
    {
        list($response) = $this->createClientOrderBulkUsingPostWithHttpInfo($client_id, $req);
        return $response;
    }

    /**
     * Operation createClientOrderBulkUsingPostWithHttpInfo
     *
     * Bulk orders for a client
     *
     * @param  string $client_id client_id (required)
     * @param  \com\hydrogen\nucleus\Model\TokenDateRequest $req req (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com\hydrogen\nucleus\Model\Order[], HTTP status code, HTTP response headers (array of strings)
     */
    public function createClientOrderBulkUsingPostWithHttpInfo($client_id, $req)
    {
        $returnType = '\com\hydrogen\nucleus\Model\Order[]';
        $request = $this->createClientOrderBulkUsingPostRequest($client_id, $req);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com\hydrogen\nucleus\Model\Order[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createClientOrderBulkUsingPostAsync
     *
     * Bulk orders for a client
     *
     * @param  string $client_id client_id (required)
     * @param  \com\hydrogen\nucleus\Model\TokenDateRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createClientOrderBulkUsingPostAsync($client_id, $req)
    {
        return $this->createClientOrderBulkUsingPostAsyncWithHttpInfo($client_id, $req)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createClientOrderBulkUsingPostAsyncWithHttpInfo
     *
     * Bulk orders for a client
     *
     * @param  string $client_id client_id (required)
     * @param  \com\hydrogen\nucleus\Model\TokenDateRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createClientOrderBulkUsingPostAsyncWithHttpInfo($client_id, $req)
    {
        $returnType = '\com\hydrogen\nucleus\Model\Order[]';
        $request = $this->createClientOrderBulkUsingPostRequest($client_id, $req);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createClientOrderBulkUsingPost'
     *
     * @param  string $client_id client_id (required)
     * @param  \com\hydrogen\nucleus\Model\TokenDateRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createClientOrderBulkUsingPostRequest($client_id, $req)
    {
        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling createClientOrderBulkUsingPost'
            );
        }
        // verify the required parameter 'req' is set
        if ($req === null || (is_array($req) && count($req) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $req when calling createClientOrderBulkUsingPost'
            );
        }

        $resourcePath = '/nucleus/v1/client/{client_id}/order_bulk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'client_id' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($req)) {
            $_tempBody = $req;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createOrderBulkUsingPost
     *
     * Bulk orders for your firm
     *
     * @param  \com\hydrogen\nucleus\Model\TokenDateRequest $req req (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com\hydrogen\nucleus\Model\Order[]
     */
    public function createOrderBulkUsingPost($req)
    {
        list($response) = $this->createOrderBulkUsingPostWithHttpInfo($req);
        return $response;
    }

    /**
     * Operation createOrderBulkUsingPostWithHttpInfo
     *
     * Bulk orders for your firm
     *
     * @param  \com\hydrogen\nucleus\Model\TokenDateRequest $req req (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com\hydrogen\nucleus\Model\Order[], HTTP status code, HTTP response headers (array of strings)
     */
    public function createOrderBulkUsingPostWithHttpInfo($req)
    {
        $returnType = '\com\hydrogen\nucleus\Model\Order[]';
        $request = $this->createOrderBulkUsingPostRequest($req);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com\hydrogen\nucleus\Model\Order[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createOrderBulkUsingPostAsync
     *
     * Bulk orders for your firm
     *
     * @param  \com\hydrogen\nucleus\Model\TokenDateRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrderBulkUsingPostAsync($req)
    {
        return $this->createOrderBulkUsingPostAsyncWithHttpInfo($req)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createOrderBulkUsingPostAsyncWithHttpInfo
     *
     * Bulk orders for your firm
     *
     * @param  \com\hydrogen\nucleus\Model\TokenDateRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrderBulkUsingPostAsyncWithHttpInfo($req)
    {
        $returnType = '\com\hydrogen\nucleus\Model\Order[]';
        $request = $this->createOrderBulkUsingPostRequest($req);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createOrderBulkUsingPost'
     *
     * @param  \com\hydrogen\nucleus\Model\TokenDateRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createOrderBulkUsingPostRequest($req)
    {
        // verify the required parameter 'req' is set
        if ($req === null || (is_array($req) && count($req) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $req when calling createOrderBulkUsingPost'
            );
        }

        $resourcePath = '/nucleus/v1/order_bulk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($req)) {
            $_tempBody = $req;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createOrderStatusUsingPost
     *
     * Create an order status
     *
     * @param  \com\hydrogen\nucleus\Model\OrderStatus $order_status_request orderStatusRequest (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com\hydrogen\nucleus\Model\OrderStatus
     */
    public function createOrderStatusUsingPost($order_status_request)
    {
        list($response) = $this->createOrderStatusUsingPostWithHttpInfo($order_status_request);
        return $response;
    }

    /**
     * Operation createOrderStatusUsingPostWithHttpInfo
     *
     * Create an order status
     *
     * @param  \com\hydrogen\nucleus\Model\OrderStatus $order_status_request orderStatusRequest (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com\hydrogen\nucleus\Model\OrderStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function createOrderStatusUsingPostWithHttpInfo($order_status_request)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderStatus';
        $request = $this->createOrderStatusUsingPostRequest($order_status_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com\hydrogen\nucleus\Model\OrderStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createOrderStatusUsingPostAsync
     *
     * Create an order status
     *
     * @param  \com\hydrogen\nucleus\Model\OrderStatus $order_status_request orderStatusRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrderStatusUsingPostAsync($order_status_request)
    {
        return $this->createOrderStatusUsingPostAsyncWithHttpInfo($order_status_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createOrderStatusUsingPostAsyncWithHttpInfo
     *
     * Create an order status
     *
     * @param  \com\hydrogen\nucleus\Model\OrderStatus $order_status_request orderStatusRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrderStatusUsingPostAsyncWithHttpInfo($order_status_request)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderStatus';
        $request = $this->createOrderStatusUsingPostRequest($order_status_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createOrderStatusUsingPost'
     *
     * @param  \com\hydrogen\nucleus\Model\OrderStatus $order_status_request orderStatusRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createOrderStatusUsingPostRequest($order_status_request)
    {
        // verify the required parameter 'order_status_request' is set
        if ($order_status_request === null || (is_array($order_status_request) && count($order_status_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_status_request when calling createOrderStatusUsingPost'
            );
        }

        $resourcePath = '/nucleus/v1/order_status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($order_status_request)) {
            $_tempBody = $order_status_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createOrderTrackUsingPost
     *
     * Create an order tracking record
     *
     * @param  \com\hydrogen\nucleus\Model\OrderTrack $order_track_request orderTrackRequest (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com\hydrogen\nucleus\Model\OrderTrack
     */
    public function createOrderTrackUsingPost($order_track_request)
    {
        list($response) = $this->createOrderTrackUsingPostWithHttpInfo($order_track_request);
        return $response;
    }

    /**
     * Operation createOrderTrackUsingPostWithHttpInfo
     *
     * Create an order tracking record
     *
     * @param  \com\hydrogen\nucleus\Model\OrderTrack $order_track_request orderTrackRequest (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com\hydrogen\nucleus\Model\OrderTrack, HTTP status code, HTTP response headers (array of strings)
     */
    public function createOrderTrackUsingPostWithHttpInfo($order_track_request)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderTrack';
        $request = $this->createOrderTrackUsingPostRequest($order_track_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com\hydrogen\nucleus\Model\OrderTrack',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createOrderTrackUsingPostAsync
     *
     * Create an order tracking record
     *
     * @param  \com\hydrogen\nucleus\Model\OrderTrack $order_track_request orderTrackRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrderTrackUsingPostAsync($order_track_request)
    {
        return $this->createOrderTrackUsingPostAsyncWithHttpInfo($order_track_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createOrderTrackUsingPostAsyncWithHttpInfo
     *
     * Create an order tracking record
     *
     * @param  \com\hydrogen\nucleus\Model\OrderTrack $order_track_request orderTrackRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrderTrackUsingPostAsyncWithHttpInfo($order_track_request)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderTrack';
        $request = $this->createOrderTrackUsingPostRequest($order_track_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createOrderTrackUsingPost'
     *
     * @param  \com\hydrogen\nucleus\Model\OrderTrack $order_track_request orderTrackRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createOrderTrackUsingPostRequest($order_track_request)
    {
        // verify the required parameter 'order_track_request' is set
        if ($order_track_request === null || (is_array($order_track_request) && count($order_track_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_track_request when calling createOrderTrackUsingPost'
            );
        }

        $resourcePath = '/nucleus/v1/order_track';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($order_track_request)) {
            $_tempBody = $order_track_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createOrderUsingPost
     *
     * Create an order record
     *
     * @param  \com\hydrogen\nucleus\Model\Order $order_info_request orderInfoRequest (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com\hydrogen\nucleus\Model\Order
     */
    public function createOrderUsingPost($order_info_request)
    {
        list($response) = $this->createOrderUsingPostWithHttpInfo($order_info_request);
        return $response;
    }

    /**
     * Operation createOrderUsingPostWithHttpInfo
     *
     * Create an order record
     *
     * @param  \com\hydrogen\nucleus\Model\Order $order_info_request orderInfoRequest (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com\hydrogen\nucleus\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function createOrderUsingPostWithHttpInfo($order_info_request)
    {
        $returnType = '\com\hydrogen\nucleus\Model\Order';
        $request = $this->createOrderUsingPostRequest($order_info_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com\hydrogen\nucleus\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createOrderUsingPostAsync
     *
     * Create an order record
     *
     * @param  \com\hydrogen\nucleus\Model\Order $order_info_request orderInfoRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrderUsingPostAsync($order_info_request)
    {
        return $this->createOrderUsingPostAsyncWithHttpInfo($order_info_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createOrderUsingPostAsyncWithHttpInfo
     *
     * Create an order record
     *
     * @param  \com\hydrogen\nucleus\Model\Order $order_info_request orderInfoRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrderUsingPostAsyncWithHttpInfo($order_info_request)
    {
        $returnType = '\com\hydrogen\nucleus\Model\Order';
        $request = $this->createOrderUsingPostRequest($order_info_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createOrderUsingPost'
     *
     * @param  \com\hydrogen\nucleus\Model\Order $order_info_request orderInfoRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createOrderUsingPostRequest($order_info_request)
    {
        // verify the required parameter 'order_info_request' is set
        if ($order_info_request === null || (is_array($order_info_request) && count($order_info_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_info_request when calling createOrderUsingPost'
            );
        }

        $resourcePath = '/nucleus/v1/order';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($order_info_request)) {
            $_tempBody = $order_info_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createPortfolioOrderBuyOnlyUsingPost
     *
     * Create buy-only portfolio rebalance orders
     *
     * @param  string $portfolio_id portfolio_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com\hydrogen\nucleus\Model\OrderVoClone[]
     */
    public function createPortfolioOrderBuyOnlyUsingPost($portfolio_id, $req)
    {
        list($response) = $this->createPortfolioOrderBuyOnlyUsingPostWithHttpInfo($portfolio_id, $req);
        return $response;
    }

    /**
     * Operation createPortfolioOrderBuyOnlyUsingPostWithHttpInfo
     *
     * Create buy-only portfolio rebalance orders
     *
     * @param  string $portfolio_id portfolio_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com\hydrogen\nucleus\Model\OrderVoClone[], HTTP status code, HTTP response headers (array of strings)
     */
    public function createPortfolioOrderBuyOnlyUsingPostWithHttpInfo($portfolio_id, $req)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderVoClone[]';
        $request = $this->createPortfolioOrderBuyOnlyUsingPostRequest($portfolio_id, $req);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com\hydrogen\nucleus\Model\OrderVoClone[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createPortfolioOrderBuyOnlyUsingPostAsync
     *
     * Create buy-only portfolio rebalance orders
     *
     * @param  string $portfolio_id portfolio_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPortfolioOrderBuyOnlyUsingPostAsync($portfolio_id, $req)
    {
        return $this->createPortfolioOrderBuyOnlyUsingPostAsyncWithHttpInfo($portfolio_id, $req)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPortfolioOrderBuyOnlyUsingPostAsyncWithHttpInfo
     *
     * Create buy-only portfolio rebalance orders
     *
     * @param  string $portfolio_id portfolio_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPortfolioOrderBuyOnlyUsingPostAsyncWithHttpInfo($portfolio_id, $req)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderVoClone[]';
        $request = $this->createPortfolioOrderBuyOnlyUsingPostRequest($portfolio_id, $req);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createPortfolioOrderBuyOnlyUsingPost'
     *
     * @param  string $portfolio_id portfolio_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createPortfolioOrderBuyOnlyUsingPostRequest($portfolio_id, $req)
    {
        // verify the required parameter 'portfolio_id' is set
        if ($portfolio_id === null || (is_array($portfolio_id) && count($portfolio_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $portfolio_id when calling createPortfolioOrderBuyOnlyUsingPost'
            );
        }
        // verify the required parameter 'req' is set
        if ($req === null || (is_array($req) && count($req) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $req when calling createPortfolioOrderBuyOnlyUsingPost'
            );
        }

        $resourcePath = '/nucleus/v1/portfolio/{portfolio_id}/order_buy_only';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($portfolio_id !== null) {
            $resourcePath = str_replace(
                '{' . 'portfolio_id' . '}',
                ObjectSerializer::toPathValue($portfolio_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($req)) {
            $_tempBody = $req;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createPortfolioOrderRebalanceUsingPost
     *
     * Create portfolio rebalance orders
     *
     * @param  string $portfolio_id portfolio_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com\hydrogen\nucleus\Model\OrderVoClone[]
     */
    public function createPortfolioOrderRebalanceUsingPost($portfolio_id, $req)
    {
        list($response) = $this->createPortfolioOrderRebalanceUsingPostWithHttpInfo($portfolio_id, $req);
        return $response;
    }

    /**
     * Operation createPortfolioOrderRebalanceUsingPostWithHttpInfo
     *
     * Create portfolio rebalance orders
     *
     * @param  string $portfolio_id portfolio_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com\hydrogen\nucleus\Model\OrderVoClone[], HTTP status code, HTTP response headers (array of strings)
     */
    public function createPortfolioOrderRebalanceUsingPostWithHttpInfo($portfolio_id, $req)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderVoClone[]';
        $request = $this->createPortfolioOrderRebalanceUsingPostRequest($portfolio_id, $req);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com\hydrogen\nucleus\Model\OrderVoClone[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createPortfolioOrderRebalanceUsingPostAsync
     *
     * Create portfolio rebalance orders
     *
     * @param  string $portfolio_id portfolio_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPortfolioOrderRebalanceUsingPostAsync($portfolio_id, $req)
    {
        return $this->createPortfolioOrderRebalanceUsingPostAsyncWithHttpInfo($portfolio_id, $req)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPortfolioOrderRebalanceUsingPostAsyncWithHttpInfo
     *
     * Create portfolio rebalance orders
     *
     * @param  string $portfolio_id portfolio_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPortfolioOrderRebalanceUsingPostAsyncWithHttpInfo($portfolio_id, $req)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderVoClone[]';
        $request = $this->createPortfolioOrderRebalanceUsingPostRequest($portfolio_id, $req);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createPortfolioOrderRebalanceUsingPost'
     *
     * @param  string $portfolio_id portfolio_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createPortfolioOrderRebalanceUsingPostRequest($portfolio_id, $req)
    {
        // verify the required parameter 'portfolio_id' is set
        if ($portfolio_id === null || (is_array($portfolio_id) && count($portfolio_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $portfolio_id when calling createPortfolioOrderRebalanceUsingPost'
            );
        }
        // verify the required parameter 'req' is set
        if ($req === null || (is_array($req) && count($req) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $req when calling createPortfolioOrderRebalanceUsingPost'
            );
        }

        $resourcePath = '/nucleus/v1/portfolio/{portfolio_id}/order_rebalance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($portfolio_id !== null) {
            $resourcePath = str_replace(
                '{' . 'portfolio_id' . '}',
                ObjectSerializer::toPathValue($portfolio_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($req)) {
            $_tempBody = $req;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createPortfolioOrderReconciliation
     *
     * Create portfolio reconciliation order
     *
     * @param  string $portfolio_id portfolio_id (required)
     * @param  \com\hydrogen\nucleus\Model\OrderReconcileRequest $req req (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com\hydrogen\nucleus\Model\OrderReconcileReturnObject
     */
    public function createPortfolioOrderReconciliation($portfolio_id, $req)
    {
        list($response) = $this->createPortfolioOrderReconciliationWithHttpInfo($portfolio_id, $req);
        return $response;
    }

    /**
     * Operation createPortfolioOrderReconciliationWithHttpInfo
     *
     * Create portfolio reconciliation order
     *
     * @param  string $portfolio_id portfolio_id (required)
     * @param  \com\hydrogen\nucleus\Model\OrderReconcileRequest $req req (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com\hydrogen\nucleus\Model\OrderReconcileReturnObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPortfolioOrderReconciliationWithHttpInfo($portfolio_id, $req)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderReconcileReturnObject';
        $request = $this->createPortfolioOrderReconciliationRequest($portfolio_id, $req);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com\hydrogen\nucleus\Model\OrderReconcileReturnObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createPortfolioOrderReconciliationAsync
     *
     * Create portfolio reconciliation order
     *
     * @param  string $portfolio_id portfolio_id (required)
     * @param  \com\hydrogen\nucleus\Model\OrderReconcileRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPortfolioOrderReconciliationAsync($portfolio_id, $req)
    {
        return $this->createPortfolioOrderReconciliationAsyncWithHttpInfo($portfolio_id, $req)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPortfolioOrderReconciliationAsyncWithHttpInfo
     *
     * Create portfolio reconciliation order
     *
     * @param  string $portfolio_id portfolio_id (required)
     * @param  \com\hydrogen\nucleus\Model\OrderReconcileRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPortfolioOrderReconciliationAsyncWithHttpInfo($portfolio_id, $req)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderReconcileReturnObject';
        $request = $this->createPortfolioOrderReconciliationRequest($portfolio_id, $req);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createPortfolioOrderReconciliation'
     *
     * @param  string $portfolio_id portfolio_id (required)
     * @param  \com\hydrogen\nucleus\Model\OrderReconcileRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createPortfolioOrderReconciliationRequest($portfolio_id, $req)
    {
        // verify the required parameter 'portfolio_id' is set
        if ($portfolio_id === null || (is_array($portfolio_id) && count($portfolio_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $portfolio_id when calling createPortfolioOrderReconciliation'
            );
        }
        // verify the required parameter 'req' is set
        if ($req === null || (is_array($req) && count($req) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $req when calling createPortfolioOrderReconciliation'
            );
        }

        $resourcePath = '/nucleus/v1/portfolio/{portfolio_id}/order_reconciliation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($portfolio_id !== null) {
            $resourcePath = str_replace(
                '{' . 'portfolio_id' . '}',
                ObjectSerializer::toPathValue($portfolio_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($req)) {
            $_tempBody = $req;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createPortfolioOrderSellAllUsingPost
     *
     * Sell all portfolio order
     *
     * @param  string $portfolio_id portfolio_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com\hydrogen\nucleus\Model\OrderVoClone[]
     */
    public function createPortfolioOrderSellAllUsingPost($portfolio_id, $req)
    {
        list($response) = $this->createPortfolioOrderSellAllUsingPostWithHttpInfo($portfolio_id, $req);
        return $response;
    }

    /**
     * Operation createPortfolioOrderSellAllUsingPostWithHttpInfo
     *
     * Sell all portfolio order
     *
     * @param  string $portfolio_id portfolio_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com\hydrogen\nucleus\Model\OrderVoClone[], HTTP status code, HTTP response headers (array of strings)
     */
    public function createPortfolioOrderSellAllUsingPostWithHttpInfo($portfolio_id, $req)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderVoClone[]';
        $request = $this->createPortfolioOrderSellAllUsingPostRequest($portfolio_id, $req);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com\hydrogen\nucleus\Model\OrderVoClone[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createPortfolioOrderSellAllUsingPostAsync
     *
     * Sell all portfolio order
     *
     * @param  string $portfolio_id portfolio_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPortfolioOrderSellAllUsingPostAsync($portfolio_id, $req)
    {
        return $this->createPortfolioOrderSellAllUsingPostAsyncWithHttpInfo($portfolio_id, $req)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPortfolioOrderSellAllUsingPostAsyncWithHttpInfo
     *
     * Sell all portfolio order
     *
     * @param  string $portfolio_id portfolio_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPortfolioOrderSellAllUsingPostAsyncWithHttpInfo($portfolio_id, $req)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderVoClone[]';
        $request = $this->createPortfolioOrderSellAllUsingPostRequest($portfolio_id, $req);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createPortfolioOrderSellAllUsingPost'
     *
     * @param  string $portfolio_id portfolio_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createPortfolioOrderSellAllUsingPostRequest($portfolio_id, $req)
    {
        // verify the required parameter 'portfolio_id' is set
        if ($portfolio_id === null || (is_array($portfolio_id) && count($portfolio_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $portfolio_id when calling createPortfolioOrderSellAllUsingPost'
            );
        }
        // verify the required parameter 'req' is set
        if ($req === null || (is_array($req) && count($req) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $req when calling createPortfolioOrderSellAllUsingPost'
            );
        }

        $resourcePath = '/nucleus/v1/portfolio/{portfolio_id}/order_sell_all';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($portfolio_id !== null) {
            $resourcePath = str_replace(
                '{' . 'portfolio_id' . '}',
                ObjectSerializer::toPathValue($portfolio_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($req)) {
            $_tempBody = $req;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createPortfolioOrderSellOnlyUsingPost
     *
     * Create sell-only portfolio rebalance orders
     *
     * @param  string $portfolio_id portfolio_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com\hydrogen\nucleus\Model\OrderVoClone[]
     */
    public function createPortfolioOrderSellOnlyUsingPost($portfolio_id, $req)
    {
        list($response) = $this->createPortfolioOrderSellOnlyUsingPostWithHttpInfo($portfolio_id, $req);
        return $response;
    }

    /**
     * Operation createPortfolioOrderSellOnlyUsingPostWithHttpInfo
     *
     * Create sell-only portfolio rebalance orders
     *
     * @param  string $portfolio_id portfolio_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com\hydrogen\nucleus\Model\OrderVoClone[], HTTP status code, HTTP response headers (array of strings)
     */
    public function createPortfolioOrderSellOnlyUsingPostWithHttpInfo($portfolio_id, $req)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderVoClone[]';
        $request = $this->createPortfolioOrderSellOnlyUsingPostRequest($portfolio_id, $req);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com\hydrogen\nucleus\Model\OrderVoClone[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createPortfolioOrderSellOnlyUsingPostAsync
     *
     * Create sell-only portfolio rebalance orders
     *
     * @param  string $portfolio_id portfolio_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPortfolioOrderSellOnlyUsingPostAsync($portfolio_id, $req)
    {
        return $this->createPortfolioOrderSellOnlyUsingPostAsyncWithHttpInfo($portfolio_id, $req)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPortfolioOrderSellOnlyUsingPostAsyncWithHttpInfo
     *
     * Create sell-only portfolio rebalance orders
     *
     * @param  string $portfolio_id portfolio_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPortfolioOrderSellOnlyUsingPostAsyncWithHttpInfo($portfolio_id, $req)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderVoClone[]';
        $request = $this->createPortfolioOrderSellOnlyUsingPostRequest($portfolio_id, $req);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createPortfolioOrderSellOnlyUsingPost'
     *
     * @param  string $portfolio_id portfolio_id (required)
     * @param  \com\hydrogen\nucleus\Model\AccountPortfolioRebalanceRequest $req req (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createPortfolioOrderSellOnlyUsingPostRequest($portfolio_id, $req)
    {
        // verify the required parameter 'portfolio_id' is set
        if ($portfolio_id === null || (is_array($portfolio_id) && count($portfolio_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $portfolio_id when calling createPortfolioOrderSellOnlyUsingPost'
            );
        }
        // verify the required parameter 'req' is set
        if ($req === null || (is_array($req) && count($req) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $req when calling createPortfolioOrderSellOnlyUsingPost'
            );
        }

        $resourcePath = '/nucleus/v1/portfolio/{portfolio_id}/order_sell_only';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($portfolio_id !== null) {
            $resourcePath = str_replace(
                '{' . 'portfolio_id' . '}',
                ObjectSerializer::toPathValue($portfolio_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($req)) {
            $_tempBody = $req;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteOrderStatusUsingDelete
     *
     * Delete an order status
     *
     * @param  string $order_status_id UUID order_status_id (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteOrderStatusUsingDelete($order_status_id)
    {
        $this->deleteOrderStatusUsingDeleteWithHttpInfo($order_status_id);
    }

    /**
     * Operation deleteOrderStatusUsingDeleteWithHttpInfo
     *
     * Delete an order status
     *
     * @param  string $order_status_id UUID order_status_id (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteOrderStatusUsingDeleteWithHttpInfo($order_status_id)
    {
        $returnType = '';
        $request = $this->deleteOrderStatusUsingDeleteRequest($order_status_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteOrderStatusUsingDeleteAsync
     *
     * Delete an order status
     *
     * @param  string $order_status_id UUID order_status_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteOrderStatusUsingDeleteAsync($order_status_id)
    {
        return $this->deleteOrderStatusUsingDeleteAsyncWithHttpInfo($order_status_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteOrderStatusUsingDeleteAsyncWithHttpInfo
     *
     * Delete an order status
     *
     * @param  string $order_status_id UUID order_status_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteOrderStatusUsingDeleteAsyncWithHttpInfo($order_status_id)
    {
        $returnType = '';
        $request = $this->deleteOrderStatusUsingDeleteRequest($order_status_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteOrderStatusUsingDelete'
     *
     * @param  string $order_status_id UUID order_status_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteOrderStatusUsingDeleteRequest($order_status_id)
    {
        // verify the required parameter 'order_status_id' is set
        if ($order_status_id === null || (is_array($order_status_id) && count($order_status_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_status_id when calling deleteOrderStatusUsingDelete'
            );
        }

        $resourcePath = '/nucleus/v1/order_status/{order_status_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($order_status_id !== null) {
            $resourcePath = str_replace(
                '{' . 'order_status_id' . '}',
                ObjectSerializer::toPathValue($order_status_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteOrderTrackUsingDelete
     *
     * Delete an order tracking record
     *
     * @param  string $order_track_id UUID order_track_id (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteOrderTrackUsingDelete($order_track_id)
    {
        $this->deleteOrderTrackUsingDeleteWithHttpInfo($order_track_id);
    }

    /**
     * Operation deleteOrderTrackUsingDeleteWithHttpInfo
     *
     * Delete an order tracking record
     *
     * @param  string $order_track_id UUID order_track_id (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteOrderTrackUsingDeleteWithHttpInfo($order_track_id)
    {
        $returnType = '';
        $request = $this->deleteOrderTrackUsingDeleteRequest($order_track_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteOrderTrackUsingDeleteAsync
     *
     * Delete an order tracking record
     *
     * @param  string $order_track_id UUID order_track_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteOrderTrackUsingDeleteAsync($order_track_id)
    {
        return $this->deleteOrderTrackUsingDeleteAsyncWithHttpInfo($order_track_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteOrderTrackUsingDeleteAsyncWithHttpInfo
     *
     * Delete an order tracking record
     *
     * @param  string $order_track_id UUID order_track_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteOrderTrackUsingDeleteAsyncWithHttpInfo($order_track_id)
    {
        $returnType = '';
        $request = $this->deleteOrderTrackUsingDeleteRequest($order_track_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteOrderTrackUsingDelete'
     *
     * @param  string $order_track_id UUID order_track_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteOrderTrackUsingDeleteRequest($order_track_id)
    {
        // verify the required parameter 'order_track_id' is set
        if ($order_track_id === null || (is_array($order_track_id) && count($order_track_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_track_id when calling deleteOrderTrackUsingDelete'
            );
        }

        $resourcePath = '/nucleus/v1/order_track/{order_track_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($order_track_id !== null) {
            $resourcePath = str_replace(
                '{' . 'order_track_id' . '}',
                ObjectSerializer::toPathValue($order_track_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteOrderUsingDelete
     *
     * Delete an order record
     *
     * @param  string $order_id UUID order_id (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteOrderUsingDelete($order_id)
    {
        $this->deleteOrderUsingDeleteWithHttpInfo($order_id);
    }

    /**
     * Operation deleteOrderUsingDeleteWithHttpInfo
     *
     * Delete an order record
     *
     * @param  string $order_id UUID order_id (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteOrderUsingDeleteWithHttpInfo($order_id)
    {
        $returnType = '';
        $request = $this->deleteOrderUsingDeleteRequest($order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteOrderUsingDeleteAsync
     *
     * Delete an order record
     *
     * @param  string $order_id UUID order_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteOrderUsingDeleteAsync($order_id)
    {
        return $this->deleteOrderUsingDeleteAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteOrderUsingDeleteAsyncWithHttpInfo
     *
     * Delete an order record
     *
     * @param  string $order_id UUID order_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteOrderUsingDeleteAsyncWithHttpInfo($order_id)
    {
        $returnType = '';
        $request = $this->deleteOrderUsingDeleteRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteOrderUsingDelete'
     *
     * @param  string $order_id UUID order_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteOrderUsingDeleteRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling deleteOrderUsingDelete'
            );
        }

        $resourcePath = '/nucleus/v1/order/{order_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'order_id' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrderAllUsingGet
     *
     * List all order records
     *
     * @param  bool $ascending ascending (optional, default to false)
     * @param  string $filter filter (optional)
     * @param  string $order_by order_by (optional, default to update_date)
     * @param  int $page page (optional, default to 0)
     * @param  int $size size (optional, default to 25)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com\hydrogen\nucleus\Model\PageOrder_
     */
    public function getOrderAllUsingGet($ascending = 'false', $filter = null, $order_by = 'update_date', $page = '0', $size = '25')
    {
        list($response) = $this->getOrderAllUsingGetWithHttpInfo($ascending, $filter, $order_by, $page, $size);
        return $response;
    }

    /**
     * Operation getOrderAllUsingGetWithHttpInfo
     *
     * List all order records
     *
     * @param  bool $ascending ascending (optional, default to false)
     * @param  string $filter filter (optional)
     * @param  string $order_by order_by (optional, default to update_date)
     * @param  int $page page (optional, default to 0)
     * @param  int $size size (optional, default to 25)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com\hydrogen\nucleus\Model\PageOrder_, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrderAllUsingGetWithHttpInfo($ascending = 'false', $filter = null, $order_by = 'update_date', $page = '0', $size = '25')
    {
        $returnType = '\com\hydrogen\nucleus\Model\PageOrder_';
        $request = $this->getOrderAllUsingGetRequest($ascending, $filter, $order_by, $page, $size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com\hydrogen\nucleus\Model\PageOrder_',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrderAllUsingGetAsync
     *
     * List all order records
     *
     * @param  bool $ascending ascending (optional, default to false)
     * @param  string $filter filter (optional)
     * @param  string $order_by order_by (optional, default to update_date)
     * @param  int $page page (optional, default to 0)
     * @param  int $size size (optional, default to 25)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderAllUsingGetAsync($ascending = 'false', $filter = null, $order_by = 'update_date', $page = '0', $size = '25')
    {
        return $this->getOrderAllUsingGetAsyncWithHttpInfo($ascending, $filter, $order_by, $page, $size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrderAllUsingGetAsyncWithHttpInfo
     *
     * List all order records
     *
     * @param  bool $ascending ascending (optional, default to false)
     * @param  string $filter filter (optional)
     * @param  string $order_by order_by (optional, default to update_date)
     * @param  int $page page (optional, default to 0)
     * @param  int $size size (optional, default to 25)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderAllUsingGetAsyncWithHttpInfo($ascending = 'false', $filter = null, $order_by = 'update_date', $page = '0', $size = '25')
    {
        $returnType = '\com\hydrogen\nucleus\Model\PageOrder_';
        $request = $this->getOrderAllUsingGetRequest($ascending, $filter, $order_by, $page, $size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrderAllUsingGet'
     *
     * @param  bool $ascending ascending (optional, default to false)
     * @param  string $filter filter (optional)
     * @param  string $order_by order_by (optional, default to update_date)
     * @param  int $page page (optional, default to 0)
     * @param  int $size size (optional, default to 25)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOrderAllUsingGetRequest($ascending = 'false', $filter = null, $order_by = 'update_date', $page = '0', $size = '25')
    {

        $resourcePath = '/nucleus/v1/order';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($ascending !== null) {
            $queryParams['ascending'] = ObjectSerializer::toQueryValue($ascending);
        }
        // query params
        if ($filter !== null) {
            $queryParams['filter'] = ObjectSerializer::toQueryValue($filter);
        }
        // query params
        if ($order_by !== null) {
            $queryParams['order_by'] = ObjectSerializer::toQueryValue($order_by);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrderBulkAllUsingGet
     *
     * List all bulk orders
     *
     * @param  bool $ascending ascending (optional, default to true)
     * @param  string $filter filter (optional)
     * @param  string $order_by order_by (optional, default to order_bulk_id)
     * @param  int $page page (optional, default to 0)
     * @param  int $size size (optional, default to 25)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com\hydrogen\nucleus\Model\PageOrderBulk_
     */
    public function getOrderBulkAllUsingGet($ascending = 'true', $filter = null, $order_by = 'order_bulk_id', $page = '0', $size = '25')
    {
        list($response) = $this->getOrderBulkAllUsingGetWithHttpInfo($ascending, $filter, $order_by, $page, $size);
        return $response;
    }

    /**
     * Operation getOrderBulkAllUsingGetWithHttpInfo
     *
     * List all bulk orders
     *
     * @param  bool $ascending ascending (optional, default to true)
     * @param  string $filter filter (optional)
     * @param  string $order_by order_by (optional, default to order_bulk_id)
     * @param  int $page page (optional, default to 0)
     * @param  int $size size (optional, default to 25)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com\hydrogen\nucleus\Model\PageOrderBulk_, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrderBulkAllUsingGetWithHttpInfo($ascending = 'true', $filter = null, $order_by = 'order_bulk_id', $page = '0', $size = '25')
    {
        $returnType = '\com\hydrogen\nucleus\Model\PageOrderBulk_';
        $request = $this->getOrderBulkAllUsingGetRequest($ascending, $filter, $order_by, $page, $size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com\hydrogen\nucleus\Model\PageOrderBulk_',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrderBulkAllUsingGetAsync
     *
     * List all bulk orders
     *
     * @param  bool $ascending ascending (optional, default to true)
     * @param  string $filter filter (optional)
     * @param  string $order_by order_by (optional, default to order_bulk_id)
     * @param  int $page page (optional, default to 0)
     * @param  int $size size (optional, default to 25)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderBulkAllUsingGetAsync($ascending = 'true', $filter = null, $order_by = 'order_bulk_id', $page = '0', $size = '25')
    {
        return $this->getOrderBulkAllUsingGetAsyncWithHttpInfo($ascending, $filter, $order_by, $page, $size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrderBulkAllUsingGetAsyncWithHttpInfo
     *
     * List all bulk orders
     *
     * @param  bool $ascending ascending (optional, default to true)
     * @param  string $filter filter (optional)
     * @param  string $order_by order_by (optional, default to order_bulk_id)
     * @param  int $page page (optional, default to 0)
     * @param  int $size size (optional, default to 25)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderBulkAllUsingGetAsyncWithHttpInfo($ascending = 'true', $filter = null, $order_by = 'order_bulk_id', $page = '0', $size = '25')
    {
        $returnType = '\com\hydrogen\nucleus\Model\PageOrderBulk_';
        $request = $this->getOrderBulkAllUsingGetRequest($ascending, $filter, $order_by, $page, $size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrderBulkAllUsingGet'
     *
     * @param  bool $ascending ascending (optional, default to true)
     * @param  string $filter filter (optional)
     * @param  string $order_by order_by (optional, default to order_bulk_id)
     * @param  int $page page (optional, default to 0)
     * @param  int $size size (optional, default to 25)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOrderBulkAllUsingGetRequest($ascending = 'true', $filter = null, $order_by = 'order_bulk_id', $page = '0', $size = '25')
    {

        $resourcePath = '/nucleus/v1/order_bulk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($ascending !== null) {
            $queryParams['ascending'] = ObjectSerializer::toQueryValue($ascending);
        }
        // query params
        if ($filter !== null) {
            $queryParams['filter'] = ObjectSerializer::toQueryValue($filter);
        }
        // query params
        if ($order_by !== null) {
            $queryParams['order_by'] = ObjectSerializer::toQueryValue($order_by);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrderStatusAllUsingGet
     *
     * List all order statuses
     *
     * @param  bool $ascending ascending (optional, default to false)
     * @param  string $filter filter (optional)
     * @param  string $order_by order_by (optional, default to update_date)
     * @param  int $page page (optional, default to 0)
     * @param  int $size size (optional, default to 25)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com\hydrogen\nucleus\Model\PageOrderStatus_
     */
    public function getOrderStatusAllUsingGet($ascending = 'false', $filter = null, $order_by = 'update_date', $page = '0', $size = '25')
    {
        list($response) = $this->getOrderStatusAllUsingGetWithHttpInfo($ascending, $filter, $order_by, $page, $size);
        return $response;
    }

    /**
     * Operation getOrderStatusAllUsingGetWithHttpInfo
     *
     * List all order statuses
     *
     * @param  bool $ascending ascending (optional, default to false)
     * @param  string $filter filter (optional)
     * @param  string $order_by order_by (optional, default to update_date)
     * @param  int $page page (optional, default to 0)
     * @param  int $size size (optional, default to 25)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com\hydrogen\nucleus\Model\PageOrderStatus_, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrderStatusAllUsingGetWithHttpInfo($ascending = 'false', $filter = null, $order_by = 'update_date', $page = '0', $size = '25')
    {
        $returnType = '\com\hydrogen\nucleus\Model\PageOrderStatus_';
        $request = $this->getOrderStatusAllUsingGetRequest($ascending, $filter, $order_by, $page, $size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com\hydrogen\nucleus\Model\PageOrderStatus_',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrderStatusAllUsingGetAsync
     *
     * List all order statuses
     *
     * @param  bool $ascending ascending (optional, default to false)
     * @param  string $filter filter (optional)
     * @param  string $order_by order_by (optional, default to update_date)
     * @param  int $page page (optional, default to 0)
     * @param  int $size size (optional, default to 25)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderStatusAllUsingGetAsync($ascending = 'false', $filter = null, $order_by = 'update_date', $page = '0', $size = '25')
    {
        return $this->getOrderStatusAllUsingGetAsyncWithHttpInfo($ascending, $filter, $order_by, $page, $size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrderStatusAllUsingGetAsyncWithHttpInfo
     *
     * List all order statuses
     *
     * @param  bool $ascending ascending (optional, default to false)
     * @param  string $filter filter (optional)
     * @param  string $order_by order_by (optional, default to update_date)
     * @param  int $page page (optional, default to 0)
     * @param  int $size size (optional, default to 25)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderStatusAllUsingGetAsyncWithHttpInfo($ascending = 'false', $filter = null, $order_by = 'update_date', $page = '0', $size = '25')
    {
        $returnType = '\com\hydrogen\nucleus\Model\PageOrderStatus_';
        $request = $this->getOrderStatusAllUsingGetRequest($ascending, $filter, $order_by, $page, $size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrderStatusAllUsingGet'
     *
     * @param  bool $ascending ascending (optional, default to false)
     * @param  string $filter filter (optional)
     * @param  string $order_by order_by (optional, default to update_date)
     * @param  int $page page (optional, default to 0)
     * @param  int $size size (optional, default to 25)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOrderStatusAllUsingGetRequest($ascending = 'false', $filter = null, $order_by = 'update_date', $page = '0', $size = '25')
    {

        $resourcePath = '/nucleus/v1/order_status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($ascending !== null) {
            $queryParams['ascending'] = ObjectSerializer::toQueryValue($ascending);
        }
        // query params
        if ($filter !== null) {
            $queryParams['filter'] = ObjectSerializer::toQueryValue($filter);
        }
        // query params
        if ($order_by !== null) {
            $queryParams['order_by'] = ObjectSerializer::toQueryValue($order_by);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrderStatusUsingGet
     *
     * Retrieve an order status
     *
     * @param  string $order_status_id UUID order_status_id (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com\hydrogen\nucleus\Model\OrderStatus
     */
    public function getOrderStatusUsingGet($order_status_id)
    {
        list($response) = $this->getOrderStatusUsingGetWithHttpInfo($order_status_id);
        return $response;
    }

    /**
     * Operation getOrderStatusUsingGetWithHttpInfo
     *
     * Retrieve an order status
     *
     * @param  string $order_status_id UUID order_status_id (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com\hydrogen\nucleus\Model\OrderStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrderStatusUsingGetWithHttpInfo($order_status_id)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderStatus';
        $request = $this->getOrderStatusUsingGetRequest($order_status_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com\hydrogen\nucleus\Model\OrderStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrderStatusUsingGetAsync
     *
     * Retrieve an order status
     *
     * @param  string $order_status_id UUID order_status_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderStatusUsingGetAsync($order_status_id)
    {
        return $this->getOrderStatusUsingGetAsyncWithHttpInfo($order_status_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrderStatusUsingGetAsyncWithHttpInfo
     *
     * Retrieve an order status
     *
     * @param  string $order_status_id UUID order_status_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderStatusUsingGetAsyncWithHttpInfo($order_status_id)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderStatus';
        $request = $this->getOrderStatusUsingGetRequest($order_status_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrderStatusUsingGet'
     *
     * @param  string $order_status_id UUID order_status_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOrderStatusUsingGetRequest($order_status_id)
    {
        // verify the required parameter 'order_status_id' is set
        if ($order_status_id === null || (is_array($order_status_id) && count($order_status_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_status_id when calling getOrderStatusUsingGet'
            );
        }

        $resourcePath = '/nucleus/v1/order_status/{order_status_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($order_status_id !== null) {
            $resourcePath = str_replace(
                '{' . 'order_status_id' . '}',
                ObjectSerializer::toPathValue($order_status_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrderTrackAllUsingGet
     *
     * List all order tracking records
     *
     * @param  bool $ascending ascending (optional, default to false)
     * @param  string $filter filter (optional)
     * @param  string $order_by order_by (optional, default to update_date)
     * @param  int $page page (optional, default to 0)
     * @param  int $size size (optional, default to 25)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com\hydrogen\nucleus\Model\PageOrderTrack_
     */
    public function getOrderTrackAllUsingGet($ascending = 'false', $filter = null, $order_by = 'update_date', $page = '0', $size = '25')
    {
        list($response) = $this->getOrderTrackAllUsingGetWithHttpInfo($ascending, $filter, $order_by, $page, $size);
        return $response;
    }

    /**
     * Operation getOrderTrackAllUsingGetWithHttpInfo
     *
     * List all order tracking records
     *
     * @param  bool $ascending ascending (optional, default to false)
     * @param  string $filter filter (optional)
     * @param  string $order_by order_by (optional, default to update_date)
     * @param  int $page page (optional, default to 0)
     * @param  int $size size (optional, default to 25)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com\hydrogen\nucleus\Model\PageOrderTrack_, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrderTrackAllUsingGetWithHttpInfo($ascending = 'false', $filter = null, $order_by = 'update_date', $page = '0', $size = '25')
    {
        $returnType = '\com\hydrogen\nucleus\Model\PageOrderTrack_';
        $request = $this->getOrderTrackAllUsingGetRequest($ascending, $filter, $order_by, $page, $size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com\hydrogen\nucleus\Model\PageOrderTrack_',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrderTrackAllUsingGetAsync
     *
     * List all order tracking records
     *
     * @param  bool $ascending ascending (optional, default to false)
     * @param  string $filter filter (optional)
     * @param  string $order_by order_by (optional, default to update_date)
     * @param  int $page page (optional, default to 0)
     * @param  int $size size (optional, default to 25)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderTrackAllUsingGetAsync($ascending = 'false', $filter = null, $order_by = 'update_date', $page = '0', $size = '25')
    {
        return $this->getOrderTrackAllUsingGetAsyncWithHttpInfo($ascending, $filter, $order_by, $page, $size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrderTrackAllUsingGetAsyncWithHttpInfo
     *
     * List all order tracking records
     *
     * @param  bool $ascending ascending (optional, default to false)
     * @param  string $filter filter (optional)
     * @param  string $order_by order_by (optional, default to update_date)
     * @param  int $page page (optional, default to 0)
     * @param  int $size size (optional, default to 25)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderTrackAllUsingGetAsyncWithHttpInfo($ascending = 'false', $filter = null, $order_by = 'update_date', $page = '0', $size = '25')
    {
        $returnType = '\com\hydrogen\nucleus\Model\PageOrderTrack_';
        $request = $this->getOrderTrackAllUsingGetRequest($ascending, $filter, $order_by, $page, $size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrderTrackAllUsingGet'
     *
     * @param  bool $ascending ascending (optional, default to false)
     * @param  string $filter filter (optional)
     * @param  string $order_by order_by (optional, default to update_date)
     * @param  int $page page (optional, default to 0)
     * @param  int $size size (optional, default to 25)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOrderTrackAllUsingGetRequest($ascending = 'false', $filter = null, $order_by = 'update_date', $page = '0', $size = '25')
    {

        $resourcePath = '/nucleus/v1/order_track';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($ascending !== null) {
            $queryParams['ascending'] = ObjectSerializer::toQueryValue($ascending);
        }
        // query params
        if ($filter !== null) {
            $queryParams['filter'] = ObjectSerializer::toQueryValue($filter);
        }
        // query params
        if ($order_by !== null) {
            $queryParams['order_by'] = ObjectSerializer::toQueryValue($order_by);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrderTrackUsingGet
     *
     * Retrieve an order tracking record
     *
     * @param  string $order_track_id UUID order_track_id (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com\hydrogen\nucleus\Model\OrderTrack
     */
    public function getOrderTrackUsingGet($order_track_id)
    {
        list($response) = $this->getOrderTrackUsingGetWithHttpInfo($order_track_id);
        return $response;
    }

    /**
     * Operation getOrderTrackUsingGetWithHttpInfo
     *
     * Retrieve an order tracking record
     *
     * @param  string $order_track_id UUID order_track_id (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com\hydrogen\nucleus\Model\OrderTrack, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrderTrackUsingGetWithHttpInfo($order_track_id)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderTrack';
        $request = $this->getOrderTrackUsingGetRequest($order_track_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com\hydrogen\nucleus\Model\OrderTrack',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrderTrackUsingGetAsync
     *
     * Retrieve an order tracking record
     *
     * @param  string $order_track_id UUID order_track_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderTrackUsingGetAsync($order_track_id)
    {
        return $this->getOrderTrackUsingGetAsyncWithHttpInfo($order_track_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrderTrackUsingGetAsyncWithHttpInfo
     *
     * Retrieve an order tracking record
     *
     * @param  string $order_track_id UUID order_track_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderTrackUsingGetAsyncWithHttpInfo($order_track_id)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderTrack';
        $request = $this->getOrderTrackUsingGetRequest($order_track_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrderTrackUsingGet'
     *
     * @param  string $order_track_id UUID order_track_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOrderTrackUsingGetRequest($order_track_id)
    {
        // verify the required parameter 'order_track_id' is set
        if ($order_track_id === null || (is_array($order_track_id) && count($order_track_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_track_id when calling getOrderTrackUsingGet'
            );
        }

        $resourcePath = '/nucleus/v1/order_track/{order_track_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($order_track_id !== null) {
            $resourcePath = str_replace(
                '{' . 'order_track_id' . '}',
                ObjectSerializer::toPathValue($order_track_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrderUsingGet
     *
     * Retrieve an order record
     *
     * @param  string $order_id UUID order_id (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com\hydrogen\nucleus\Model\Order
     */
    public function getOrderUsingGet($order_id)
    {
        list($response) = $this->getOrderUsingGetWithHttpInfo($order_id);
        return $response;
    }

    /**
     * Operation getOrderUsingGetWithHttpInfo
     *
     * Retrieve an order record
     *
     * @param  string $order_id UUID order_id (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com\hydrogen\nucleus\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrderUsingGetWithHttpInfo($order_id)
    {
        $returnType = '\com\hydrogen\nucleus\Model\Order';
        $request = $this->getOrderUsingGetRequest($order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com\hydrogen\nucleus\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrderUsingGetAsync
     *
     * Retrieve an order record
     *
     * @param  string $order_id UUID order_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderUsingGetAsync($order_id)
    {
        return $this->getOrderUsingGetAsyncWithHttpInfo($order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrderUsingGetAsyncWithHttpInfo
     *
     * Retrieve an order record
     *
     * @param  string $order_id UUID order_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderUsingGetAsyncWithHttpInfo($order_id)
    {
        $returnType = '\com\hydrogen\nucleus\Model\Order';
        $request = $this->getOrderUsingGetRequest($order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrderUsingGet'
     *
     * @param  string $order_id UUID order_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOrderUsingGetRequest($order_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling getOrderUsingGet'
            );
        }

        $resourcePath = '/nucleus/v1/order/{order_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'order_id' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateOrderStatusUsingPut
     *
     * Update an order status
     *
     * @param  object $order_status order_status (required)
     * @param  string $order_status_id UUID order_status_id (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com\hydrogen\nucleus\Model\OrderStatus
     */
    public function updateOrderStatusUsingPut($order_status, $order_status_id)
    {
        list($response) = $this->updateOrderStatusUsingPutWithHttpInfo($order_status, $order_status_id);
        return $response;
    }

    /**
     * Operation updateOrderStatusUsingPutWithHttpInfo
     *
     * Update an order status
     *
     * @param  object $order_status order_status (required)
     * @param  string $order_status_id UUID order_status_id (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com\hydrogen\nucleus\Model\OrderStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateOrderStatusUsingPutWithHttpInfo($order_status, $order_status_id)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderStatus';
        $request = $this->updateOrderStatusUsingPutRequest($order_status, $order_status_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com\hydrogen\nucleus\Model\OrderStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateOrderStatusUsingPutAsync
     *
     * Update an order status
     *
     * @param  object $order_status order_status (required)
     * @param  string $order_status_id UUID order_status_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateOrderStatusUsingPutAsync($order_status, $order_status_id)
    {
        return $this->updateOrderStatusUsingPutAsyncWithHttpInfo($order_status, $order_status_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateOrderStatusUsingPutAsyncWithHttpInfo
     *
     * Update an order status
     *
     * @param  object $order_status order_status (required)
     * @param  string $order_status_id UUID order_status_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateOrderStatusUsingPutAsyncWithHttpInfo($order_status, $order_status_id)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderStatus';
        $request = $this->updateOrderStatusUsingPutRequest($order_status, $order_status_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateOrderStatusUsingPut'
     *
     * @param  object $order_status order_status (required)
     * @param  string $order_status_id UUID order_status_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateOrderStatusUsingPutRequest($order_status, $order_status_id)
    {
        // verify the required parameter 'order_status' is set
        if ($order_status === null || (is_array($order_status) && count($order_status) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_status when calling updateOrderStatusUsingPut'
            );
        }
        // verify the required parameter 'order_status_id' is set
        if ($order_status_id === null || (is_array($order_status_id) && count($order_status_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_status_id when calling updateOrderStatusUsingPut'
            );
        }

        $resourcePath = '/nucleus/v1/order_status/{order_status_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($order_status_id !== null) {
            $resourcePath = str_replace(
                '{' . 'order_status_id' . '}',
                ObjectSerializer::toPathValue($order_status_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($order_status)) {
            $_tempBody = $order_status;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateOrderTrackUsingPut
     *
     * Update an order tracking record
     *
     * @param  object $order_track order_track (required)
     * @param  string $order_track_id UUID order_track_id (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com\hydrogen\nucleus\Model\OrderTrack
     */
    public function updateOrderTrackUsingPut($order_track, $order_track_id)
    {
        list($response) = $this->updateOrderTrackUsingPutWithHttpInfo($order_track, $order_track_id);
        return $response;
    }

    /**
     * Operation updateOrderTrackUsingPutWithHttpInfo
     *
     * Update an order tracking record
     *
     * @param  object $order_track order_track (required)
     * @param  string $order_track_id UUID order_track_id (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com\hydrogen\nucleus\Model\OrderTrack, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateOrderTrackUsingPutWithHttpInfo($order_track, $order_track_id)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderTrack';
        $request = $this->updateOrderTrackUsingPutRequest($order_track, $order_track_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com\hydrogen\nucleus\Model\OrderTrack',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateOrderTrackUsingPutAsync
     *
     * Update an order tracking record
     *
     * @param  object $order_track order_track (required)
     * @param  string $order_track_id UUID order_track_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateOrderTrackUsingPutAsync($order_track, $order_track_id)
    {
        return $this->updateOrderTrackUsingPutAsyncWithHttpInfo($order_track, $order_track_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateOrderTrackUsingPutAsyncWithHttpInfo
     *
     * Update an order tracking record
     *
     * @param  object $order_track order_track (required)
     * @param  string $order_track_id UUID order_track_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateOrderTrackUsingPutAsyncWithHttpInfo($order_track, $order_track_id)
    {
        $returnType = '\com\hydrogen\nucleus\Model\OrderTrack';
        $request = $this->updateOrderTrackUsingPutRequest($order_track, $order_track_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateOrderTrackUsingPut'
     *
     * @param  object $order_track order_track (required)
     * @param  string $order_track_id UUID order_track_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateOrderTrackUsingPutRequest($order_track, $order_track_id)
    {
        // verify the required parameter 'order_track' is set
        if ($order_track === null || (is_array($order_track) && count($order_track) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_track when calling updateOrderTrackUsingPut'
            );
        }
        // verify the required parameter 'order_track_id' is set
        if ($order_track_id === null || (is_array($order_track_id) && count($order_track_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_track_id when calling updateOrderTrackUsingPut'
            );
        }

        $resourcePath = '/nucleus/v1/order_track/{order_track_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($order_track_id !== null) {
            $resourcePath = str_replace(
                '{' . 'order_track_id' . '}',
                ObjectSerializer::toPathValue($order_track_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($order_track)) {
            $_tempBody = $order_track;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateOrderUsingPut
     *
     * Update an order record
     *
     * @param  object $order order (required)
     * @param  string $order_id UUID order_id (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com\hydrogen\nucleus\Model\Order
     */
    public function updateOrderUsingPut($order, $order_id)
    {
        list($response) = $this->updateOrderUsingPutWithHttpInfo($order, $order_id);
        return $response;
    }

    /**
     * Operation updateOrderUsingPutWithHttpInfo
     *
     * Update an order record
     *
     * @param  object $order order (required)
     * @param  string $order_id UUID order_id (required)
     *
     * @throws \com\hydrogen\nucleus\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com\hydrogen\nucleus\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateOrderUsingPutWithHttpInfo($order, $order_id)
    {
        $returnType = '\com\hydrogen\nucleus\Model\Order';
        $request = $this->updateOrderUsingPutRequest($order, $order_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com\hydrogen\nucleus\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateOrderUsingPutAsync
     *
     * Update an order record
     *
     * @param  object $order order (required)
     * @param  string $order_id UUID order_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateOrderUsingPutAsync($order, $order_id)
    {
        return $this->updateOrderUsingPutAsyncWithHttpInfo($order, $order_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateOrderUsingPutAsyncWithHttpInfo
     *
     * Update an order record
     *
     * @param  object $order order (required)
     * @param  string $order_id UUID order_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateOrderUsingPutAsyncWithHttpInfo($order, $order_id)
    {
        $returnType = '\com\hydrogen\nucleus\Model\Order';
        $request = $this->updateOrderUsingPutRequest($order, $order_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateOrderUsingPut'
     *
     * @param  object $order order (required)
     * @param  string $order_id UUID order_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateOrderUsingPutRequest($order, $order_id)
    {
        // verify the required parameter 'order' is set
        if ($order === null || (is_array($order) && count($order) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order when calling updateOrderUsingPut'
            );
        }
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling updateOrderUsingPut'
            );
        }

        $resourcePath = '/nucleus/v1/order/{order_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'order_id' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($order)) {
            $_tempBody = $order;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
