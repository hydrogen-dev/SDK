/*
 * Hydrogen Admin API
 * The Hydrogen Admin API
 *
 * OpenAPI spec version: 1.0.2
 * Contact: info@hydrogenplatform.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 *
 * Swagger Codegen version: 2.4.17
 *
 * Do not edit the class manually.
 *
 */


(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['ApiClient', 'model/Client', 'model/PageClient'], factory);
  } else if (typeof module === 'object' && module.exports) {
    // CommonJS-like environments that support module.exports, like Node.
    module.exports = factory(require('../ApiClient'), require('../model/Client'), require('../model/PageClient'));
  } else {
    // Browser globals (root is window)
    if (!root.HydrogenAdminApi) {
      root.HydrogenAdminApi = {};
    }
    root.HydrogenAdminApi.ClientApi = factory(root.HydrogenAdminApi.ApiClient, root.HydrogenAdminApi.Client, root.HydrogenAdminApi.PageClient);
  }
}(this, function(ApiClient, Client, PageClient) {
  'use strict';

  /**
   * Client service.
   * @module api/ClientApi
   * @version 1.3.1
   */

  /**
   * Constructs a new ClientApi. 
   * @alias module:api/ClientApi
   * @class
   * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
   * default to {@link module:ApiClient#instance} if unspecified.
   */
  var exports = function(apiClient) {
    this.apiClient = apiClient || ApiClient.instance;


    /**
     * Callback function to receive the result of the createClientUsingPost operation.
     * @callback module:api/ClientApi~createClientUsingPostCallback
     * @param {String} error Error message, if any.
     * @param {module:model/Client} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Create a client
     * Create a new client, or register a new user, with your firm.
     * @param {module:model/Client} clientRequest clientRequest
     * @param {module:api/ClientApi~createClientUsingPostCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/Client}
     */
    this.createClientUsingPost = function(clientRequest, appTokenConfig, callback) {
      var postBody = clientRequest;

      // verify the required parameter 'clientRequest' is set
      if (clientRequest === undefined || clientRequest === null) {
        throw new Error("Missing the required parameter 'clientRequest' when calling createClientUsingPost");
      }

      if (appTokenConfig.basePath === undefined || appTokenConfig.basePath === null) {
        throw new Error("Missing the required parameter 'basePath'");
      }
      if (appTokenConfig.authType === undefined || appTokenConfig.authType === null) {
        throw new Error("Missing the required parameter 'authType'");
      }
      this.apiClient.basePath = appTokenConfig.basePath;
      this.authApi = authApi || new AuthApi();

      var pathParams = {
      };
      var queryParams = {
      };
      var collectionQueryParams = {
      };
      var headerParams = {
      };
      var formParams = {
      };

      var authNames = ['oauth2'];
      var contentTypes = ['application/json'];
      var accepts = ['*/*'];
      var returnType = Client;
      var oauth2 = this.apiClient.authentications['oauth2'];

      async function createUsingPostClientCredentials (apiClient, authApi) {
        // Token Generation for grant_type = client_credentials
        const req = authApi.createUsingPostClientCredentials({
          'grant_type': 'client_credentials',
          'client_id': appTokenConfig.clientId,
          'client_secret': appTokenConfig.clientSecret
        }, null);

        return new Promise(function(resolve, reject) {
          req
              .then(response => {
                let data = null;
                try {
                  data = apiClient.deserialize(response, Object);
                  if (apiClient.enableCookies && typeof window === 'undefined') {
                    apiClient.agent.saveCookies(response);
                  }
                } catch (err) {
                  console.log(err);
                  reject(err);
                }

                resolve(data)
              })
              .catch(err => {
                console.error(err);
                reject(err);
              });
        });
      }

      async function createUsingPostPassword (apiClient, authApi) {
        // Token Generation for grant_type = password
        const req = authApi.createUsingPostPassword({
          'grant_type': 'password',
          'client_id': appTokenConfig.clientId,
          'client_secret': appTokenConfig.clientSecret,
          'username': appTokenConfig.username,
          'password': appTokenConfig.password
        }, null);

        return new Promise(function(resolve, reject) {
          req
              .then(response => {
                let data = null;
                try {
                  data = apiClient.deserialize(response, Object);
                  if (apiClient.enableCookies && typeof window === 'undefined') {
                    apiClient.agent.saveCookies(response);
                  }
                } catch (err) {
                  console.log(err);
                  reject(err);
                }

                resolve(data)
              })
              .catch(err => {
                console.error(err);
                reject(err);
              });
        });
      }

      async function createUsingPostUserToken (apiClient, authApi) {
        // Token Generation for grant_type = password
        const req = authApi.createUsingPostClientTokenCredentials({
          'grant_type': 'password',
          'client_id': appTokenConfig.clientId,
          'client_secret': appTokenConfig.clientSecret,
          'Client-Token': appTokenConfig.ClientToken
        }, null);

        return new Promise(function(resolve, reject) {
          req
              .then(response => {
                let data = null;
                try {
                  data = apiClient.deserialize(response, Object);
                  if (apiClient.enableCookies && typeof window === 'undefined') {
                    apiClient.agent.saveCookies(response);
                  }
                } catch (err) {
                  console.log(err);
                  reject(err);
                }

                resolve(data)
              })
              .catch(err => {
                console.error(err);
                reject(err);
              });
        });
      }
      async function createClient (apiClient) {
        const req = apiClient.callApi(
            '/nucleus/v1/client', 'POST',
            pathParams, queryParams, collectionQueryParams, headerParams, formParams, postBody,
            authNames, contentTypes, accepts, Client, null
        );

        return new Promise(function(resolve, reject) {
          req
              .then(response => {
                let data = null;
                try {
                  data = apiClient.deserialize(response, Object);
                  if (apiClient.enableCookies && typeof window === 'undefined') {
                    apiClient.agent.saveCookies(response);
                  }
                } catch (err) {
                  console.log(err);
                  reject(err);
                }

                resolve(data)
              })
              .catch(err => {
                console.error(err);
                reject(err);
              });
        });
      }
      try {
        (async () => {
          if (appTokenConfig.authType && appTokenConfig.authType.toLowerCase() === "client_credentials") {
            const tokenData = await createUsingPostClientCredentials(this.apiClient, this.authApi).catch(e=>{
              callback(e, null, null)
            });
            oauth2.accessToken = tokenData.access_token;
          } else if (appTokenConfig.authType && appTokenConfig.authType.toLowerCase() === "password_credentials") {
            const tokenData = await createUsingPostPassword(this.apiClient, this.authApi).catch(e=>{
              callback(e, null, null)
            });
            oauth2.accessToken = tokenData.access_token;
          } else if (appTokenConfig.authType && appTokenConfig.authType.toLowerCase() === "client_token_credentials") {
            const tokenData = await createUsingPostUserToken(this.apiClient, this.authApi).catch(e=>{
              callback(e, null, null)
            });
            oauth2.accessToken = tokenData.access_token;
          }

          const response = await createClient(this.apiClient).catch(e=>{
            callback(e, null, null)
          });
          callback(null, response, response) ;
        })();
      }
      catch(e){
        callback(e, null, null);
      }
    }

    /**
     * Callback function to receive the result of the getClientAllUsingGet operation.
     * @callback module:api/ClientApi~getClientAllUsingGetCallback
     * @param {String} error Error message, if any.
     * @param {module:model/PageClient} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * List all clients
     * Get details for all clients registered with your firm.
     * @param {Object} opts Optional parameters
     * @param {Boolean} opts.ascending ascending (default to false)
     * @param {String} opts.filter filter
     * @param {String} opts.orderBy order_by (default to update_date)
     * @param {Number} opts.page page (default to 0)
     * @param {Number} opts.size size (default to 25)
     * @param {module:api/ClientApi~getClientAllUsingGetCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/PageClient}
     */
    this.getClientAllUsingGet = function(opts, appTokenConfig, callback) {
      opts = opts || {};
      var postBody = null;

      if (appTokenConfig.basePath === undefined || appTokenConfig.basePath === null) {
        throw new Error("Missing the required parameter 'basePath'");
      }
      if (appTokenConfig.authType === undefined || appTokenConfig.authType === null) {
        throw new Error("Missing the required parameter 'authType'");
      }
      this.apiClient.basePath = appTokenConfig.basePath;
      this.authApi = authApi || new AuthApi();
      var oauth2 = this.apiClient.authentications['oauth2'];

      var pathParams = {
      };
      var queryParams = {
        'ascending': opts['ascending'],
        'filter': opts['filter'],
        'order_by': opts['orderBy'],
        'page': opts['page'],
        'size': opts['size'],
      };
      var collectionQueryParams = {
      };
      var headerParams = {
      };
      var formParams = {
      };

      var authNames = ['oauth2'];
      var contentTypes = [];
      var accepts = ['*/*'];
      var returnType = PageClient;
      async function createUsingPostClientCredentials (apiClient, authApi) {
        // Token Generation for grant_type = client_credentials
        const req = authApi.createUsingPostClientCredentials({
          'grant_type': 'client_credentials',
          'client_id': appTokenConfig.clientId,
          'client_secret': appTokenConfig.clientSecret
        }, null);

        return new Promise(function(resolve, reject) {
          req
              .then(response => {
                let data = null;
                try {
                  data = apiClient.deserialize(response, Object);
                  if (apiClient.enableCookies && typeof window === 'undefined') {
                    apiClient.agent.saveCookies(response);
                  }
                } catch (err) {
                  console.log(err);
                  reject(err);
                }

                resolve(data)
              })
              .catch(err => {
                console.error(err);
                reject(err);
              });
        });
      }

      async function createUsingPostPassword (apiClient, authApi) {
        // Token Generation for grant_type = password
        const req = authApi.createUsingPostPassword({
          'grant_type': 'password',
          'client_id': appTokenConfig.clientId,
          'client_secret': appTokenConfig.clientSecret,
          'username': appTokenConfig.username,
          'password': appTokenConfig.password
        }, null);

        return new Promise(function(resolve, reject) {
          req
              .then(response => {
                let data = null;
                try {
                  data = apiClient.deserialize(response, Object);
                  if (apiClient.enableCookies && typeof window === 'undefined') {
                    apiClient.agent.saveCookies(response);
                  }
                } catch (err) {
                  console.log(err);
                  reject(err);
                }

                resolve(data)
              })
              .catch(err => {
                console.error(err);
                reject(err);
              });
        });
      }

      async function createUsingPostUserToken (apiClient, authApi) {
        // Token Generation for grant_type = password
        const req = authApi.createUsingPostClientTokenCredentials({
          'grant_type': 'password',
          'client_id': appTokenConfig.clientId,
          'client_secret': appTokenConfig.clientSecret,
          'Client-Token': appTokenConfig.ClientToken
        }, null);

        return new Promise(function(resolve, reject) {
          req
              .then(response => {
                let data = null;
                try {
                  data = apiClient.deserialize(response, Object);
                  if (apiClient.enableCookies && typeof window === 'undefined') {
                    apiClient.agent.saveCookies(response);
                  }
                } catch (err) {
                  console.log(err);
                  reject(err);
                }

                resolve(data)
              })
              .catch(err => {
                console.error(err);
                reject(err);
              });
        });
      }
      async function getClientAll (apiClient) {
        const req = apiClient.callApi(
            '/nucleus/v1/client', 'GET',
            pathParams, queryParams, collectionQueryParams, headerParams, formParams, postBody,
            authNames, contentTypes, accepts, PageClient, null
        );

        return new Promise(function(resolve, reject) {
          req
              .then(response => {
                let data = null;
                try {
                  data = apiClient.deserialize(response, Object);
                  if (apiClient.enableCookies && typeof window === 'undefined') {
                    apiClient.agent.saveCookies(response);
                  }
                } catch (err) {
                  console.log(err);
                  reject(err);
                }

                resolve(data)
              })
              .catch(err => {
                console.error(err);
                reject(err);
              });
        });
      }
      try {
        (async () => {
          if (appTokenConfig.authType && appTokenConfig.authType.toLowerCase() === "client_credentials") {
            const tokenData = await createUsingPostClientCredentials(this.apiClient, this.authApi).catch(e=>{
              callback(e, null, null)
            });
            oauth2.accessToken = tokenData.access_token;
          } else if (appTokenConfig.authType && appTokenConfig.authType.toLowerCase() === "password_credentials") {
            const tokenData = await createUsingPostPassword(this.apiClient, this.authApi).catch(e=>{
              callback(e, null, null)
            });
            oauth2.accessToken = tokenData.access_token;
          } else if (appTokenConfig.authType && appTokenConfig.authType.toLowerCase() === "client_token_credentials") {
            const tokenData = await createUsingPostUserToken(this.apiClient, this.authApi).catch(e=>{
              callback(e, null, null)
            });
            oauth2.accessToken = tokenData.access_token;
          }

          const response = await getClientAll(this.apiClient).catch(e=>{
            callback(e, null, null)
          });
          callback(null, response, response) ;
        })();
      }
      catch(e){
        callback(e, null, null);
      }
    }

    /**
     * Callback function to receive the result of the getClientUsingGet operation.
     * @callback module:api/ClientApi~getClientUsingGetCallback
     * @param {String} error Error message, if any.
     * @param {module:model/Client} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Retrieve a client
     * Retrieve the information for a client registered with your firm.
     * @param {String} clientId UUID client_id
     * @param {module:api/ClientApi~getClientUsingGetCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/Client}
     */
    this.getClientUsingGet = function(clientId, appTokenConfig, callback) {
      var postBody = null;

      // verify the required parameter 'clientId' is set
      if (clientId === undefined || clientId === null) {
        throw new Error("Missing the required parameter 'clientId' when calling getClientUsingGet");
      }
      if (appTokenConfig.basePath === undefined || appTokenConfig.basePath === null) {
        throw new Error("Missing the required parameter 'basePath'");
      }
      if (appTokenConfig.authType === undefined || appTokenConfig.authType === null) {
        throw new Error("Missing the required parameter 'authType'");
      }
      this.apiClient.basePath = appTokenConfig.basePath;
      this.authApi = authApi || new AuthApi();
      var oauth2 = this.apiClient.authentications['oauth2'];


      var pathParams = {
        'client_id': clientId
      };
      var queryParams = {
      };
      var collectionQueryParams = {
      };
      var headerParams = {
      };
      var formParams = {
      };

      var authNames = ['oauth2'];
      var contentTypes = [];
      var accepts = ['*/*'];
      var returnType = Client;
      async function createUsingPostClientCredentials (apiClient, authApi) {
        // Token Generation for grant_type = client_credentials
        const req = authApi.createUsingPostClientCredentials({
          'grant_type': 'client_credentials',
          'client_id': appTokenConfig.clientId,
          'client_secret': appTokenConfig.clientSecret
        }, null);

        return new Promise(function(resolve, reject) {
          req
              .then(response => {
                let data = null;
                try {
                  data = apiClient.deserialize(response, Object);
                  if (apiClient.enableCookies && typeof window === 'undefined') {
                    apiClient.agent.saveCookies(response);
                  }
                } catch (err) {
                  console.log(err);
                  reject(err);
                }

                resolve(data)
              })
              .catch(err => {
                console.error(err);
                reject(err);
              });
        });
      }

      async function createUsingPostPassword (apiClient, authApi) {
        // Token Generation for grant_type = password
        const req = authApi.createUsingPostPassword({
          'grant_type': 'password',
          'client_id': appTokenConfig.clientId,
          'client_secret': appTokenConfig.clientSecret,
          'username': appTokenConfig.username,
          'password': appTokenConfig.password
        }, null);

        return new Promise(function(resolve, reject) {
          req
              .then(response => {
                let data = null;
                try {
                  data = apiClient.deserialize(response, Object);
                  if (apiClient.enableCookies && typeof window === 'undefined') {
                    apiClient.agent.saveCookies(response);
                  }
                } catch (err) {
                  console.log(err);
                  reject(err);
                }

                resolve(data)
              })
              .catch(err => {
                console.error(err);
                reject(err);
              });
        });
      }

      async function createUsingPostUserToken (apiClient, authApi) {
        // Token Generation for grant_type = password
        const req = authApi.createUsingPostClientTokenCredentials({
          'grant_type': 'password',
          'client_id': appTokenConfig.clientId,
          'client_secret': appTokenConfig.clientSecret,
          'Client-Token': appTokenConfig.ClientToken
        }, null);

        return new Promise(function(resolve, reject) {
          req
              .then(response => {
                let data = null;
                try {
                  data = apiClient.deserialize(response, Object);
                  if (apiClient.enableCookies && typeof window === 'undefined') {
                    apiClient.agent.saveCookies(response);
                  }
                } catch (err) {
                  console.log(err);
                  reject(err);
                }

                resolve(data)
              })
              .catch(err => {
                console.error(err);
                reject(err);
              });
        });
      }
      async function getClient (apiClient) {
        const req = apiClient.callApi(
            '/nucleus/v1/client/{client_id}', 'GET',
            pathParams, queryParams, collectionQueryParams, headerParams, formParams, postBody,
            authNames, contentTypes, accepts, Client, null
        );

        return new Promise(function(resolve, reject) {
          req
              .then(response => {
                let data = null;
                try {
                  data = apiClient.deserialize(response, Object);
                  if (apiClient.enableCookies && typeof window === 'undefined') {
                    apiClient.agent.saveCookies(response);
                  }
                } catch (err) {
                  console.log(err);
                  reject(err);
                }

                resolve(data)
              })
              .catch(err => {
                console.error(err);
                reject(err);
              });
        });
      }
      try {
        (async () => {
          if (appTokenConfig.authType && appTokenConfig.authType.toLowerCase() === "client_credentials") {
            const tokenData = await createUsingPostClientCredentials(this.apiClient, this.authApi).catch(e=>{
              callback(e, null, null)
            });
            oauth2.accessToken = tokenData.access_token;
          } else if (appTokenConfig.authType && appTokenConfig.authType.toLowerCase() === "password_credentials") {
            const tokenData = await createUsingPostPassword(this.apiClient, this.authApi).catch(e=>{
              callback(e, null, null)
            });
            oauth2.accessToken = tokenData.access_token;
          } else if (appTokenConfig.authType && appTokenConfig.authType.toLowerCase() === "client_token_credentials") {
            const tokenData = await createUsingPostUserToken(this.apiClient, this.authApi).catch(e=>{
              callback(e, null, null)
            });
            oauth2.accessToken = tokenData.access_token;
          }

          const response = await getClient(this.apiClient).catch(e=>{
            callback(e, null, null)
          });
          callback(null, response, response) ;
        })();
      }
      catch(e){
        callback(e, null, null);
      }
    }

    /**
     * Callback function to receive the result of the updateClientUsingPut operation.
     * @callback module:api/ClientApi~updateClientUsingPutCallback
     * @param {String} error Error message, if any.
     * @param {module:model/Client} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Update a client
     * Update the information for a client registered with your firm.
     * @param {Object} client client
     * @param {String} clientId UUID client_id
     * @param {module:api/ClientApi~updateClientUsingPutCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/Client}
     */
    this.updateClientUsingPut = function(client, clientId, appTokenConfig, callback) {
      var postBody = client;

      // verify the required parameter 'client' is set
      if (client === undefined || client === null) {
        throw new Error("Missing the required parameter 'client' when calling updateClientUsingPut");
      }

      // verify the required parameter 'clientId' is set
      if (clientId === undefined || clientId === null) {
        throw new Error("Missing the required parameter 'clientId' when calling updateClientUsingPut");
      }

      if (appTokenConfig.basePath === undefined || appTokenConfig.basePath === null) {
        throw new Error("Missing the required parameter 'basePath'");
      }
      if (appTokenConfig.authType === undefined || appTokenConfig.authType === null) {
        throw new Error("Missing the required parameter 'authType'");
      }
      this.apiClient.basePath = appTokenConfig.basePath;
      this.authApi = authApi || new AuthApi();
      var oauth2 = this.apiClient.authentications['oauth2'];


      var pathParams = {
        'client_id': clientId
      };
      var queryParams = {
      };
      var collectionQueryParams = {
      };
      var headerParams = {
      };
      var formParams = {
      };

      var authNames = ['oauth2'];
      var contentTypes = ['application/json'];
      var accepts = ['*/*'];
      var returnType = Client;
      async function createUsingPostClientCredentials (apiClient, authApi) {
        // Token Generation for grant_type = client_credentials
        const req = authApi.createUsingPostClientCredentials({
          'grant_type': 'client_credentials',
          'client_id': appTokenConfig.clientId,
          'client_secret': appTokenConfig.clientSecret
        }, null);

        return new Promise(function(resolve, reject) {
          req
              .then(response => {
                let data = null;
                try {
                  data = apiClient.deserialize(response, Object);
                  if (apiClient.enableCookies && typeof window === 'undefined') {
                    apiClient.agent.saveCookies(response);
                  }
                } catch (err) {
                  console.log(err);
                  reject(err);
                }

                resolve(data)
              })
              .catch(err => {
                console.error(err);
                reject(err);
              });
        });
      }

      async function createUsingPostPassword (apiClient, authApi) {
        // Token Generation for grant_type = password
        const req = authApi.createUsingPostPassword({
          'grant_type': 'password',
          'client_id': appTokenConfig.clientId,
          'client_secret': appTokenConfig.clientSecret,
          'username': appTokenConfig.username,
          'password': appTokenConfig.password
        }, null);

        return new Promise(function(resolve, reject) {
          req
              .then(response => {
                let data = null;
                try {
                  data = apiClient.deserialize(response, Object);
                  if (apiClient.enableCookies && typeof window === 'undefined') {
                    apiClient.agent.saveCookies(response);
                  }
                } catch (err) {
                  console.log(err);
                  reject(err);
                }

                resolve(data)
              })
              .catch(err => {
                console.error(err);
                reject(err);
              });
        });
      }

      async function createUsingPostUserToken (apiClient, authApi) {
        // Token Generation for grant_type = password
        const req = authApi.createUsingPostClientTokenCredentials({
          'grant_type': 'password',
          'client_id': appTokenConfig.clientId,
          'client_secret': appTokenConfig.clientSecret,
          'Client-Token': appTokenConfig.ClientToken
        }, null);

        return new Promise(function(resolve, reject) {
          req
              .then(response => {
                let data = null;
                try {
                  data = apiClient.deserialize(response, Object);
                  if (apiClient.enableCookies && typeof window === 'undefined') {
                    apiClient.agent.saveCookies(response);
                  }
                } catch (err) {
                  console.log(err);
                  reject(err);
                }

                resolve(data)
              })
              .catch(err => {
                console.error(err);
                reject(err);
              });
        });
      }
      async function updateClient (apiClient) {
        const req = apiClient.callApi(
            '/nucleus/v1/client/{client_id}', 'PUT',
            pathParams, queryParams, collectionQueryParams, headerParams, formParams, postBody,
            authNames, contentTypes, accepts, Client, null
        );

        return new Promise(function(resolve, reject) {
          req
              .then(response => {
                let data = null;
                try {
                  data = apiClient.deserialize(response, Object);
                  if (apiClient.enableCookies && typeof window === 'undefined') {
                    apiClient.agent.saveCookies(response);
                  }
                } catch (err) {
                  console.log(err);
                  reject(err);
                }

                resolve(data)
              })
              .catch(err => {
                console.error(err);
                reject(err);
              });
        });
      }
      try {
        (async () => {
          if (appTokenConfig.authType && appTokenConfig.authType.toLowerCase() === "client_credentials") {
            const tokenData = await createUsingPostClientCredentials(this.apiClient, this.authApi).catch(e=>{
              callback(e, null, null)
            });
            oauth2.accessToken = tokenData.access_token;
          } else if (appTokenConfig.authType && appTokenConfig.authType.toLowerCase() === "password_credentials") {
            const tokenData = await createUsingPostPassword(this.apiClient, this.authApi).catch(e=>{
              callback(e, null, null)
            });
            oauth2.accessToken = tokenData.access_token;
          } else if (appTokenConfig.authType && appTokenConfig.authType.toLowerCase() === "client_token_credentials") {
            const tokenData = await createUsingPostUserToken(this.apiClient, this.authApi).catch(e=>{
              callback(e, null, null)
            });
            oauth2.accessToken = tokenData.access_token;
          }

          const response = await updateClient(this.apiClient).catch(e=>{
            callback(e, null, null)
          });
          callback(null, response, response) ;
        })();
      }
      catch(e){
        callback(e, null, null);
      }
    }
  };

  return exports;
}));
