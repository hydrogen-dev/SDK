/*
 * Hydrogen Atom API
 * The Hydrogen Atom API
 *
 * OpenAPI spec version: 1.0.1
 * Contact: info@hydrogenplatform.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

/**
 * MonteCarlo
 */
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2019-09-12T10:03:00.746-04:00")
public class MonteCarlo {
  @SerializedName("cf")
  private List<List<BigDecimal>> cf = new ArrayList<List<BigDecimal>>();

  @SerializedName("mu")
  private List<BigDecimal> mu = new ArrayList<BigDecimal>();

  @SerializedName("sigma")
  private List<BigDecimal> sigma = new ArrayList<BigDecimal>();

  @SerializedName("ret_mod")
  private List<BigDecimal> retMod = null;

  @SerializedName("init_bal")
  private Integer initBal = null;

  @SerializedName("n")
  private Integer n = null;

  @SerializedName("remove_outliers")
  private Boolean removeOutliers = false;

  /**
   * The type of simulation results to display in the output
   */
  @JsonAdapter(ResultTypeEnum.Adapter.class)
  public enum ResultTypeEnum {
    RAW("raw"),
    
    MEAN("mean"),
    
    MEDIAN("median"),
    
    PERCENTILES("percentiles"),
    
    CUSTOM("custom");

    private String value;

    ResultTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ResultTypeEnum fromValue(String text) {
      for (ResultTypeEnum b : ResultTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<ResultTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ResultTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ResultTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ResultTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("result_type")
  private ResultTypeEnum resultType = ResultTypeEnum.RAW;

  @SerializedName("p")
  private List<BigDecimal> p = null;

  @SerializedName("min_bal")
  private List<BigDecimal> minBal = null;

  @SerializedName("max_bal")
  private List<BigDecimal> maxBal = null;

  @SerializedName("min_sample")
  private List<BigDecimal> minSample = null;

  @SerializedName("max_sample")
  private List<BigDecimal> maxSample = null;

  public MonteCarlo cf(List<List<BigDecimal>> cf) {
    this.cf = cf;
    return this;
  }

  public MonteCarlo addCfItem(List<BigDecimal> cfItem) {
    this.cf.add(cfItem);
    return this;
  }

   /**
   * The cash flows to occur during the simulation
   * @return cf
  **/
  @ApiModelProperty(required = true, value = "The cash flows to occur during the simulation")
  public List<List<BigDecimal>> getCf() {
    return cf;
  }

  public void setCf(List<List<BigDecimal>> cf) {
    this.cf = cf;
  }

  public MonteCarlo mu(List<BigDecimal> mu) {
    this.mu = mu;
    return this;
  }

  public MonteCarlo addMuItem(BigDecimal muItem) {
    this.mu.add(muItem);
    return this;
  }

   /**
   * The periodic mean portfolio return
   * @return mu
  **/
  @ApiModelProperty(required = true, value = "The periodic mean portfolio return")
  public List<BigDecimal> getMu() {
    return mu;
  }

  public void setMu(List<BigDecimal> mu) {
    this.mu = mu;
  }

  public MonteCarlo sigma(List<BigDecimal> sigma) {
    this.sigma = sigma;
    return this;
  }

  public MonteCarlo addSigmaItem(BigDecimal sigmaItem) {
    this.sigma.add(sigmaItem);
    return this;
  }

   /**
   * The periodic portfolio standard deviation
   * @return sigma
  **/
  @ApiModelProperty(required = true, value = "The periodic portfolio standard deviation")
  public List<BigDecimal> getSigma() {
    return sigma;
  }

  public void setSigma(List<BigDecimal> sigma) {
    this.sigma = sigma;
  }

  public MonteCarlo retMod(List<BigDecimal> retMod) {
    this.retMod = retMod;
    return this;
  }

  public MonteCarlo addRetModItem(BigDecimal retModItem) {
    if (this.retMod == null) {
      this.retMod = new ArrayList<BigDecimal>();
    }
    this.retMod.add(retModItem);
    return this;
  }

   /**
   * A periodic return modifier
   * @return retMod
  **/
  @ApiModelProperty(value = "A periodic return modifier")
  public List<BigDecimal> getRetMod() {
    return retMod;
  }

  public void setRetMod(List<BigDecimal> retMod) {
    this.retMod = retMod;
  }

  public MonteCarlo initBal(Integer initBal) {
    this.initBal = initBal;
    return this;
  }

   /**
   * The initial investment at time zero
   * minimum: 0
   * @return initBal
  **/
  @ApiModelProperty(value = "The initial investment at time zero")
  public Integer getInitBal() {
    return initBal;
  }

  public void setInitBal(Integer initBal) {
    this.initBal = initBal;
  }

  public MonteCarlo n(Integer n) {
    this.n = n;
    return this;
  }

   /**
   * The number of simulations to run
   * minimum: 0
   * @return n
  **/
  @ApiModelProperty(value = "The number of simulations to run")
  public Integer getN() {
    return n;
  }

  public void setN(Integer n) {
    this.n = n;
  }

  public MonteCarlo removeOutliers(Boolean removeOutliers) {
    this.removeOutliers = removeOutliers;
    return this;
  }

   /**
   * If true, remove outlying results
   * @return removeOutliers
  **/
  @ApiModelProperty(value = "If true, remove outlying results")
  public Boolean isRemoveOutliers() {
    return removeOutliers;
  }

  public void setRemoveOutliers(Boolean removeOutliers) {
    this.removeOutliers = removeOutliers;
  }

  public MonteCarlo resultType(ResultTypeEnum resultType) {
    this.resultType = resultType;
    return this;
  }

   /**
   * The type of simulation results to display in the output
   * @return resultType
  **/
  @ApiModelProperty(value = "The type of simulation results to display in the output")
  public ResultTypeEnum getResultType() {
    return resultType;
  }

  public void setResultType(ResultTypeEnum resultType) {
    this.resultType = resultType;
  }

  public MonteCarlo p(List<BigDecimal> p) {
    this.p = p;
    return this;
  }

  public MonteCarlo addPItem(BigDecimal pItem) {
    if (this.p == null) {
      this.p = new ArrayList<BigDecimal>();
    }
    this.p.add(pItem);
    return this;
  }

   /**
   * Custom result percentiles
   * @return p
  **/
  @ApiModelProperty(value = "Custom result percentiles")
  public List<BigDecimal> getP() {
    return p;
  }

  public void setP(List<BigDecimal> p) {
    this.p = p;
  }

  public MonteCarlo minBal(List<BigDecimal> minBal) {
    this.minBal = minBal;
    return this;
  }

  public MonteCarlo addMinBalItem(BigDecimal minBalItem) {
    if (this.minBal == null) {
      this.minBal = new ArrayList<BigDecimal>();
    }
    this.minBal.add(minBalItem);
    return this;
  }

   /**
   * A lower bound to enforce on the periodic balance. Each item in the array corresponds to a period in the simulation. If the length of the array is less than the number of simulation periods, it is conformed to the appropriate length by persisting the final value in the array.
   * @return minBal
  **/
  @ApiModelProperty(value = "A lower bound to enforce on the periodic balance. Each item in the array corresponds to a period in the simulation. If the length of the array is less than the number of simulation periods, it is conformed to the appropriate length by persisting the final value in the array.")
  public List<BigDecimal> getMinBal() {
    return minBal;
  }

  public void setMinBal(List<BigDecimal> minBal) {
    this.minBal = minBal;
  }

  public MonteCarlo maxBal(List<BigDecimal> maxBal) {
    this.maxBal = maxBal;
    return this;
  }

  public MonteCarlo addMaxBalItem(BigDecimal maxBalItem) {
    if (this.maxBal == null) {
      this.maxBal = new ArrayList<BigDecimal>();
    }
    this.maxBal.add(maxBalItem);
    return this;
  }

   /**
   * An upper bound to enforce on the periodic balance. Each item in the array corresponds to a period in the simulation. If the length of the array is less than the number of simulation periods, it is conformed to the appropriate length by persisting the final value in the array.
   * @return maxBal
  **/
  @ApiModelProperty(value = "An upper bound to enforce on the periodic balance. Each item in the array corresponds to a period in the simulation. If the length of the array is less than the number of simulation periods, it is conformed to the appropriate length by persisting the final value in the array.")
  public List<BigDecimal> getMaxBal() {
    return maxBal;
  }

  public void setMaxBal(List<BigDecimal> maxBal) {
    this.maxBal = maxBal;
  }

  public MonteCarlo minSample(List<BigDecimal> minSample) {
    this.minSample = minSample;
    return this;
  }

  public MonteCarlo addMinSampleItem(BigDecimal minSampleItem) {
    if (this.minSample == null) {
      this.minSample = new ArrayList<BigDecimal>();
    }
    this.minSample.add(minSampleItem);
    return this;
  }

   /**
   * A lower bound to enforce on the randomly sampled periodic return. Each item in the array corresponds to a period in the simulation. If the length of the array is less than the number of simulation periods, it is conformed to the appropriate length by persisting the final value in the array.
   * @return minSample
  **/
  @ApiModelProperty(value = "A lower bound to enforce on the randomly sampled periodic return. Each item in the array corresponds to a period in the simulation. If the length of the array is less than the number of simulation periods, it is conformed to the appropriate length by persisting the final value in the array.")
  public List<BigDecimal> getMinSample() {
    return minSample;
  }

  public void setMinSample(List<BigDecimal> minSample) {
    this.minSample = minSample;
  }

  public MonteCarlo maxSample(List<BigDecimal> maxSample) {
    this.maxSample = maxSample;
    return this;
  }

  public MonteCarlo addMaxSampleItem(BigDecimal maxSampleItem) {
    if (this.maxSample == null) {
      this.maxSample = new ArrayList<BigDecimal>();
    }
    this.maxSample.add(maxSampleItem);
    return this;
  }

   /**
   * An upper bound to enforce on the randomly sampled periodic return. Each item in the array corresponds to a period in the simulation. If the length of the array is less than the number of simulation periods, it is conformed to the appropriate length by persisting the final value in the array.
   * @return maxSample
  **/
  @ApiModelProperty(value = "An upper bound to enforce on the randomly sampled periodic return. Each item in the array corresponds to a period in the simulation. If the length of the array is less than the number of simulation periods, it is conformed to the appropriate length by persisting the final value in the array.")
  public List<BigDecimal> getMaxSample() {
    return maxSample;
  }

  public void setMaxSample(List<BigDecimal> maxSample) {
    this.maxSample = maxSample;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MonteCarlo monteCarlo = (MonteCarlo) o;
    return Objects.equals(this.cf, monteCarlo.cf) &&
        Objects.equals(this.mu, monteCarlo.mu) &&
        Objects.equals(this.sigma, monteCarlo.sigma) &&
        Objects.equals(this.retMod, monteCarlo.retMod) &&
        Objects.equals(this.initBal, monteCarlo.initBal) &&
        Objects.equals(this.n, monteCarlo.n) &&
        Objects.equals(this.removeOutliers, monteCarlo.removeOutliers) &&
        Objects.equals(this.resultType, monteCarlo.resultType) &&
        Objects.equals(this.p, monteCarlo.p) &&
        Objects.equals(this.minBal, monteCarlo.minBal) &&
        Objects.equals(this.maxBal, monteCarlo.maxBal) &&
        Objects.equals(this.minSample, monteCarlo.minSample) &&
        Objects.equals(this.maxSample, monteCarlo.maxSample);
  }

  @Override
  public int hashCode() {
    return Objects.hash(cf, mu, sigma, retMod, initBal, n, removeOutliers, resultType, p, minBal, maxBal, minSample, maxSample);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class MonteCarlo {\n");
    
    sb.append("    cf: ").append(toIndentedString(cf)).append("\n");
    sb.append("    mu: ").append(toIndentedString(mu)).append("\n");
    sb.append("    sigma: ").append(toIndentedString(sigma)).append("\n");
    sb.append("    retMod: ").append(toIndentedString(retMod)).append("\n");
    sb.append("    initBal: ").append(toIndentedString(initBal)).append("\n");
    sb.append("    n: ").append(toIndentedString(n)).append("\n");
    sb.append("    removeOutliers: ").append(toIndentedString(removeOutliers)).append("\n");
    sb.append("    resultType: ").append(toIndentedString(resultType)).append("\n");
    sb.append("    p: ").append(toIndentedString(p)).append("\n");
    sb.append("    minBal: ").append(toIndentedString(minBal)).append("\n");
    sb.append("    maxBal: ").append(toIndentedString(maxBal)).append("\n");
    sb.append("    minSample: ").append(toIndentedString(minSample)).append("\n");
    sb.append("    maxSample: ").append(toIndentedString(maxSample)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

